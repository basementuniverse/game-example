/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/camera/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/camera/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass Camera {\n    constructor(position, options) {\n        this.size = (0, vec_1.vec)();\n        this._actualPosition = (0, vec_1.vec)();\n        this.targetPosition = (0, vec_1.vec)();\n        this._actualScale = 1;\n        this.targetScale = 1;\n        this._actualPosition = position;\n        this.targetPosition = position;\n        this.options = Object.assign({}, Camera.defaultOptions, options !== null && options !== void 0 ? options : {});\n    }\n    get position() {\n        return this.targetPosition;\n    }\n    set position(value) {\n        this.targetPosition = value;\n    }\n    set positionImmediate(value) {\n        this._actualPosition = value;\n        this.targetPosition = value;\n    }\n    get actualPosition() {\n        return this._actualPosition;\n    }\n    get scale() {\n        return this.targetScale;\n    }\n    get actualScale() {\n        return this._actualScale;\n    }\n    set scale(value) {\n        this.targetScale = clamp(value, this.options.minScale, this.options.maxScale);\n    }\n    set scaleImmediate(value) {\n        this._actualScale = clamp(value, this.options.minScale, this.options.maxScale);\n        this.targetScale = this._actualScale;\n    }\n    /**\n     * Get screen bounds based on the current camera position and scale\n     */\n    get bounds() {\n        return {\n            top: this._actualPosition.y - (this.size.y / 2) / this._actualScale,\n            bottom: this._actualPosition.y + (this.size.y / 2) / this._actualScale,\n            left: this._actualPosition.x - (this.size.x / 2) / this._actualScale,\n            right: this._actualPosition.x + (this.size.x / 2) / this._actualScale\n        };\n    }\n    /**\n     * Convert a screen position to a world position\n     */\n    positionToWorld(position) {\n        const bounds = this.bounds;\n        return vec_1.vec.add({ x: bounds.left, y: bounds.top }, vec_1.vec.mul(position, 1 / this.scale));\n    }\n    /**\n     * Update context transforms to match camera position and scale\n     */\n    draw(context, screen) {\n        this.size = (0, vec_1.vec)(screen);\n        // Maybe clamp position to bounds\n        if (this.options.bounds) {\n            const screenScaled = vec_1.vec.map(vec_1.vec.mul(this.size, 1 / this._actualScale), Math.ceil);\n            // If the scaled screen size is larger than allowed bounds, we resize\n            // the bounds to prevent jittering\n            const actualBounds = {\n                ...this.options.bounds,\n            };\n            if (screenScaled.x > actualBounds.right - actualBounds.left) {\n                const boundsWidth = actualBounds.right - actualBounds.left;\n                const halfDiff = (screenScaled.x - boundsWidth) / 2;\n                actualBounds.left -= halfDiff;\n                actualBounds.right += halfDiff;\n            }\n            if (screenScaled.y > actualBounds.bottom - actualBounds.top) {\n                const boundsHeight = actualBounds.bottom - actualBounds.top;\n                const halfDiff = (screenScaled.y - boundsHeight) / 2;\n                actualBounds.top -= halfDiff;\n                actualBounds.bottom += halfDiff;\n            }\n            const halfScreenScaled = vec_1.vec.map(vec_1.vec.mul(screenScaled, 1 / 2), Math.ceil);\n            const minPosition = (0, vec_1.vec)(actualBounds.left + halfScreenScaled.x, actualBounds.top + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec)(actualBounds.right - halfScreenScaled.x, actualBounds.bottom - halfScreenScaled.y);\n            this.targetPosition.x = clamp(this.targetPosition.x, minPosition.x, maxPosition.x);\n            this.targetPosition.y = clamp(this.targetPosition.y, minPosition.y, maxPosition.y);\n        }\n        const d = vec_1.vec.sub(this._actualPosition, this.targetPosition);\n        this._actualPosition = vec_1.vec.add(this.position, vec_1.vec.mul(d, this.options.moveEaseAmount));\n        const s = clamp(this.targetScale, this.options.minScale, this.options.maxScale);\n        this._actualScale = s + (this._actualScale - s) * this.options.scaleEaseAmount;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.translate((this.size.x / 2) - this._actualPosition.x * this._actualScale, (this.size.y / 2) - this._actualPosition.y * this._actualScale);\n        context.scale(this._actualScale, this._actualScale);\n    }\n}\nexports[\"default\"] = Camera;\nCamera.defaultOptions = {\n    allowScale: true,\n    minScale: 0.5,\n    maxScale: 4,\n    moveEaseAmount: 0.1,\n    scaleEaseAmount: 0.1,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_26398__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_26398__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_26398__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/content-manager/build/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@basementuniverse/content-manager/build/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content-loaders/audio.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/audio.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AudioLoader = void 0;\nconst AudioLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const audio = new Audio(url);\n        audio.addEventListener('loadeddata', () => {\n            resolve(audio);\n        });\n        audio.addEventListener('error', () => {\n            reject(`Error loading audio \"${url}\"`);\n        });\n    });\n};\nexports.AudioLoader = AudioLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/audio.loader.ts?");

/***/ }),

/***/ "./content-loaders/font.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/font.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FontLoader = void 0;\nconst FontLoader = async (url, family) => {\n    return new Promise((resolve, reject) => {\n        const font = new FontFace(family, `url(${url})`);\n        font.load()\n            .then(font => {\n            document.fonts.add(font);\n            resolve(font);\n        })\n            .catch(() => {\n            reject(`Error loading font \"${url}\"`);\n        });\n    });\n};\nexports.FontLoader = FontLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/font.loader.ts?");

/***/ }),

/***/ "./content-loaders/image.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/image.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageLoader = void 0;\nconst ImageLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.src = url;\n        image.addEventListener('load', () => {\n            resolve(image);\n        });\n        image.addEventListener('error', () => {\n            reject(`Error loading image \"${url}\"`);\n        });\n    });\n};\nexports.ImageLoader = ImageLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/image.loader.ts?");

/***/ }),

/***/ "./content-loaders/index.ts":
/*!**********************************!*\
  !*** ./content-loaders/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./audio.loader */ \"./content-loaders/audio.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./font.loader */ \"./content-loaders/font.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./image.loader */ \"./content-loaders/image.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./json.loader */ \"./content-loaders/json.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./text.loader */ \"./content-loaders/text.loader.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/index.ts?");

/***/ }),

/***/ "./content-loaders/json.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/json.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONLoader = void 0;\nconst JSONLoader = async (urlOrData) => {\n    if (typeof urlOrData === 'string' &&\n        urlOrData.startsWith('http')) {\n        return new Promise((resolve, reject) => {\n            window.fetch(urlOrData, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'application/json;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.json();\n            })\n                .then(json => {\n                resolve(json);\n            })\n                .catch(() => {\n                reject(`Error loading json \"${urlOrData}\"`);\n            });\n        });\n    }\n    return urlOrData;\n};\nexports.JSONLoader = JSONLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/json.loader.ts?");

/***/ }),

/***/ "./content-loaders/text.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/text.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextLoader = void 0;\nconst TextLoader = async (urlOrText) => {\n    if (urlOrText.startsWith('http')) {\n        return new Promise((resolve, reject) => {\n            window.fetch(urlOrText, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'text/plain;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.text();\n            })\n                .then(data => {\n                resolve(data);\n            })\n                .catch(() => {\n                reject(`Error loading text \"${urlOrText}\"`);\n            });\n        });\n    }\n    return urlOrText.toString();\n};\nexports.TextLoader = TextLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/text.loader.ts?");

/***/ }),

/***/ "./content-processors/image-name.processor.ts":
/*!****************************************************!*\
  !*** ./content-processors/image-name.processor.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageNameProcessor = void 0;\nconst defaultOptions = {\n    imageNameFieldName: 'imageName',\n    imageFieldName: 'image',\n};\nconst ImageNameProcessor = async (content, item, options) => {\n    const actualOptions = Object.assign({}, defaultOptions, options !== null && options !== void 0 ? options : {});\n    if (typeof item.content === 'object' &&\n        item.content !== null) {\n        const processObject = (o) => {\n            var _a;\n            for (const key in o) {\n                if (key === actualOptions.imageNameFieldName) {\n                    const imageName = o[key];\n                    const imageItem = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n                    if (imageItem) {\n                        o[actualOptions.imageFieldName] = imageItem;\n                        delete o[key];\n                    }\n                }\n                else if (typeof o[key] === 'object' &&\n                    o[key] !== null) {\n                    processObject(o[key]);\n                }\n            }\n        };\n        processObject(item.content);\n    }\n};\nexports.ImageNameProcessor = ImageNameProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/image-name.processor.ts?");

/***/ }),

/***/ "./content-processors/index.ts":
/*!*************************************!*\
  !*** ./content-processors/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./image-name.processor */ \"./content-processors/image-name.processor.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/index.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentItemStatus = exports.ContentManagerStatus = exports.ContentItemType = void 0;\nconst content_loaders_1 = __webpack_require__(/*! ./content-loaders */ \"./content-loaders/index.ts\");\nconst content_processors_1 = __webpack_require__(/*! ./content-processors */ \"./content-processors/index.ts\");\nvar ContentItemType;\n(function (ContentItemType) {\n    ContentItemType[\"JSON\"] = \"json\";\n    ContentItemType[\"Font\"] = \"font\";\n    ContentItemType[\"Image\"] = \"image\";\n    ContentItemType[\"Audio\"] = \"audio\";\n    ContentItemType[\"Text\"] = \"text\";\n})(ContentItemType = exports.ContentItemType || (exports.ContentItemType = {}));\nvar ContentManagerStatus;\n(function (ContentManagerStatus) {\n    ContentManagerStatus[\"Idle\"] = \"idle\";\n    ContentManagerStatus[\"Loading\"] = \"loading\";\n    ContentManagerStatus[\"Processing\"] = \"processing\";\n    ContentManagerStatus[\"Ready\"] = \"ready\";\n})(ContentManagerStatus = exports.ContentManagerStatus || (exports.ContentManagerStatus = {}));\nvar ContentItemStatus;\n(function (ContentItemStatus) {\n    ContentItemStatus[\"Idle\"] = \"idle\";\n    ContentItemStatus[\"Loading\"] = \"loading\";\n    ContentItemStatus[\"Loaded\"] = \"loaded\";\n    ContentItemStatus[\"Processing\"] = \"processing\";\n    ContentItemStatus[\"Processed\"] = \"processed\";\n})(ContentItemStatus = exports.ContentItemStatus || (exports.ContentItemStatus = {}));\nconst defaultContentLoaders = {\n    [ContentItemType.JSON]: content_loaders_1.JSONLoader,\n    [ContentItemType.Font]: content_loaders_1.FontLoader,\n    [ContentItemType.Image]: content_loaders_1.ImageLoader,\n    [ContentItemType.Audio]: content_loaders_1.AudioLoader,\n    [ContentItemType.Text]: content_loaders_1.TextLoader,\n};\nconst defaultContentProcessors = {\n    imageName: content_processors_1.ImageNameProcessor,\n};\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nfunction randomBetween(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst MIN_SLEEP_TIME = 1000;\nconst MAX_SLEEP_TIME = 3000;\nclass ContentManager {\n    constructor(options) {\n        var _a, _b, _c;\n        this.currentContentList = [];\n        this.currentProgress = 0;\n        this.currentTotalProgress = 0;\n        this.content = {};\n        this.status = ContentManagerStatus.Idle;\n        this.options = Object.assign({}, ContentManager.defaultOptions, options !== null && options !== void 0 ? options : {}, {\n            loaders: {\n                ...ContentManager.defaultOptions.loaders,\n                ...((_a = options === null || options === void 0 ? void 0 : options.loaders) !== null && _a !== void 0 ? _a : {}),\n            },\n            processors: {\n                ...((_b = ContentManager.defaultOptions.processors) !== null && _b !== void 0 ? _b : {}),\n                ...((_c = options === null || options === void 0 ? void 0 : options.processors) !== null && _c !== void 0 ? _c : {}),\n            },\n        });\n    }\n    /**\n     * Initialise the content manager and provide configuration options\n     */\n    static initialise(options) {\n        if (ContentManager.instance !== undefined) {\n            throw new Error('Content manager already initialised');\n        }\n        ContentManager.instance = new ContentManager(options);\n    }\n    static dispose() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not initialised');\n        }\n        delete ContentManager.instance;\n    }\n    static getInstance() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not properly initialised');\n        }\n        return ContentManager.instance;\n    }\n    /**\n     * Current loading progress, represented as a unit scalar [0, 1]\n     */\n    static get progress() {\n        const instance = ContentManager.getInstance();\n        return instance.getProgress();\n    }\n    /**\n     * Current content manager status\n     */\n    static get status() {\n        const instance = ContentManager.getInstance();\n        return instance.status;\n    }\n    getProgress() {\n        if (!this.currentContentList.length || this.currentTotalProgress === 0) {\n            return 1;\n        }\n        return clamp(this.currentProgress / this.currentTotalProgress);\n    }\n    /**\n     * Load content items\n     *\n     * Existing content items will be retained, and any content items which\n     * already exist will be re-loaded\n     */\n    static async load(items) {\n        var _a, _b, _c, _d, _e;\n        if (!items || items.length === 0) {\n            return;\n        }\n        const instance = ContentManager.getInstance();\n        if (!instance.options.loaders ||\n            Object.keys(instance.options.loaders).length === 0) {\n            throw new Error('No content loaders defined');\n        }\n        instance.currentContentList = items;\n        // Calculate how many tasks we need to perform\n        const countTotalToLoad = items.length;\n        const countTotalToProcess = items.reduce((a, c) => { var _a; return a + ((_a = c.processors) !== null && _a !== void 0 ? _a : []).length; }, 0);\n        instance.currentProgress = 0;\n        instance.currentTotalProgress = countTotalToLoad + countTotalToProcess;\n        // Load items\n        instance.status = ContentManagerStatus.Loading;\n        for (const item of items) {\n            if (!(item.type in instance.options.loaders)) {\n                throw new Error(`No content loader defined for type \"${item.type}\"`);\n            }\n            if (instance.options.simulateSlowLoading) {\n                await sleep(randomBetween((_a = instance.options.slowLoadingTimeMin) !== null && _a !== void 0 ? _a : MIN_SLEEP_TIME, (_b = instance.options.slowLoadingTimeMax) !== null && _b !== void 0 ? _b : MAX_SLEEP_TIME));\n            }\n            const contentItem = {\n                name: item.name,\n                type: item.type,\n                content: null,\n                status: ContentItemStatus.Loading,\n            };\n            instance.content[item.name] = contentItem;\n            contentItem.content = await instance.options.loaders[item.type](...item.args);\n            contentItem.status = ContentItemStatus.Loaded;\n            instance.currentProgress++;\n        }\n        // Process items\n        instance.status = ContentManagerStatus.Processing;\n        for (const item of items) {\n            if (!item.processors || item.processors.length === 0) {\n                continue;\n            }\n            if (!instance.options.processors ||\n                Object.keys(instance.options.processors).length === 0) {\n                throw new Error('No content processors defined');\n            }\n            const contentItem = instance.content[item.name];\n            if (!contentItem) {\n                // We should never reach this point; the item will have been loaded\n                // and added to the instance's content dictionary... but just in case\n                throw new Error(`Cannot find item with name \"${item.name}\"`);\n            }\n            if (instance.options.simulateSlowProcessing) {\n                await sleep(randomBetween((_c = instance.options.slowProcessingTimeMin) !== null && _c !== void 0 ? _c : MIN_SLEEP_TIME, (_d = instance.options.slowProcessingTimeMax) !== null && _d !== void 0 ? _d : MAX_SLEEP_TIME));\n            }\n            contentItem.status = ContentItemStatus.Processing;\n            for (const processor of item.processors) {\n                if (!(processor.name in instance.options.processors)) {\n                    throw new Error(`No content processor defined with name \"${processor.name}\"`);\n                }\n                await instance.options.processors[processor.name](instance.content, contentItem, ...((_e = processor.args) !== null && _e !== void 0 ? _e : []));\n                instance.currentProgress++;\n            }\n            contentItem.status = ContentItemStatus.Processed;\n        }\n        instance.status = ContentManagerStatus.Ready;\n    }\n    /**\n     * Retrieve a content item by name\n     */\n    static get(name) {\n        const instance = ContentManager.getInstance();\n        if (!(name in instance.content)) {\n            if (instance.options.throwOnNotFound) {\n                throw new Error(`Content item \"${name}\" not found`);\n            }\n            return undefined;\n        }\n        return instance.content[name].content;\n    }\n}\nexports[\"default\"] = ContentManager;\nContentManager.defaultOptions = {\n    loaders: defaultContentLoaders,\n    processors: defaultContentProcessors,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_19914__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_19914__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_19914__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/debug/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@basementuniverse/debug/build/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass Debug {\n    constructor(options) {\n        if (options === null || options === void 0 ? void 0 : options.defaultValue) {\n            options.defaultValue = Object.assign({}, Debug.defaultOptions.defaultValue, options.defaultValue);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultChart) {\n            options.defaultChart = Object.assign({}, Debug.defaultOptions.defaultChart, options.defaultChart);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultMarker) {\n            options.defaultMarker = Object.assign({}, Debug.defaultOptions.defaultMarker, options.defaultMarker);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultBorder) {\n            options.defaultBorder = Object.assign({}, Debug.defaultOptions.defaultBorder, options.defaultBorder);\n        }\n        this.options = Object.assign({}, Debug.defaultOptions, options !== null && options !== void 0 ? options : {});\n        this.values = new Map();\n        this.charts = new Map();\n        this.markers = new Map();\n        this.borders = new Map();\n    }\n    /**\n     * Initialise the debug renderer for displaying values and markers\n     */\n    static initialise(options = {}) {\n        if (Debug.instance !== undefined) {\n            throw new Error('Debug has already been initialised');\n        }\n        Debug.instance = new Debug(options);\n    }\n    static getInstance() {\n        if (Debug.instance === undefined) {\n            throw new Error('Debug not properly initialised');\n        }\n        return Debug.instance;\n    }\n    /**\n     * Show a debug value\n     */\n    static value(label, value, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.values.set(label, Object.assign({}, instance.options.defaultValue, (_a = instance.values.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value }));\n    }\n    /**\n     * Show a debug chart\n     */\n    static chart(label, value, options) {\n        var _a, _b;\n        const instance = Debug.getInstance();\n        const currentChart = instance.charts.get(label);\n        instance.charts.set(label, Object.assign({}, instance.options.defaultChart, currentChart !== null && currentChart !== void 0 ? currentChart : {}, options !== null && options !== void 0 ? options : {}, {\n            label,\n            values: [...(_a = currentChart === null || currentChart === void 0 ? void 0 : currentChart.values) !== null && _a !== void 0 ? _a : [], value].slice(-((_b = options === null || options === void 0 ? void 0 : options.valueBufferSize) !== null && _b !== void 0 ? _b : instance.options.defaultChart.valueBufferSize)),\n        }));\n    }\n    /**\n     * Remove a debug chart\n     */\n    static removeChart(label) {\n        const instance = Debug.getInstance();\n        instance.charts.delete(label);\n    }\n    /**\n     * Show a marker in world or screen space\n     */\n    static marker(label, value, position, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.markers.set(label, Object.assign({}, instance.options.defaultMarker, (_a = instance.markers.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Show a border in world or screen space\n     */\n    static border(label, value, position, options) {\n        var _a;\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) === 'circle' && (options === null || options === void 0 ? void 0 : options.radius) === undefined) {\n            // Don't add the border if it's circular but we don't have a radius\n            return;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) !== 'circle' && (options === null || options === void 0 ? void 0 : options.size) === undefined) {\n            // Don't add the border if it's rectangular (default is rectangular) but\n            // we don't have a size\n            return;\n        }\n        const instance = Debug.getInstance();\n        instance.borders.set(label, Object.assign({}, instance.options.defaultBorder, (_a = instance.borders.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Render the debug values and markers onto a canvas\n     */\n    static draw(context) {\n        const instance = Debug.getInstance();\n        // Draw world-space markers & borders\n        context.save();\n        instance.markers.forEach(marker => {\n            if (marker.space === 'world') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            if (border.space === 'world') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Draw values, charts and screen-space markers & borders\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        let position;\n        let leftY = instance.options.margin;\n        let rightY = instance.options.margin;\n        const lineHeight = (instance.options.lineHeight +\n            instance.options.padding * 2);\n        instance.values.forEach(value => {\n            var _a, _b, _c, _d, _e, _f;\n            switch (value.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawLabel(context, Debug.prepareLabel((_a = value.label) !== null && _a !== void 0 ? _a : '', (_b = value.value) !== null && _b !== void 0 ? _b : '', value.showLabel, true), position, value.align, (_c = value.padding) !== null && _c !== void 0 ? _c : instance.options.padding, (_d = value.font) !== null && _d !== void 0 ? _d : instance.options.font, (_e = value.foregroundColour) !== null && _e !== void 0 ? _e : instance.options.foregroundColour, (_f = value.backgroundColour) !== null && _f !== void 0 ? _f : instance.options.backgroundColour);\n        });\n        instance.charts.forEach(chart => {\n            var _a, _b, _c, _d, _e;\n            switch (chart.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawChart(context, Debug.prepareLabel((_a = chart.label) !== null && _a !== void 0 ? _a : '', '', chart.showLabel, false), position, chart.align, (_b = chart.padding) !== null && _b !== void 0 ? _b : instance.options.padding, (_c = chart.font) !== null && _c !== void 0 ? _c : instance.options.font, (_d = chart.foregroundColour) !== null && _d !== void 0 ? _d : instance.options.foregroundColour, (_e = chart.backgroundColour) !== null && _e !== void 0 ? _e : instance.options.backgroundColour, chart.chartBackgroundColour, chart.values, chart.valueBufferSize, chart.valueBufferStride, chart.minValue, chart.maxValue, chart.barWidth, chart.barColours);\n        });\n        instance.markers.forEach(marker => {\n            if (marker.space === 'screen') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            if (border.space === 'screen') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Clear values, markers & borders ready for next frame\n        instance.values.clear();\n        instance.markers.clear();\n        instance.borders.clear();\n    }\n    static prepareLabel(label, value, showLabel, showValue) {\n        const actualLabel = (showLabel && label) ? label : '';\n        const actualValue = (!!showValue && value !== '') ? value.toString() : '';\n        const separator = (actualLabel && actualValue) ? ': ' : '';\n        return `${actualLabel}${separator}${actualValue}`;\n    }\n    drawLabel(context, text, position, align, padding, font, foregroundColour, backgroundColour) {\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const backgroundSize = {\n            width: context.measureText(text).width + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw text\n        context.fillStyle = foregroundColour;\n        context.fillText(text, x, position.y);\n        context.restore();\n    }\n    drawChart(context, label, position, align, padding, font, foregroundColour, backgroundColour, chartBackgroundColour, values, valueBufferSize, valueBufferStride, minValue, maxValue, barWidth, barColours) {\n        var _a, _b;\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const chartSize = {\n            width: barWidth * Math.ceil(valueBufferSize / Math.max(valueBufferStride, 1)),\n            height: this.options.lineHeight + padding * 2,\n        };\n        const labelSize = {\n            width: context.measureText(label).width,\n            height: this.options.lineHeight,\n        };\n        const backgroundSize = {\n            width: (labelSize.width +\n                padding +\n                chartSize.width) + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw label\n        if (label) {\n            context.fillStyle = foregroundColour;\n            context.fillText(label, x, position.y);\n        }\n        // Draw chart\n        if (chartBackgroundColour) {\n            context.fillStyle = chartBackgroundColour;\n            context.fillRect(x + padding + labelSize.width + padding, position.y - padding, chartSize.width, chartSize.height);\n        }\n        const range = maxValue - minValue;\n        const barOffset = (0, vec_1.vec)(x + padding + labelSize.width + padding, position.y - padding);\n        for (let i = 0; i < Math.ceil(values.length / Math.max(valueBufferStride, 1)); i++) {\n            let value;\n            if (valueBufferStride <= 1) {\n                value = values[i];\n            }\n            else {\n                value = values\n                    .slice(i * valueBufferStride, (i + 1) * valueBufferStride)\n                    .reduce((a, b) => a + b, 0) / valueBufferStride;\n            }\n            const barSize = (0, vec_1.vec)(barWidth, Math.round(chartSize.height * (value - minValue) / range));\n            const barPosition = vec_1.vec.add(barOffset, (0, vec_1.vec)((values.length < valueBufferSize\n                ? Math.ceil((valueBufferSize - values.length) / valueBufferStride) * barWidth\n                : 0) + i * barWidth, chartSize.height - barSize.y));\n            const barColour = (_b = (barColours\n                ? (_a = [...barColours].reverse().find(c => values[i] >= c.offset)) === null || _a === void 0 ? void 0 : _a.colour\n                : undefined)) !== null && _b !== void 0 ? _b : foregroundColour;\n            context.fillStyle = barColour;\n            context.fillRect(barPosition.x, barPosition.y, barSize.x, barSize.y);\n        }\n        context.restore();\n    }\n    drawMarker(context, marker) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = marker.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (marker.showLabel || marker.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = marker.label) !== null && _b !== void 0 ? _b : '', (_c = marker.value) !== null && _c !== void 0 ? _c : '', marker.showLabel, marker.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), marker.labelOffset), 'left', (_d = marker.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = marker.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = marker.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = marker.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (marker.showMarker) {\n            context.lineWidth = 2;\n            context.strokeStyle = context.fillStyle = marker.markerColour;\n            switch (marker.markerStyle) {\n                case 'x':\n                    this.drawCross(context, position, marker.markerSize);\n                    break;\n                case '+':\n                    this.drawPlus(context, position, marker.markerSize);\n                    break;\n                case '.':\n                    this.drawDot(context, position, marker.markerSize);\n                    break;\n            }\n        }\n        context.restore();\n    }\n    drawCross(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n    }\n    drawPlus(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.stroke();\n    }\n    drawDot(context, position, size) {\n        context.beginPath();\n        context.arc(position.x, position.y, size / 2, 0, Math.PI * 2);\n        context.fill();\n    }\n    drawBorder(context, border) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = border.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (border.showLabel || border.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = border.label) !== null && _b !== void 0 ? _b : '', (_c = border.value) !== null && _c !== void 0 ? _c : '', border.showLabel, border.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), border.labelOffset), 'left', (_d = border.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = border.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = border.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = border.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (border.showBorder) {\n            context.lineWidth = border.borderWidth;\n            context.strokeStyle = context.fillStyle = border.borderColour;\n            switch (border.borderStyle) {\n                case 'solid':\n                    context.setLineDash([]);\n                    break;\n                case 'dashed':\n                    context.setLineDash([border.borderDashSize, border.borderDashSize]);\n                    break;\n                case 'dotted':\n                    context.setLineDash([border.borderWidth, border.borderWidth]);\n                    break;\n            }\n            switch (border.borderShape) {\n                case 'rectangle':\n                    if (border.size) {\n                        this.drawRectangle(context, position, border.size);\n                    }\n                    break;\n                case 'circle':\n                    if (border.radius) {\n                        this.drawCircle(context, position, border.radius);\n                    }\n                    break;\n            }\n        }\n        context.restore();\n    }\n    drawRectangle(context, position, size) {\n        context.beginPath();\n        context.rect(position.x, position.y, size.x, size.y);\n        context.stroke();\n    }\n    drawCircle(context, position, radius) {\n        context.beginPath();\n        context.arc(position.x, position.y, radius, 0, Math.PI * 2);\n        context.stroke();\n    }\n}\nexports[\"default\"] = Debug;\nDebug.defaultOptions = {\n    margin: 10,\n    padding: 4,\n    font: '10pt Lucida Console, monospace',\n    lineHeight: 12,\n    lineMargin: 0,\n    foregroundColour: '#fff',\n    backgroundColour: '#333',\n    defaultValue: {\n        align: 'left',\n        showLabel: true,\n    },\n    defaultChart: {\n        values: [],\n        valueBufferSize: 60,\n        valueBufferStride: 1,\n        minValue: 0,\n        maxValue: 100,\n        barWidth: 2,\n        align: 'left',\n        showLabel: true,\n        chartBackgroundColour: '#222',\n    },\n    defaultMarker: {\n        showLabel: true,\n        showValue: true,\n        showMarker: true,\n        markerSize: 6,\n        markerStyle: 'x',\n        markerColour: '#ccc',\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n    defaultBorder: {\n        showLabel: true,\n        showValue: true,\n        showBorder: true,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderShape: 'rectangle',\n        borderColour: '#ccc',\n        borderDashSize: 5,\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n};\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_40469__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_40469__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_40469__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/input-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/input-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass InputManager {\n    constructor(options) {\n        this.keyboardState = {};\n        this.previousKeyboardState = {};\n        this.mouseState = { button: false, position: (0, vec_1.vec)(), wheel: 0 };\n        this.previousMouseState = { button: false, position: (0, vec_1.vec)(), wheel: 0 };\n        this.options = Object.assign({}, InputManager.defaultOptions, options !== null && options !== void 0 ? options : {});\n        // Set up event handlers\n        if (this.options.mouse) {\n            window.addEventListener('mousedown', () => {\n                this.mouseState.button = true;\n            });\n            window.addEventListener('mouseup', () => {\n                this.mouseState.button = false;\n            });\n            window.addEventListener('touchstart', () => {\n                this.mouseState.button = true;\n            });\n            window.addEventListener('touchend', () => {\n                this.mouseState.button = false;\n            });\n            window.addEventListener('mousemove', e => {\n                this.mouseState.position.x = e.offsetX;\n                this.mouseState.position.y = e.offsetY;\n            });\n            if (this.options.mouseWheel) {\n                window.addEventListener('wheel', e => {\n                    this.mouseState.wheel = e.deltaY > 0 ? 1 : -1;\n                });\n            }\n        }\n        if (this.options.keyboard) {\n            window.addEventListener('keydown', e => {\n                this.keyboardState[e.code] = true;\n            });\n            window.addEventListener('keyup', e => {\n                this.keyboardState[e.code] = false;\n            });\n        }\n    }\n    /**\n     * Initialise the input manager for managing mouse and keyboard input\n     */\n    static initialise(options) {\n        if (InputManager.instance !== undefined) {\n            throw new Error('Input manager already initialised');\n        }\n        InputManager.instance = new InputManager(options);\n    }\n    static getInstance() {\n        if (InputManager.instance === undefined) {\n            throw new Error('Input manager not properly initialised');\n        }\n        return InputManager.instance;\n    }\n    /**\n     * Update the state of the input devices\n     */\n    static update() {\n        const instance = InputManager.getInstance();\n        instance.previousKeyboardState = Object.assign({}, instance.keyboardState);\n        instance.previousMouseState = {\n            ...instance.mouseState,\n            position: vec_1.vec.cpy(instance.mouseState.position),\n        };\n        instance.mouseState.wheel = 0;\n    }\n    /**\n     * Check if a key is currently pressed down\n     */\n    static keyDown(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key is down\n        if (!code) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.keyboardState[code];\n    }\n    /**\n     * Check if a key has been pressed since the last frame\n     */\n    static keyPressed(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was pressed\n        if (!code) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k] &&\n                    (!(k in instance.previousKeyboardState) ||\n                        !instance.previousKeyboardState[k])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.keyboardState[code] && !instance.previousKeyboardState[code];\n    }\n    /**\n     * Check if a key has been released since the last frame\n     */\n    static keyReleased(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was released\n        if (!code) {\n            for (const k in instance.keyboardState) {\n                if (!instance.keyboardState[k] &&\n                    !!instance.previousKeyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !instance.keyboardState[code] && !!instance.previousKeyboardState[code];\n    }\n    /**\n     * Check if a mouse button is currently pressed down\n     */\n    static mouseDown() {\n        const instance = InputManager.getInstance();\n        return !!instance.mouseState.button;\n    }\n    /**\n     * Check if a mouse button has been pressed since the last frame\n     */\n    static mousePressed() {\n        const instance = InputManager.getInstance();\n        return !!instance.mouseState.button && !instance.previousMouseState.button;\n    }\n    /**\n     * Check if a mouse button has been released since the last frame\n     */\n    static mouseReleased() {\n        const instance = InputManager.getInstance();\n        return !instance.mouseState.button && !!instance.previousMouseState.button;\n    }\n    /**\n     * Check if the mousewheel is scrolling up\n     */\n    static mouseWheelUp() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel > 0;\n    }\n    /**\n     * Check if the mousewheel is scrolling down\n     */\n    static mouseWheelDown() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel < 0;\n    }\n    /**\n     * Get the current mouse position in screen-space\n     */\n    static get mousePosition() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.position;\n    }\n}\nexports[\"default\"] = InputManager;\nInputManager.defaultOptions = {\n    mouse: true,\n    mouseWheel: true,\n    keyboard: true,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_27635__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_27635__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_27635__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/scene-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/scene-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = exports.SceneTransitionState = void 0;\nvar SceneTransitionState;\n(function (SceneTransitionState) {\n    SceneTransitionState[\"In\"] = \"in\";\n    SceneTransitionState[\"Out\"] = \"out\";\n    SceneTransitionState[\"None\"] = \"none\";\n})(SceneTransitionState = exports.SceneTransitionState || (exports.SceneTransitionState = {}));\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass SceneManager {\n    constructor() {\n        this.scenes = [];\n    }\n    /**\n     * Initialise the scene manager for managing game scenes\n     */\n    static initialise() {\n        if (SceneManager.instance) {\n            throw new Error('SceneManager already initialised');\n        }\n        SceneManager.instance = new SceneManager();\n    }\n    static getInstance() {\n        if (!SceneManager.instance) {\n            throw new Error('SceneManager not properly initialised');\n        }\n        return SceneManager.instance;\n    }\n    /**\n     * Push a scene onto the scene stack and start transitioning in\n     */\n    static push(scene, ...args) {\n        const instance = SceneManager.getInstance();\n        instance.scenes.push(scene);\n        // Initialise the scene and start the transition\n        scene.initialise(...args);\n        scene.transitionIn();\n        return scene;\n    }\n    /**\n     * Remove a scene from the scene stack after transitioning out\n     */\n    static pop() {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            let last = instance.scenes.length - 1;\n            // Remove the top-most scene that isn't currently transitioning out\n            while (last > 0 &&\n                instance.scenes[last].transitionState === SceneTransitionState.Out) {\n                last--;\n            }\n            if (last >= 0) {\n                const scene = instance.scenes[last];\n                // Start transitioning out\n                scene.transitionOut();\n                return scene;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Remove all scene from the scene stack\n     */\n    static clear() {\n        const instance = SceneManager.getInstance();\n        instance.scenes.forEach(scene => {\n            if (scene.transitionState !== SceneTransitionState.Out) {\n                scene.transitionOut();\n            }\n        });\n    }\n    /**\n     * Update the scene manager and the current scene\n     */\n    static update(dt, ...args) {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            // Only update the top-most scene that isn't currently transitioning out\n            for (let i = instance.scenes.length; i--;) {\n                if (instance.scenes[i].transitionState !== SceneTransitionState.Out) {\n                    instance.scenes[i].update(dt, ...args);\n                    break;\n                }\n            }\n            // Update all scene transitions\n            instance.scenes.forEach(scene => {\n                scene.updateTransition(dt);\n            });\n            // Remove any disposed scenes\n            instance.scenes = instance.scenes.filter(scene => !scene.disposed);\n        }\n    }\n    /**\n     * Render scenes on the screen\n     */\n    static draw(context, ...args) {\n        const instance = SceneManager.getInstance();\n        // Figure out which scenes we need to draw\n        const drawList = [];\n        for (let i = instance.scenes.length; i--;) {\n            const scene = instance.scenes[i];\n            drawList.push(scene);\n            // If transitioning, this scene is assumed to be transparent\n            // (we might want to show the scene underneath if we're doing e.g. a fade)\n            if (!scene.transparent &&\n                scene.transitionState === SceneTransitionState.None) {\n                break;\n            }\n        }\n        // Draw the scenes in bottom -> top order\n        drawList.reverse().forEach(scene => {\n            scene.draw(context, ...args);\n        });\n    }\n    /**\n     * Let all scenes know that a resize event has occurred\n     */\n    static resize(width, height) {\n        var _a;\n        const instance = SceneManager.getInstance();\n        for (const scene of instance.scenes) {\n            (_a = scene.resize) === null || _a === void 0 ? void 0 : _a.call(scene, width, height);\n        }\n    }\n}\nexports[\"default\"] = SceneManager;\nclass Scene {\n    constructor(options) {\n        this.defaultOptions = {\n            transitionTime: 2,\n            transparent: true,\n        };\n        this.transitionState = SceneTransitionState.None;\n        this.transitionAmount = 0;\n        this.transitionTime = 0;\n        this.transparent = false;\n        this.disposed = false;\n        const actualOptions = Object.assign({}, this.defaultOptions, options);\n        this.transitionTime = actualOptions.transitionTime;\n        this.transparent = actualOptions.transparent;\n        this.onTransitionedIn = actualOptions.onTransitionedIn;\n        this.onTransitionedOut = actualOptions.onTransitionedOut;\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    transitionIn() {\n        this.transitionState = SceneTransitionState.In;\n    }\n    transitionOut() {\n        this.transitionState = SceneTransitionState.Out;\n    }\n    updateTransition(dt) {\n        var _a, _b;\n        const amount = dt / this.transitionTime;\n        // Transitioning in\n        if (this.transitionState === SceneTransitionState.In) {\n            if (this.transitionAmount < 1) {\n                this.transitionAmount = clamp(this.transitionAmount + amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                (_a = this.onTransitionedIn) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        }\n        // Transitioning out\n        if (this.transitionState === SceneTransitionState.Out) {\n            if (this.transitionAmount > 0) {\n                this.transitionAmount = clamp(this.transitionAmount - amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                this.dispose();\n                (_b = this.onTransitionedOut) === null || _b === void 0 ? void 0 : _b.call(this);\n            }\n        }\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://@basementuniverse/scene-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.ts"](0, __webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/sprite/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/sprite/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spriteOptionsContentProcessor = exports.Sprite = exports.SpriteAnimationRepeatMode = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar SpriteAnimationRepeatMode;\n(function (SpriteAnimationRepeatMode) {\n    /**\n     * Loop this animation indefinitely\n     */\n    SpriteAnimationRepeatMode[\"Repeat\"] = \"repeat\";\n    /**\n     * Play once and then stop on the last frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndStop\"] = \"play-once-and-stop\";\n    /**\n     * Play once and then reset back to the first frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndReset\"] = \"play-once-and-reset\";\n})(SpriteAnimationRepeatMode = exports.SpriteAnimationRepeatMode || (exports.SpriteAnimationRepeatMode = {}));\nclass Sprite {\n    constructor(options) {\n        var _a, _b;\n        this.position = (0, vec_1.vec)();\n        this.size = (0, vec_1.vec)();\n        this.origin = (0, vec_1.vec)();\n        this.scale = 1;\n        this.rotation = 0;\n        this.currentAnimationOptions = null;\n        this.currentAnimationState = null;\n        this.currentImage = null;\n        this.currentAttachmentPoints = null;\n        const actualOptions = Object.assign({}, Sprite.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        for (const animation of Object.keys(actualOptions.animations)) {\n            for (const direction of Object.keys(actualOptions.animations[animation])) {\n                actualOptions.animations[animation][direction] = Object.assign({}, Sprite.DEFAULT_ANIMATION_OPTIONS, actualOptions.animations[animation][direction]);\n            }\n        }\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showSpriteTransforms: !!actualOptions.debug,\n                showSpriteBoundingBox: !!actualOptions.debug,\n                showAttachmentPoints: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        if (this.options.position) {\n            this.position = vec_1.vec.cpy(this.options.position);\n        }\n        if (this.options.size) {\n            this.size = vec_1.vec.cpy(this.options.size);\n        }\n        else {\n            // Default to the size of the base image if one exists\n            if (this.options.image) {\n                this.size = (0, vec_1.vec)(this.options.image.width, this.options.image.height);\n            }\n            else {\n                // Fall back to the size of the image in the first frame of the first\n                // available direction of the default animation if one exists\n                const defaultAnimationDirections = Object.values(this.options.animations[this.options.defaultAnimation])[0];\n                if (defaultAnimationDirections &&\n                    ((_b = (_a = defaultAnimationDirections.images) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n                    this.size = (0, vec_1.vec)(defaultAnimationDirections.images[0].width, defaultAnimationDirections.images[0].height);\n                }\n            }\n            // Otherwise leave the size as (0, 0)\n        }\n        if (this.options.origin) {\n            this.origin = vec_1.vec.cpy(this.options.origin);\n        }\n        else {\n            // Default to the center of the sprite based on size\n            this.origin = vec_1.vec.mul(this.size, 0.5);\n        }\n        if (this.options.scale) {\n            this.scale = this.options.scale;\n        }\n        if (this.options.rotation) {\n            this.rotation = this.options.rotation;\n        }\n        // Check and initialise direction\n        this._direction = this.options.defaultDirection;\n        if (this.options.directions.length === 0 ||\n            !this.options.directions.includes(this._direction)) {\n            throw new Error(`Invalid direction \"${this._direction}\"`);\n        }\n        // Check and initialise animation\n        this._animation = this.options.defaultAnimation;\n        const animations = Object.keys(this.options.animations);\n        if (animations.length === 0 ||\n            !animations.includes(this._animation)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        // Make sure attachment point keyframes are defined in ascending\n        // frame order in all animations\n        for (const animation of Object.keys(this.options.animations)) {\n            for (const direction of Object.keys(this.options.animations[animation])) {\n                if (this.options.animations[animation][direction].attachmentPointKeyframes) {\n                    for (const attachmentPoint of Object.keys(this\n                        .options\n                        .animations[animation][direction]\n                        .attachmentPointKeyframes)) {\n                        this\n                            .options\n                            .animations[animation][direction]\n                            .attachmentPointKeyframes[attachmentPoint]\n                            .sort((a, b) => a.frame - b.frame);\n                    }\n                }\n            }\n        }\n    }\n    get direction() {\n        return this._direction;\n    }\n    set direction(value) {\n        if (this.options.directions.includes(value)) {\n            this._direction = value;\n        }\n    }\n    get animation() {\n        return this._animation;\n    }\n    set animation(value) {\n        var _a, _b, _c, _d;\n        if (Object.keys(this.options.animations).includes(value)) {\n            const previous = this._animation;\n            this._animation = value;\n            // When switching animations, we might be part-way through and the\n            // new animation might have fewer frames, in which case we should clamp\n            // the current frame number\n            const currentFrameCount = (_b = (_a = this.options.animations[value][this.direction]) === null || _a === void 0 ? void 0 : _a.frameCount) !== null && _b !== void 0 ? _b : 1;\n            const previousFrameCount = (_d = (_c = this.options.animations[previous][this.direction]) === null || _c === void 0 ? void 0 : _c.frameCount) !== null && _d !== void 0 ? _d : 1;\n            if (currentFrameCount < previousFrameCount &&\n                this.currentAnimationState &&\n                this.currentAnimationState.currentFrame >= currentFrameCount) {\n                this.currentAnimationState.currentFrame = currentFrameCount - 1;\n            }\n        }\n    }\n    playAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = true;\n        }\n    }\n    pauseAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = false;\n        }\n    }\n    resetAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.currentFrame = 0;\n            this.currentAnimationState.currentFrameTime = 0;\n        }\n    }\n    getAttachmentPoint(name) {\n        var _a, _b;\n        return (_b = (_a = this.currentAttachmentPoints) === null || _a === void 0 ? void 0 : _a[name]) !== null && _b !== void 0 ? _b : null;\n    }\n    update(dt) {\n        this.currentAnimationOptions = this.updateAnimationOptions();\n        this.currentAnimationState = this.updateAnimationState(dt);\n        this.currentImage = this.updateImage();\n        this.currentAttachmentPoints = this.updateAttachmentPoints();\n    }\n    updateAnimationOptions() {\n        if (!(this._animation in this.options.animations)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        const directions = Object.keys(this.options.animations[this._animation]);\n        if (directions.length === 0) {\n            throw new Error(`No directions available for animation \"${this._animation}\"`);\n        }\n        if (this._direction in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation][this._direction];\n        }\n        if ('*' in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation]['*'];\n        }\n        return this.options.animations[this._animation][directions[0]];\n    }\n    updateAnimationState(dt) {\n        if (!this.currentAnimationOptions ||\n            !this.currentAnimationState) {\n            return {\n                playing: true,\n                currentFrame: 0,\n                currentFrameTime: 0,\n            };\n        }\n        if (this.currentAnimationState.playing) {\n            const frameTime = 1 / this.currentAnimationOptions.frameRate;\n            this.currentAnimationState.currentFrameTime += dt;\n            if (this.currentAnimationState.currentFrameTime > frameTime) {\n                const frameCount = this.currentAnimationOptions.frameCount;\n                this.currentAnimationState.currentFrame++;\n                this.currentAnimationState.currentFrameTime = 0;\n                if (this.currentAnimationState.currentFrame >= frameCount) {\n                    switch (this.currentAnimationOptions.mode) {\n                        case SpriteAnimationRepeatMode.PlayOnceAndReset:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                        case SpriteAnimationRepeatMode.PlayOnceAndStop:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = frameCount - 1;\n                            break;\n                        case SpriteAnimationRepeatMode.Repeat:\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                    }\n                }\n            }\n        }\n        return this.currentAnimationState;\n    }\n    updateImage() {\n        var _a, _b, _c;\n        if (!this.currentAnimationOptions ||\n            !this.currentAnimationState) {\n            return null;\n        }\n        if (!this.currentAnimationOptions.images ||\n            this.currentAnimationOptions.images.length === 0) {\n            return (_a = this.options.image) !== null && _a !== void 0 ? _a : null;\n        }\n        return (_c = (_b = this.currentAnimationOptions.images[this.currentAnimationState.currentFrame]) !== null && _b !== void 0 ? _b : this.options.image) !== null && _c !== void 0 ? _c : null;\n    }\n    updateAttachmentPoints() {\n        if (!this.options.attachmentPoints ||\n            this.options.attachmentPoints.length === 0) {\n            return null;\n        }\n        if (!this.currentAttachmentPoints) {\n            this.currentAttachmentPoints = Object.fromEntries(this.options.attachmentPoints.map(attachmentPoint => [\n                attachmentPoint.name,\n                attachmentPoint.offset\n            ]));\n        }\n        if (this.currentAnimationOptions &&\n            this.currentAnimationOptions.attachmentPointKeyframes &&\n            this.currentAnimationState) {\n            for (const name of Object.keys(this.currentAttachmentPoints)) {\n                if (name in this.currentAnimationOptions.attachmentPointKeyframes &&\n                    this.currentAnimationOptions.attachmentPointKeyframes[name].length > 0) {\n                    const previousKeyframe = this.findPreviousKeyframe(this.currentAnimationOptions.attachmentPointKeyframes[name], this.currentAnimationState.currentFrame);\n                    this.currentAttachmentPoints[name] = previousKeyframe.offset;\n                }\n            }\n        }\n        return this.currentAttachmentPoints;\n    }\n    findPreviousKeyframe(keyframes, currentFrame) {\n        const found = [...keyframes].reverse().find(keyframe => keyframe.frame <= currentFrame);\n        if (!found) {\n            return keyframes[keyframes.length - 1];\n        }\n        return found;\n    }\n    draw(context) {\n        var _a, _b, _c, _d;\n        context.save();\n        context.translate(this.position.x, this.position.y);\n        context.scale(this.scale, this.scale);\n        context.rotate(this.rotation);\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this);\n        if (this.currentImage) {\n            context.drawImage(this.currentImage, -this.origin.x, -this.origin.y, this.currentImage.width, this.currentImage.height);\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this);\n        if (this.options.debug.showSpriteBoundingBox) {\n            context.strokeStyle = Sprite.DEBUG_BOUNDING_BOX_COLOUR;\n            context.lineWidth = Sprite.DEBUG_BOUNDING_BOX_LINE_WIDTH;\n            context.strokeRect(-this.origin.x, -this.origin.y, this.size.x, this.size.y);\n        }\n        if (this.options.debug.showSpriteTransforms) {\n            this.drawTransformsMarker(context, (0, vec_1.vec)(), Sprite.DEBUG_TRANSFORMS_COLOUR_X, Sprite.DEBUG_TRANSFORMS_COLOUR_Y, Sprite.DEBUG_TRANSFORMS_LINE_WIDTH, Sprite.DEBUG_TRANSFORMS_SIZE);\n        }\n        if (this.options.debug.showAttachmentPoints &&\n            this.currentAttachmentPoints) {\n            for (const attachmentPoint of Object.values(this.currentAttachmentPoints)) {\n                this.drawCross(context, attachmentPoint, Sprite.DEBUG_ATTACHMENT_POINT_COLOUR, Sprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH, Sprite.DEBUG_ATTACHMENT_POINT_SIZE);\n            }\n        }\n        context.restore();\n    }\n    drawTransformsMarker(context, position, xColour, yColour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = xColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x + size, position.y);\n        context.stroke();\n        context.strokeStyle = yColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x, position.y + size);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.Sprite = Sprite;\nSprite.DEFAULT_OPTIONS = {\n    directions: ['default'],\n    defaultDirection: 'default',\n    animations: {\n        default: {\n            '*': {\n                name: 'default',\n                frameCount: 1,\n                frameRate: 1,\n                mode: SpriteAnimationRepeatMode.PlayOnceAndStop,\n            },\n        },\n    },\n    defaultAnimation: 'default',\n};\nSprite.DEFAULT_ANIMATION_OPTIONS = {\n    name: 'default',\n    frameCount: 1,\n    frameRate: 1,\n    mode: SpriteAnimationRepeatMode.Repeat,\n};\nSprite.DEBUG_BOUNDING_BOX_COLOUR = 'green';\nSprite.DEBUG_BOUNDING_BOX_LINE_WIDTH = 2;\nSprite.DEBUG_TRANSFORMS_COLOUR_X = 'red';\nSprite.DEBUG_TRANSFORMS_COLOUR_Y = 'orange';\nSprite.DEBUG_TRANSFORMS_LINE_WIDTH = 1;\nSprite.DEBUG_TRANSFORMS_SIZE = 10;\nSprite.DEBUG_ATTACHMENT_POINT_COLOUR = 'blue';\nSprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH = 2;\nSprite.DEBUG_ATTACHMENT_POINT_SIZE = 5;\n/**\n * Content Manager Processor wrapper which converts SpriteOptionsData into\n * SpriteOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function spriteOptionsContentProcessor(content, data) {\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.imageName) {\n        result.image = getImageFromContent(result.imageName);\n        delete result.imageName;\n    }\n    if (result.animations) {\n        for (const [animationName, animation] of Object.entries(result.animations)) {\n            for (const [directionName, direction] of Object.entries(animation)) {\n                if (direction.imageNames) {\n                    result.animations[animationName][directionName].images = direction\n                        .imageNames\n                        .map(getImageFromContent);\n                    delete result.animations[animationName][directionName].imageNames;\n                }\n            }\n        }\n    }\n    data.content = result;\n}\nexports.spriteOptionsContentProcessor = spriteOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_43554__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_43554__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_43554__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/texture-atlas/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/texture-atlas/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textureAtlasContentProcessor = exports.textureAtlas = void 0;\nconst DEFAULT_REPEATING_REGION_NAME_FORMAT = '{name}-{n}';\nconst DEFAULT_OPTIONS = {\n    relative: true,\n    width: 1,\n    height: 1,\n    regions: {\n        default: {\n            x: 0,\n            y: 0,\n        },\n    },\n    cellMargin: 0,\n};\n/**\n * Takes an image and some texture atlas options and returns a dictionary\n * of canvases indexed by region name\n */\nfunction textureAtlas(image, options) {\n    var _a, _b, _c, _d;\n    const actualOptions = Object.assign({}, DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n    if (actualOptions.width <= 0 || actualOptions.height <= 0) {\n        throw new Error('Width and height must be greater than 0');\n    }\n    if (Object.keys(actualOptions.regions).length === 0) {\n        throw new Error('No regions defined');\n    }\n    let cellWidth = 1;\n    let cellHeight = 1;\n    if (actualOptions.relative) {\n        let imageWidth = image.width;\n        let imageHeight = image.height;\n        if (actualOptions.cellMargin > 0) {\n            imageWidth -= actualOptions.cellMargin;\n            imageHeight -= actualOptions.cellMargin;\n        }\n        cellWidth = Math.ceil(imageWidth / actualOptions.width);\n        cellHeight = Math.ceil(imageHeight / actualOptions.height);\n    }\n    const map = {};\n    for (const [name, region] of Object.entries(actualOptions.regions)) {\n        let absoluteX = Math.floor(region.x * cellWidth);\n        let absoluteY = Math.floor(region.y * cellHeight);\n        let absoluteWidth = Math.ceil(region.width\n            ? (actualOptions.relative\n                ? region.width * cellWidth\n                : region.width)\n            : (actualOptions.relative\n                ? cellWidth\n                : image.width - absoluteX));\n        let absoluteHeight = Math.ceil(region.height\n            ? (actualOptions.relative\n                ? region.height * cellHeight\n                : region.height)\n            : (actualOptions.relative\n                ? cellHeight\n                : image.height - absoluteY));\n        if (actualOptions.relative && actualOptions.cellMargin > 0) {\n            absoluteX += actualOptions.cellMargin;\n            absoluteY += actualOptions.cellMargin;\n            absoluteWidth -= actualOptions.cellMargin;\n            absoluteHeight -= actualOptions.cellMargin;\n        }\n        if (region.repeat && region.repeat > 0) {\n            for (let i = 0; i < region.repeat; i++) {\n                const repeatName = getRepeatingRegionName(name, i + 1, region.repeatNameFormat);\n                let repeatOffsetX = Math.floor((((_a = region.repeatOffset) === null || _a === void 0 ? void 0 : _a.x) !== undefined &&\n                    ((_b = region.repeatOffset) === null || _b === void 0 ? void 0 : _b.x) !== null)\n                    ? (actualOptions.relative\n                        ? region.repeatOffset.x * cellWidth\n                        : region.repeatOffset.x)\n                    : cellWidth);\n                let repeatOffsetY = Math.floor((((_c = region.repeatOffset) === null || _c === void 0 ? void 0 : _c.y) !== undefined &&\n                    ((_d = region.repeatOffset) === null || _d === void 0 ? void 0 : _d.y) !== null)\n                    ? (actualOptions.relative\n                        ? region.repeatOffset.y * cellHeight\n                        : region.repeatOffset.y)\n                    : 0);\n                map[repeatName] = chopRegion(image, absoluteX + repeatOffsetX * i, absoluteY + repeatOffsetY * i, absoluteWidth, absoluteHeight);\n            }\n        }\n        else {\n            map[name] = chopRegion(image, absoluteX, absoluteY, absoluteWidth, absoluteHeight);\n        }\n    }\n    return map;\n}\nexports.textureAtlas = textureAtlas;\n/**\n * Chop a rectangular region from an image into a new canvas\n */\nfunction chopRegion(image, x, y, width, height) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    canvas.width = width;\n    canvas.height = height;\n    if (!context) {\n        throw new Error('Failed to get 2D context');\n    }\n    context.drawImage(image, x, y, width, height, 0, 0, width, height);\n    return canvas;\n}\n/**\n * Get the name of a repeating region\n */\nfunction getRepeatingRegionName(regionName, repetitionIndex, regionNameFormat) {\n    return (regionNameFormat !== null && regionNameFormat !== void 0 ? regionNameFormat : DEFAULT_REPEATING_REGION_NAME_FORMAT)\n        .replace('{name}', regionName)\n        .replace('{n}', repetitionIndex.toString());\n}\n/**\n * Content Manager Processor wrapper which allows the textureAtlas function\n * to be used as a processor in a Content Manager\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function textureAtlasContentProcessor(content, data, imageName) {\n    var _a;\n    const image = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n    if (!image) {\n        throw new Error(`Image '${imageName}' not found`);\n    }\n    const map = textureAtlas(image, data.content);\n    for (const [name, canvas] of Object.entries(map)) {\n        content[name] = {\n            name,\n            type: 'image',\n            content: canvas,\n            status: 4,\n        };\n    }\n}\nexports.textureAtlasContentProcessor = textureAtlasContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/texture-atlas/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.ts"](0, __webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/tile-map/build/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@basementuniverse/tile-map/build/index.js ***!
  \****************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./node_modules/fast-rle/decode.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-rle/decode.js ***!
  \*****************************************/
/***/ ((module) => {

eval("const decode = nums => {\n  const decoded = [];\n  for (let i = 0; i < nums.length; i += 2) {\n    const run_length = nums[i];\n    const value = nums[i + 1];\n    for (let ii = 0; ii < run_length; ii++) {\n      decoded.push(value);\n    }\n  }\n  return decoded;\n};\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/fast-rle/decode.js?");

/***/ }),

/***/ "./node_modules/lru_map/dist/lru.js":
/*!******************************************!*\
  !*** ./node_modules/lru_map/dist/lru.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("!function(g,c){ true?c(exports):0}(this,function(g){const c=Symbol(\"newer\"),e=Symbol(\"older\");class n{constructor(a,b){typeof a!==\"number\"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size))}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error(\"overflow\")}this.newest=b,this.size=this._keymap.size}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear()}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!==\"object\"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c]}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a=\"\",b=this.oldest;b;)a+=String(b.key)+\":\"+b.value,b=b[c],b&&(a+=\" < \");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0}function i(a){this.entry=a}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}}});\n//# sourceMappingURL=lru.js.map\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/lru_map/dist/lru.js?");

/***/ }),

/***/ "./bitmap-decompose.ts":
/*!*****************************!*\
  !*** ./bitmap-decompose.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bitmapToRectangles = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction bitmapToRectangles(bitmap) {\n    const rectangles = [];\n    // Step 1 - create 1-unit tall rectangles for each row\n    for (const [y, row] of bitmap.entries()) {\n        let currentRectangle = null;\n        for (let x = 0; x < row.length; x++) {\n            if (row[x]) {\n                if (!currentRectangle) {\n                    currentRectangle = {\n                        position: (0, vec_1.vec)(x, y),\n                        size: (0, vec_1.vec)(1, 1),\n                    };\n                }\n                else {\n                    currentRectangle.size.x++;\n                }\n            }\n            else {\n                if (currentRectangle) {\n                    rectangles.push(currentRectangle);\n                    currentRectangle = null;\n                }\n            }\n        }\n    }\n    // Step 2 - extend each rectangle downwards if possible\n    let pair;\n    while (pair = findRectangleToExtend(rectangles)) {\n        const [a, b] = pair;\n        rectangles.splice(indexOf(b, rectangles), 1, ...chopRectangle(b, a));\n        a.size.y += b.size.y;\n    }\n    return rectangles;\n}\nexports.bitmapToRectangles = bitmapToRectangles;\n/**\n * Get the index of rectangle a in a list of rectangles\n */\nfunction indexOf(a, rectangles) {\n    return rectangles.findIndex(b => vec_1.vec.eq(a.position, b.position) && vec_1.vec.eq(a.size, b.size));\n}\n/**\n * Find a pair of rectangles where the first one can be extended into the\n * second one\n *\n * If no such pair exists, return null\n */\nfunction findRectangleToExtend(rectangles) {\n    for (const a of rectangles) {\n        const b = findRectangleToExtendInto(a, rectangles);\n        if (b) {\n            return [a, b];\n        }\n    }\n    return null;\n}\n/**\n * Find a rectangle which rectangle a can extend into, or null if none can be\n * found\n *\n * A rectangle can extend into another one if the other one is exactly below\n * and their x-axis projections overlap\n */\nfunction findRectangleToExtendInto(a, rectangles) {\n    var _a;\n    return (_a = rectangles.find(other => (\n    // The other rectangle is exactly below the current one\n    other.position.y === a.position.y + a.size.y &&\n        // The other rectangle starts before (or at) the start of the current one\n        other.position.x <= a.position.x &&\n        // The other rectangle ends after (or at) the end of the current one\n        other.position.x + other.size.x >= a.position.x + a.size.x))) !== null && _a !== void 0 ? _a : null;\n}\n/**\n * Subtract rectangle b from rectangle a, ignoring height (i.e. only in the\n * x-axis) and return 0, 1 or 2 resulting rectangles\n */\nfunction chopRectangle(a, b) {\n    const result = [];\n    if (b.position.x > a.position.x) {\n        result.push({\n            position: (0, vec_1.vec)(a.position.x, a.position.y),\n            size: (0, vec_1.vec)(b.position.x - a.position.x, a.size.y),\n        });\n    }\n    if (b.position.x + b.size.x < a.position.x + a.size.x) {\n        result.push({\n            position: (0, vec_1.vec)(b.position.x + b.size.x, a.position.y),\n            size: (0, vec_1.vec)((a.position.x + a.size.x) - (b.position.x + b.size.x), a.size.y),\n        });\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./bitmap-decompose.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tileMapOptionsContentProcessor = exports.TileMap = exports.cameraBoundsSize = exports.cameraBoundsToTileMapBounds = exports.TileAlignment = void 0;\nconst lru_map_1 = __webpack_require__(/*! lru_map */ \"./node_modules/lru_map/dist/lru.js\");\nconst decode_1 = __importDefault(__webpack_require__(/*! fast-rle/decode */ \"./node_modules/fast-rle/decode.js\"));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst bitmap_decompose_1 = __webpack_require__(/*! ./bitmap-decompose */ \"./bitmap-decompose.ts\");\nvar TileAlignment;\n(function (TileAlignment) {\n    TileAlignment[\"TopLeft\"] = \"top-left\";\n    TileAlignment[\"Top\"] = \"top\";\n    TileAlignment[\"TopRight\"] = \"top-right\";\n    TileAlignment[\"Left\"] = \"left\";\n    TileAlignment[\"Center\"] = \"center\";\n    TileAlignment[\"Right\"] = \"right\";\n    TileAlignment[\"BottomLeft\"] = \"bottom-left\";\n    TileAlignment[\"Bottom\"] = \"bottom\";\n    TileAlignment[\"BottomRight\"] = \"bottom-right\";\n})(TileAlignment = exports.TileAlignment || (exports.TileAlignment = {}));\nfunction pointInRectangle(point, topLeft, bottomRight) {\n    return (point.x >= topLeft.x &&\n        point.y >= topLeft.y &&\n        point.x < bottomRight.x &&\n        point.y < bottomRight.y);\n}\nfunction cameraBoundsToTileMapBounds(bounds) {\n    return {\n        topLeft: (0, vec_1.vec)(bounds.left, bounds.top),\n        bottomRight: (0, vec_1.vec)(bounds.right, bounds.bottom),\n    };\n}\nexports.cameraBoundsToTileMapBounds = cameraBoundsToTileMapBounds;\nfunction cameraBoundsSize(bounds) {\n    const convertedBounds = cameraBoundsToTileMapBounds(bounds);\n    return vec_1.vec.sub(convertedBounds.bottomRight, convertedBounds.topLeft);\n}\nexports.cameraBoundsSize = cameraBoundsSize;\nclass TileMap {\n    constructor(options) {\n        const actualOptions = Object.assign({}, TileMap.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        for (const [i, layer] of actualOptions.layers.entries()) {\n            actualOptions.layers[i] = Object.assign({}, TileMap.DEFAULT_LAYER_OPTIONS, layer);\n        }\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showOrigin: !!actualOptions.debug,\n                showChunkBorders: !!actualOptions.debug,\n                showChunkLabels: !!actualOptions.debug,\n                showTileBorders: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        this.chunkBuffer = new lru_map_1.LRUMap(this.options.chunkBufferMaxSize);\n    }\n    /**\n     * Get a (roughly minimal) set of rectangles which cover the tiles in a\n     * given layer\n     *\n     * @param layerName The name of the layer to get rectangles for\n     * @param fieldName We will check the truthyness of this field in the\n     * tile definition\n     * @param tileBounds Optional bounds to check within, relative to bounds\n     * defined in options if any exist, otherwise relative to (0, 0)\n     */\n    getLayerRectangles(layerName, fieldName, tileBounds) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const layer = this.options.layers.find((l) => l.name === layerName);\n        if (!layer) {\n            return [];\n        }\n        const topLeft = (_a = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.topLeft) !== null && _a !== void 0 ? _a : (0, vec_1.vec)(0);\n        const bottomRight = (_b = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.bottomRight) !== null && _b !== void 0 ? _b : (0, vec_1.vec)(Math.max(...(_d = (_c = layer.data) === null || _c === void 0 ? void 0 : _c.map(row => row.length)) !== null && _d !== void 0 ? _d : [0]), (_f = (_e = layer.data) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0);\n        if (bottomRight.x <= topLeft.x || bottomRight.y <= topLeft.y) {\n            return [];\n        }\n        const bitmap = [];\n        for (let y = topLeft.y; y < bottomRight.y; y++) {\n            const row = [];\n            for (let x = topLeft.x; x < bottomRight.x; x++) {\n                const tileData = (_h = (_g = layer.data) === null || _g === void 0 ? void 0 : _g[y]) === null || _h === void 0 ? void 0 : _h[x];\n                if (tileData === undefined || tileData === -1) {\n                    row.push(false);\n                    continue;\n                }\n                const tile = (_j = layer.tiles) === null || _j === void 0 ? void 0 : _j[tileData];\n                if (!tile) {\n                    row.push(false);\n                    continue;\n                }\n                if (fieldName && !tile[fieldName]) {\n                    row.push(false);\n                    continue;\n                }\n                row.push(true);\n            }\n            bitmap.push(row);\n        }\n        return (0, bitmap_decompose_1.bitmapToRectangles)(bitmap);\n    }\n    /**\n     * Get the tile at a given position and in the specified layer\n     *\n     * If no layer is specified, return a dictionary of layer names to tile\n     * definitions (i.e. return all layers)\n     *\n     * If no tile exists at this position, return null\n     */\n    getTileAtPosition(position, layerName) {\n        if (layerName) {\n            return this.getTileAtPositionInLayer(position, layerName);\n        }\n        const result = {};\n        for (const layer of this.options.layers) {\n            result[layer.name] = this.getTileAtPositionInLayer(position, layer.name);\n        }\n        return result;\n    }\n    getTileAtPositionInLayer(position, layerName) {\n        var _a, _b, _c;\n        const tilePosition = vec_1.vec.map(vec_1.vec.mul(position, 1 / this.options.tileSize), Math.floor);\n        const layer = this.options.layers.find((l) => l.name === layerName);\n        if (!layer) {\n            return null;\n        }\n        const tileData = (_b = (_a = layer.data) === null || _a === void 0 ? void 0 : _a[tilePosition.y]) === null || _b === void 0 ? void 0 : _b[tilePosition.x];\n        if (tileData === undefined || tileData === -1) {\n            return null;\n        }\n        if (layer.tiles) {\n            return (_c = layer.tiles[tileData]) !== null && _c !== void 0 ? _c : null;\n        }\n        return null;\n    }\n    hashVector(v) {\n        return vec_1.vec.str(v);\n    }\n    draw(context, a, b, c) {\n        if (b && c) {\n            this.performDraw(context, a, b, c);\n        }\n        else {\n            const screen = cameraBoundsSize(a.bounds);\n            this.performDraw(context, screen, a.actualPosition, a.actualScale, false);\n        }\n    }\n    performDraw(context, screen, position, scale, doTransforms = true) {\n        var _a, _b, _c, _d;\n        const absoluteChunkSize = this.options.tileSize * this.options.chunkSize;\n        const chunkBorder = (0, vec_1.vec)(this.options.chunkBorder);\n        // Maybe clamp scale\n        let actualScale = scale;\n        if (this.options.minScale && actualScale < this.options.minScale) {\n            actualScale = this.options.minScale;\n        }\n        if (this.options.maxScale && actualScale > this.options.maxScale) {\n            actualScale = this.options.maxScale;\n        }\n        // Maybe clamp position to bounds\n        let actualPosition = (0, vec_1.vec)(position);\n        if (this.options.bounds && this.options.clampPositionToBounds) {\n            const tileSizeScaled = this.options.tileSize / actualScale;\n            const halfScreenScaled = vec_1.vec.map(vec_1.vec.mul(screen, 1 / (actualScale * 2)), Math.ceil);\n            const minPosition = (0, vec_1.vec)(this.options.bounds.topLeft.x * tileSizeScaled + halfScreenScaled.x, this.options.bounds.topLeft.y * tileSizeScaled + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec)(this.options.bounds.bottomRight.x * tileSizeScaled - halfScreenScaled.x, this.options.bounds.bottomRight.y * tileSizeScaled - halfScreenScaled.y);\n            actualPosition = (0, vec_1.vec)((0, utils_1.clamp)(actualPosition.x, minPosition.x, maxPosition.x), (0, utils_1.clamp)(actualPosition.y, minPosition.y, maxPosition.y));\n        }\n        const screenSizeInChunks = vec_1.vec.map(vec_1.vec.mul(screen, 1 / (absoluteChunkSize * actualScale)), Math.ceil);\n        const screenCenterChunk = vec_1.vec.map(vec_1.vec.mul(actualPosition, 1 / absoluteChunkSize), Math.floor);\n        const topLeftChunk = vec_1.vec.sub(vec_1.vec.sub(screenCenterChunk, vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        const bottomRightChunk = vec_1.vec.add(vec_1.vec.add(screenCenterChunk, vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        context.save();\n        if (doTransforms) {\n            context.scale(actualScale, actualScale);\n            context.translate(-actualPosition.x + screen.x / (actualScale * 2), -actualPosition.y + screen.y / (actualScale * 2));\n        }\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this, screen, actualPosition, actualScale);\n        // Render chunks\n        for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                const chunkPosition = (0, vec_1.vec)(x, y);\n                const chunkAbsolutePosition = vec_1.vec.mul(chunkPosition, absoluteChunkSize);\n                // Check if we have this chunk in the cache\n                const chunkHash = this.hashVector(chunkPosition);\n                if (!this.chunkBuffer.has(chunkHash)) {\n                    this.chunkBuffer.set(chunkHash, this.generateChunk(chunkPosition, absoluteChunkSize));\n                }\n                const chunk = this.chunkBuffer.get(chunkHash);\n                if (chunk) {\n                    context.drawImage(chunk.image, chunkAbsolutePosition.x, chunkAbsolutePosition.y);\n                }\n            }\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this, screen, actualPosition, actualScale);\n        // Render debug helpers\n        if (this.options.debug.showTileBorders) {\n            const topLeftTile = vec_1.vec.mul(vec_1.vec.sub(screenCenterChunk, vec_1.vec.add(vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec)(1))), this.options.chunkSize);\n            const bottomRightTile = vec_1.vec.mul(vec_1.vec.add(screenCenterChunk, vec_1.vec.add(vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec)(1))), this.options.chunkSize);\n            for (let y = topLeftTile.y; y < bottomRightTile.y; y++) {\n                this.drawLine(context, (0, vec_1.vec)(actualPosition.x - screen.x / (actualScale * 2), y * this.options.tileSize), (0, vec_1.vec)(actualPosition.x + screen.x / (actualScale * 2), y * this.options.tileSize), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftTile.x; x < bottomRightTile.x; x++) {\n                this.drawLine(context, (0, vec_1.vec)(x * this.options.tileSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec)(x * this.options.tileSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkBorders) {\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                this.drawLine(context, (0, vec_1.vec)(actualPosition.x - screen.x / (actualScale * 2), y * absoluteChunkSize), (0, vec_1.vec)(actualPosition.x + screen.x / (actualScale * 2), y * absoluteChunkSize), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                this.drawLine(context, (0, vec_1.vec)(x * absoluteChunkSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec)(x * absoluteChunkSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkLabels) {\n            context.save();\n            context.fillStyle = TileMap.DEBUG_CHUNK_LABEL_COLOUR;\n            context.font = TileMap.DEBUG_CHUNK_LABEL_FONT;\n            context.textBaseline = 'middle';\n            context.textAlign = 'center';\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                    context.fillText(`${x}, ${y}`, x * absoluteChunkSize + absoluteChunkSize / 2, y * absoluteChunkSize + absoluteChunkSize / 2);\n                }\n            }\n            context.restore();\n        }\n        if (this.options.debug.showOrigin &&\n            pointInRectangle((0, vec_1.vec)(0, 0), topLeftChunk, bottomRightChunk)) {\n            this.drawCross(context, (0, vec_1.vec)(0, 0), TileMap.DEBUG_ORIGIN_COLOUR, TileMap.DEBUG_ORIGIN_LINE_WIDTH, TileMap.DEBUG_ORIGIN_SIZE);\n        }\n        context.restore();\n    }\n    generateChunk(chunkPosition, absoluteChunkSize) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const chunkCanvas = document.createElement('canvas');\n        const chunkContext = chunkCanvas.getContext('2d');\n        chunkCanvas.width = absoluteChunkSize;\n        chunkCanvas.height = absoluteChunkSize;\n        let chunk = {\n            chunkPosition,\n            image: chunkCanvas,\n        };\n        const topLeftTile = vec_1.vec.mul(chunkPosition, this.options.chunkSize);\n        const bottomRightTile = vec_1.vec.add(topLeftTile, (0, vec_1.vec)(this.options.chunkSize - 1));\n        const boundsTopLeft = (_b = (_a = this.options.bounds) === null || _a === void 0 ? void 0 : _a.topLeft) !== null && _b !== void 0 ? _b : (0, vec_1.vec)(0);\n        if (this.options.preGenerateChunk) {\n            const result = this.options.preGenerateChunk(chunkContext, this, {\n                topLeft: topLeftTile,\n                bottomRight: bottomRightTile,\n            }, chunkPosition);\n            if (Array.isArray(result)) {\n                if (!result[1]) {\n                    return chunk;\n                }\n            }\n        }\n        // Default generation, render tiles from tilemap data\n        for (const layer of this.options.layers) {\n            chunkContext.save();\n            chunkContext.globalAlpha = (_c = layer.opacity) !== null && _c !== void 0 ? _c : 1;\n            const alignment = (_d = layer.alignment) !== null && _d !== void 0 ? _d : TileAlignment.Center;\n            for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {\n                for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {\n                    const tilePosition = (0, vec_1.vec)(x, y);\n                    (_e = layer.preRenderTile) === null || _e === void 0 ? void 0 : _e.call(layer, chunkContext, this, layer, chunkPosition, tilePosition);\n                    const tileDataPosition = vec_1.vec.sub(tilePosition, boundsTopLeft);\n                    if (tileDataPosition.x < 0 || tileDataPosition.y < 0) {\n                        continue;\n                    }\n                    const tileData = (_g = (_f = layer.data) === null || _f === void 0 ? void 0 : _f[tileDataPosition.y]) === null || _g === void 0 ? void 0 : _g[tileDataPosition.x];\n                    if (tileData === undefined || tileData === -1) {\n                        continue;\n                    }\n                    const tileImage = (_j = (_h = layer.tiles) === null || _h === void 0 ? void 0 : _h[tileData]) === null || _j === void 0 ? void 0 : _j.image;\n                    if (!tileImage) {\n                        continue;\n                    }\n                    const tileAbsolutePosition = vec_1.vec.sub(vec_1.vec.mul(tilePosition, this.options.tileSize), vec_1.vec.mul(chunkPosition, absoluteChunkSize));\n                    // Tile clipping\n                    if (layer.clip) {\n                        chunkContext.save();\n                        chunkContext.beginPath();\n                        chunkContext.rect(tileAbsolutePosition.x, tileAbsolutePosition.y, this.options.tileSize, this.options.tileSize);\n                        chunkContext.clip();\n                    }\n                    // Tile alignment\n                    let tileImageAbsolutePosition;\n                    switch (alignment) {\n                        case TileAlignment.TopLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition);\n                            break;\n                        case TileAlignment.Top:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.TopRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.Left:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.Center:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.Right:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.BottomLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                        case TileAlignment.Bottom:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                        case TileAlignment.BottomRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                    }\n                    chunkContext.drawImage(tileImage, tileImageAbsolutePosition.x, tileImageAbsolutePosition.y);\n                    if (layer.clip) {\n                        chunkContext.restore();\n                    }\n                    (_k = layer.postRenderTile) === null || _k === void 0 ? void 0 : _k.call(layer, chunkCanvas, chunkContext, this, layer, chunkPosition, tilePosition);\n                }\n            }\n            chunkContext.restore();\n        }\n        (_m = (_l = this.options).postGenerateChunk) === null || _m === void 0 ? void 0 : _m.call(_l, chunkCanvas, chunkContext, this, {\n            topLeft: topLeftTile,\n            bottomRight: bottomRightTile,\n        }, chunkPosition);\n        return chunk;\n    }\n    drawLine(context, start, end, colour, lineWidth) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(start.x, start.y);\n        context.lineTo(end.x, end.y);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.TileMap = TileMap;\nTileMap.DEFAULT_OPTIONS = {\n    clampPositionToBounds: true,\n    tileSize: 16,\n    layers: [\n        {\n            name: 'default',\n        },\n    ],\n    chunkSize: 8,\n    chunkBorder: 1,\n    chunkBufferMaxSize: 64,\n};\nTileMap.DEFAULT_LAYER_OPTIONS = {\n    name: 'default',\n};\nTileMap.DEBUG_ORIGIN_COLOUR = 'cyan';\nTileMap.DEBUG_ORIGIN_LINE_WIDTH = 2;\nTileMap.DEBUG_ORIGIN_SIZE = 10;\nTileMap.DEBUG_CHUNK_BORDER_COLOUR = 'yellow';\nTileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH = 2;\nTileMap.DEBUG_CHUNK_LABEL_COLOUR = 'white';\nTileMap.DEBUG_CHUNK_LABEL_FONT = '12px monospace';\nTileMap.DEBUG_TILE_BORDER_COLOUR = 'orange';\nTileMap.DEBUG_TILE_BORDER_LINE_WIDTH = 1;\n/**\n * Content Manager Processor wrapper which converts TileMapOptionsData into\n * TileMapOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function tileMapOptionsContentProcessor(content, data, options) {\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.layers) {\n        for (const [i, layer] of result.layers.entries()) {\n            // Replace imageName with image in the tile definitions array\n            if (layer.tiles) {\n                for (const [j, tile] of layer.tiles.entries()) {\n                    result.layers[i].tiles[j].image = getImageFromContent(tile.imageName);\n                    delete result.layers[i].tiles[j].imageName;\n                }\n            }\n            // Decompress layer data\n            if ((options === null || options === void 0 ? void 0 : options.decompressData) && layer.data && layer.width) {\n                result.layers[i].data = (0, utils_1.chunk)((0, decode_1.default)(layer.data), layer.width);\n                delete result.layers[i].width;\n            }\n        }\n    }\n    // @ts-ignore\n    data.content = result;\n}\nexports.tileMapOptionsContentProcessor = tileMapOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_57312__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_57312__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_57312__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {Array<*>} a
 * @param {Array<*>} b
 * @return {Array<Array<*>>}
 */
const zip = (a, b) => a.map((k, i) => [k, b[i]]);

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

/**
 * A 2d vector
 * @typedef {Object} vec
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new vector
 * @param {number|vec} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec} A new vector
 * @example <caption>Various ways to initialise a vector</caption>
 * let a = vec(3, 2);  // (3, 2)
 * let b = vec(4);     // (4, 4)
 * let c = vec(a);     // (3, 2)
 * let d = vec();      // (0, 0)
 */
const vec = (x, y) => (!x && !y ?
  { x: 0, y: 0 } : (typeof x === 'object' ?
    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?
      { x: x, y: x } : { x: x, y: y })
  )
);

/**
 * Get the components of a vector as an array
 * @param {vec} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec.components = a => [a.x, a.y];

/**
 * Return a unit vector (1, 0)
 * @return {vec} A unit vector (1, 0)
 */
vec.ux = () => vec(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec} A unit vector (0, 1)
 */
vec.uy = () => vec(0, 1);

/**
 * Add vectors
 * @param {vec} a Vector a
 * @param {vec} b Vector b
 * @return {vec} a + b
 */
vec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });

/**
 * Scale a vector
 * @param {vec} a Vector a
 * @param {number} b Scalar b
 * @return {vec} a * b
 */
vec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });

/**
 * Subtract vectors
 * @param {vec} a Vector a
 * @param {vec} b Vector b
 * @return {vec} a - b
 */
vec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });

/**
 * Get the length of a vector
 * @param {vec} a Vector a
 * @return {number} |a|
 */
vec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec} a Vector a
 * @return {number} |a|
 */
vec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec} a The vector to normalise
 * @return {vec} ^a
 */
vec.nor = a => {
  let len = vec.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec();
};

/**
 * Get a dot product of vectors
 * @param {vec} a Vector a
 * @param {vec} b Vector b
 * @return {number} a ∙ b
 */
vec.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec} A rotated vector
 */
vec.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
}

/**
 * Check if two vectors are equal
 * @param {vec} a Vector a
 * @param {vec} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec} a The vector to copy
 * @return {vec} A copy of vector a
 */
vec.cpy = a => vec(a);

/**
 * A function to call on each component of a vector
 * @callback vectorMapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec} a Vector a
 * @param {vectorMapCallback} f The function to call on each component of the vector
 * @return {vec} Vector a mapped through f
 */
vec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|boolean} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|boolean} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|boolean} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|boolean} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec, mat };
}


/***/ }),

/***/ "./node_modules/shader-canvas/dist/shader-canvas.js":
/*!**********************************************************!*\
  !*** ./node_modules/shader-canvas/dist/shader-canvas.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderCanvas": () => (/* binding */ ShaderCanvas)
/* harmony export */ });
const defaultVertexShader = `
  #ifdef GL_ES
  precision mediump float;
  #endif
  attribute vec2 position;
  void main() {
    gl_Position = vec4(position, 0.0, 1.0);
  }
`;
const defaultFragmentShader = `
  #ifdef GL_ES
  precision mediump float;
  #endif
  void main() {
    gl_FragColor = vec4(0.0);
  }
`;
class ShaderCanvas {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.textures = {};
        this.domElement = document.createElement("canvas");
        const gl = this.domElement.getContext("webgl");
        if (!gl) {
            throw new Error("failed to get webgl context");
        }
        this.gl = gl;
        const vs = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (!vs) {
            throw new Error("failed to create vertex shader");
        }
        this.vertexShader = vs;
        const vsErrs = compileShader(this.gl, this.vertexShader, defaultVertexShader);
        if (vsErrs) {
            throw new Error("failed to compile vertex shader");
        }
        const fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        if (!fs) {
            throw new Error("failed to create fragment shader");
        }
        this.fragmentShader = fs;
        const fsErrs = compileShader(this.gl, this.fragmentShader, defaultFragmentShader);
        if (fsErrs) {
            throw new Error("failed to compile vertex shader");
        }
        this.shaderProgram = createShaderProgram(this.gl, this.vertexShader, this.fragmentShader);
        bindPositionAttribute(this.gl, this.shaderProgram);
        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
        this.gl.useProgram(this.shaderProgram);
        this.setSize(400, 400);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        const dpr = window.devicePixelRatio;
        this.domElement.width = width * dpr;
        this.domElement.height = height * dpr;
        this.domElement.style.width = width + "px";
        this.domElement.style.height = height + "px";
        this.gl.viewport(0, 0, this.domElement.width, this.domElement.height);
    }
    // getResolution is a convenience method for getting a vec2 representing the
    // size in physical pixels of the canvas.
    // Typical usage is:
    //   shaderCanvas.setUniform("u_resolution", shaderCanvas.getResolution());
    getResolution() {
        return [
            this.domElement.width,
            this.domElement.height,
        ];
    }
    setShader(source) {
        const gl = this.gl;
        const errs = compileShader(gl, this.fragmentShader, source);
        if (errs) {
            return errs;
        }
        gl.linkProgram(this.shaderProgram);
        if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(this.shaderProgram));
            throw new Error("failed to link program");
        }
    }
    testUniform(name) {
        const location = this.gl.getUniformLocation(this.shaderProgram, name);
        return location !== null;
    }
    setUniform(name, value) {
        // TODO: validate name?
        // TODO OPTIMIZE: cache uniform location
        const location = this.gl.getUniformLocation(this.shaderProgram, name);
        if (location === null) {
            throw new Error(`uniform location for ${name} not found`);
        }
        if (typeof value === "number") {
            this.gl.uniform1f(location, value);
            return;
        }
        switch (value.length) {
            case 2:
                this.gl.uniform2fv(location, value);
                break;
            case 3:
                this.gl.uniform3fv(location, value);
                break;
            case 4:
                this.gl.uniform4fv(location, value);
                break;
        }
    }
    // TODO: accept options, like format, filter, wrap, etc.
    setTexture(name, image) {
        // TODO: validate name?
        const gl = this.gl;
        let t = this.textures[name];
        if (!t) {
            const glTexture = gl.createTexture();
            if (!glTexture) {
                throw new Error(`unable to create glTexture`);
            }
            t = {
                glTexture,
                unit: lowestUnused(Object.keys(this.textures).map((k) => this.textures[k].unit)),
            };
            this.textures[name] = t;
        }
        gl.activeTexture(gl.TEXTURE0 + t.unit);
        gl.bindTexture(gl.TEXTURE_2D, t.glTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        const location = gl.getUniformLocation(this.shaderProgram, name);
        if (location === null) {
            throw new Error(`uniform location for texture ${name} not found`);
        }
        gl.uniform1i(location, t.unit);
    }
    render() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
}
function compileShader(gl, shader, source) {
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        return;
    }
    const info = gl.getShaderInfoLog(shader);
    if (!info) {
        throw new Error("failed to compile, but found no error log");
    }
    console.error(info);
    return parseErrorMessages(info);
}
function createShaderProgram(gl, vs, fs) {
    const program = gl.createProgram();
    if (program === null) {
        throw new Error("failed to create shader program");
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        console.error(info);
        throw new Error("failed to link program");
    }
    return program;
}
function bindPositionAttribute(gl, program) {
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const positions = new Float32Array([
        -1.0, -1.0,
        -1.0, 1.0,
        1.0, -1.0,
        1.0, 1.0,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    const positionLocation = gl.getAttribLocation(program, "position");
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);
}
function parseErrorMessages(msg) {
    const errorRegex = /^ERROR: \d+:(\d+).*$/mg;
    const messages = [];
    let match = errorRegex.exec(msg);
    while (match) {
        messages.push({
            text: match[0],
            lineNumber: parseInt(match[1], 10),
        });
        // Look for another error:
        match = errorRegex.exec(msg);
    }
    return messages;
}
// This is a flavor of Shlemiel the painter's algorithm.
// http://wiki.c2.com/?ShlemielThePainter
//
// TODO: figure out how to run tests, but I've spot checked these:
//   [] => 0
//   [0, 1, 2, 3, 4] => 5
//   [0, 1, 3, 4] => 2
//   [1, 3, 4] => 0
//   [4] => 0
//   [4, 3, 2, 1, 0] => 5
//   [4, 2, 1, 0] => 3
//   [4, 2, 1, 10] => 0
//   [2, 0, 3, 4] => 1
function lowestUnused(xs) {
    let unused = 0;
    for (let i = 0; i < xs.length; i++) {
        if (xs[i] === unused) {
            unused++;
            i = -1; // go back to the beginning
        }
    }
    return unused;
}


/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const LoadingScene_1 = __webpack_require__(/*! ./scenes/LoadingScene */ "./src/scenes/LoadingScene.ts");
const config = __webpack_require__(/*! ./config.json */ "./src/config.json");
const constants = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const shader_content_processor_1 = __webpack_require__(/*! ./content-processors/shader.content-processor */ "./src/content-processors/shader.content-processor.ts");
const texture_atlas_1 = __webpack_require__(/*! @basementuniverse/texture-atlas */ "./node_modules/@basementuniverse/texture-atlas/build/index.js");
const tile_map_1 = __webpack_require__(/*! @basementuniverse/tile-map */ "./node_modules/@basementuniverse/tile-map/build/index.js");
const sprite_1 = __webpack_require__(/*! @basementuniverse/sprite */ "./node_modules/@basementuniverse/sprite/build/index.js");
class Game {
    constructor(container) {
        this.frameRate = 0;
        this.frameCount = 0;
        if (container === null) {
            throw new Error('A valid container element must be specified.');
        }
        if (container.tagName.toLowerCase() !== 'canvas') {
            throw new Error('Container element must be a canvas.');
        }
        this.canvas = container;
        const context = this.canvas.getContext('2d');
        if (context !== null) {
            this.context = context;
        }
        else {
            throw new Error("Couldn't get a 2d context.");
        }
        window.addEventListener('resize', this.resize.bind(this), false);
        this.resize();
    }
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    initialise() {
        content_manager_1.default.initialise({
            simulateSlowLoading: constants.DEBUG,
            slowLoadingTimeMin: 100,
            slowLoadingTimeMax: 500,
            processors: {
                shader: shader_content_processor_1.ShaderProcessor,
                textureAtlas: texture_atlas_1.textureAtlasContentProcessor,
                tileMap: tile_map_1.tileMapOptionsContentProcessor,
                sprite: sprite_1.spriteOptionsContentProcessor,
            },
            throwOnNotFound: true,
        });
        debug_1.default.initialise({
            lineMargin: 5,
        });
        input_manager_1.default.initialise();
        scene_manager_1.default.initialise();
        this.lastFrameTime = this.lastFrameCountTime = performance.now();
        this.loop();
        scene_manager_1.default.push(new LoadingScene_1.default());
    }
    loop() {
        const now = performance.now();
        const elapsedTime = Math.min(now - this.lastFrameTime, constants.FPS_MIN);
        if (now - this.lastFrameCountTime >= 1000) {
            this.lastFrameCountTime = now;
            this.frameRate = this.frameCount;
            this.frameCount = 0;
        }
        this.frameCount++;
        this.lastFrameTime = now;
        if (config.showFPS) {
            debug_1.default.value('FPS', this.frameRate, { align: 'right' });
            debug_1.default.chart('FPS', this.frameRate, { minValue: 0, maxValue: 70 });
        }
        this.update(elapsedTime);
        this.draw();
        window.requestAnimationFrame(this.loop.bind(this));
    }
    update(dt) {
        Game.screen = (0, vec_1.vec)(this.canvas.width, this.canvas.height);
        debug_1.default.value('status', content_manager_1.default.status);
        debug_1.default.value('progress', content_manager_1.default.progress);
        scene_manager_1.default.update(dt);
        input_manager_1.default.update();
    }
    draw() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        scene_manager_1.default.draw(this.context);
    }
}
exports["default"] = Game;


/***/ }),

/***/ "./src/actors/Actor.ts":
/*!*****************************!*\
  !*** ./src/actors/Actor.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/actors/Player.ts":
/*!******************************!*\
  !*** ./src/actors/Player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Player = void 0;
const sprite_1 = __webpack_require__(/*! @basementuniverse/sprite */ "./node_modules/@basementuniverse/sprite/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
class Player {
    constructor(position, direction, spriteData) {
        this.position = position;
        this.direction = direction;
        this.sprite = new sprite_1.Sprite({
            ...spriteData,
            position,
            defaultDirection: direction,
        });
    }
    update(dt) {
        var _a;
        const moveVector = (0, vec_1.vec)();
        if (input_manager_1.default.keyDown('ArrowUp')) {
            moveVector.y--;
        }
        if (input_manager_1.default.keyDown('ArrowDown')) {
            moveVector.y++;
        }
        if (input_manager_1.default.keyDown('ArrowLeft')) {
            moveVector.x--;
        }
        if (input_manager_1.default.keyDown('ArrowRight')) {
            moveVector.x++;
        }
        this.position = vec_1.vec.add(this.position, vec_1.vec.mul(moveVector, Player.SPEED * dt));
        this.position.x = (0, utils_1.clamp)(this.position.x, 0, 1024);
        this.position.y = (0, utils_1.clamp)(this.position.y, 0, 1024);
        const moving = !vec_1.vec.eq(moveVector, (0, vec_1.vec)());
        if (moving) {
            this.direction = ((_a = {
                ['1, 0']: 'e',
                ['1, 1']: 'se',
                ['0, 1']: 's',
                ['-1, 1']: 'sw',
                ['-1, 0']: 'w',
                ['-1, -1']: 'nw',
                ['0, -1']: 'n',
                ['1, -1']: 'ne',
            }[vec_1.vec.str(moveVector)]) !== null && _a !== void 0 ? _a : 's');
        }
        this.sprite.position = vec_1.vec.cpy(this.position);
        this.sprite.direction = this.direction;
        this.sprite.animation = moving ? 'walk' : 'idle';
        this.sprite.update(dt);
    }
    draw(context) {
        this.sprite.draw(context);
    }
}
exports.Player = Player;
Player.SPEED = 40;


/***/ }),

/***/ "./src/actors/ProgressBar.ts":
/*!***********************************!*\
  !*** ./src/actors/ProgressBar.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressBar = void 0;
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
class ProgressBar {
    constructor(position, size) {
        this.position = position;
        this.size = size;
        this.progress = 0;
        this.displayProgress = 0;
    }
    update(dt) {
        this.displayProgress += (this.progress - this.displayProgress) * ProgressBar.EASE_AMOUNT * dt;
        if (Math.abs(this.displayProgress - this.progress) <= 0.001) {
            this.displayProgress = this.progress;
        }
    }
    draw(context) {
        context.save();
        context.strokeStyle = ProgressBar.COLOUR;
        context.fillStyle = ProgressBar.COLOUR;
        context.lineWidth = 2;
        const topLeft = vec_1.vec.sub(this.position, vec_1.vec.mul(this.size, 1 / 2));
        context.strokeRect(topLeft.x, topLeft.y, this.size.x, this.size.y);
        context.fillRect(topLeft.x, topLeft.y, Math.floor(this.displayProgress * this.size.x), this.size.y);
        context.restore();
    }
}
exports.ProgressBar = ProgressBar;
ProgressBar.EASE_AMOUNT = 1.5;
ProgressBar.COLOUR = 'white';


/***/ }),

/***/ "./src/actors/index.ts":
/*!*****************************!*\
  !*** ./src/actors/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Actor */ "./src/actors/Actor.ts"), exports);
__exportStar(__webpack_require__(/*! ./Player */ "./src/actors/Player.ts"), exports);
__exportStar(__webpack_require__(/*! ./ProgressBar */ "./src/actors/ProgressBar.ts"), exports);


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FPS_MIN = exports.DEBUG = void 0;
exports.DEBUG = true;
exports.FPS_MIN = 1 / 30;


/***/ }),

/***/ "./src/content-processors/shader.content-processor.ts":
/*!************************************************************!*\
  !*** ./src/content-processors/shader.content-processor.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShaderProcessor = void 0;
const shader_canvas_1 = __webpack_require__(/*! shader-canvas */ "./node_modules/shader-canvas/dist/shader-canvas.js");
const ShaderProcessor = async (content, item) => {
    const shaderCanvas = new shader_canvas_1.ShaderCanvas();
    shaderCanvas.setShader(item.content);
    item.content = shaderCanvas;
};
exports.ShaderProcessor = ShaderProcessor;


/***/ }),

/***/ "./src/scenes/GameScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/GameScene.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const camera_1 = __webpack_require__(/*! @basementuniverse/camera */ "./node_modules/@basementuniverse/camera/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const tile_map_1 = __webpack_require__(/*! @basementuniverse/tile-map */ "./node_modules/@basementuniverse/tile-map/build/index.js");
const actors_1 = __webpack_require__(/*! ../actors */ "./src/actors/index.ts");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class GameScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: GameScene.TRANSITION_TIME,
            onTransitionedOut: () => {
                debug_1.default.removeChart('Camera Scale');
                debug_1.default.removeChart('Wave');
            },
        });
    }
    initialise() {
        this.camera = new camera_1.default(GameScene.STARTING_POSITION, {
            minScale: 0.5,
            maxScale: 5,
            bounds: {
                top: 0,
                left: 0,
                right: 1024,
                bottom: 1024,
            },
            moveEaseAmount: 0.95,
            scaleEaseAmount: 0.95,
        });
        this.camera.scaleImmediate = 3;
        this.map = new tile_map_1.TileMap(content_manager_1.default.get('tile-map-data'));
        this.player = new actors_1.Player(GameScene.STARTING_POSITION, 's', content_manager_1.default.get('character-sprite-data'));
    }
    update(dt) {
        if (input_manager_1.default.keyPressed('Escape')) {
            scene_manager_1.default.pop();
        }
        if (input_manager_1.default.mouseWheelUp()) {
            this.camera.scale += 0.1;
        }
        if (input_manager_1.default.mouseWheelDown()) {
            this.camera.scale -= 0.1;
        }
        debug_1.default.chart('Camera Scale', this.camera.scale, {
            minValue: 0.5,
            maxValue: 5,
            barColours: [
                {
                    offset: 1,
                    colour: '#f00',
                },
                {
                    offset: 2.5,
                    colour: '#f50',
                },
                {
                    offset: 4,
                    colour: '#f90',
                },
            ]
        });
        debug_1.default.chart('Wave', Math.sin(performance.now() / 1000) + 1, {
            minValue: 0,
            maxValue: 2,
            valueBufferSize: 1500,
            valueBufferStride: 30,
        });
        debug_1.default.border('test1', '', (0, vec_1.vec)(200), {
            space: 'screen',
            size: (0, vec_1.vec)(200, 200),
            borderColour: '#f82',
            borderStyle: 'dashed',
            borderWidth: 4,
        });
        debug_1.default.border('test2', '', (0, vec_1.vec)(100), {
            space: 'world',
            radius: 200,
            borderShape: 'circle',
            borderColour: '#5f5',
            borderStyle: 'dotted',
            showLabel: false,
        });
        debug_1.default.marker('player', vec_1.vec.str(vec_1.vec.map(this.player.position, Math.floor)), vec_1.vec.add(this.player.position, (0, vec_1.vec)(0, 30)), {
            markerStyle: 'x',
            markerColour: '#ff0',
            showLabel: false,
            showValue: true,
        });
        this.player.update(dt);
        this.camera.position = vec_1.vec.cpy(this.player.position);
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        context.fillStyle = '#ccc';
        context.fillRect(0, 0, Game_1.default.screen.x, Game_1.default.screen.y);
        context.save();
        this.camera.draw(context, Game_1.default.screen);
        this.map.draw(context, this.camera);
        this.player.draw(context);
        debug_1.default.draw(context);
        context.restore();
        context.restore();
    }
}
exports["default"] = GameScene;
GameScene.TRANSITION_TIME = 1;
GameScene.STARTING_POSITION = (0, vec_1.vec)(512, 512);


/***/ }),

/***/ "./src/scenes/IntroScene.ts":
/*!**********************************!*\
  !*** ./src/scenes/IntroScene.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const MenuScene_1 = __webpack_require__(/*! ./MenuScene */ "./src/scenes/MenuScene.ts");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class IntroScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: IntroScene.TRANSITION_TIME,
        });
        this.time = 0;
    }
    initialise() {
        const shader = content_manager_1.default.get('blur-shader');
        if (shader) {
            this.shader = shader;
        }
        const logo = content_manager_1.default.get('basement-universe');
        if (logo) {
            this.logo = logo;
            this.shader.setSize(this.logo.width, this.logo.height);
            this.shader.setTexture('u_mainTex', this.logo);
            this.shader.setUniform('u_resolution', this.shader.getResolution());
        }
    }
    update(dt) {
        this.time += dt;
        if (this.time > IntroScene.COOLDOWN_TIME ||
            input_manager_1.default.keyPressed() ||
            input_manager_1.default.mousePressed()) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new MenuScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        if (this.shader) {
            this.shader.setUniform('u_sigma', 1 - this.transitionAmount);
            this.shader.render();
            context.drawImage(this.shader.domElement, Game_1.default.screen.x / 2 - this.logo.width / 2, Game_1.default.screen.y / 2 - this.logo.height / 2, this.logo.width, this.logo.height);
        }
        debug_1.default.draw(context);
        context.restore();
    }
}
exports["default"] = IntroScene;
IntroScene.TRANSITION_TIME = 2;
IntroScene.COOLDOWN_TIME = 8;


/***/ }),

/***/ "./src/scenes/LoadingScene.ts":
/*!************************************!*\
  !*** ./src/scenes/LoadingScene.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const constants = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const content = __webpack_require__(/*! ../../content/content.json */ "./content/content.json");
const IntroScene_1 = __webpack_require__(/*! ./IntroScene */ "./src/scenes/IntroScene.ts");
const actors_1 = __webpack_require__(/*! ../actors */ "./src/actors/index.ts");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class LoadingScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: LoadingScene.TRANSITION_TIME,
        });
        this.cooldownTime = 0;
    }
    initialise() {
        this.finishedLoadingContent = false;
        this.progressBar = new actors_1.ProgressBar(vec_1.vec.map(vec_1.vec.mul(Game_1.default.screen, 1 / 2), Math.floor), (0, vec_1.vec)(200, 40));
        this.cooldownTime = LoadingScene.COOLDOWN_TIME;
        content_manager_1.default.load(content).then(() => {
            this.finishedLoadingContent = true;
        }).catch((error) => {
            constants.DEBUG && console.log(`Unable to load content: ${error}`);
        });
    }
    update(dt) {
        this.progressBar.position = vec_1.vec.map(vec_1.vec.mul(Game_1.default.screen, 1 / 2), Math.floor);
        this.progressBar.progress = content_manager_1.default.progress;
        this.progressBar.update(dt);
        if (this.finishedLoadingContent) {
            this.cooldownTime -= dt;
        }
        if (this.cooldownTime <= 0) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new IntroScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        this.progressBar.draw(context);
        debug_1.default.draw(context);
        context.restore();
    }
}
exports["default"] = LoadingScene;
LoadingScene.TRANSITION_TIME = 0.5;
LoadingScene.COOLDOWN_TIME = 2.5;


/***/ }),

/***/ "./src/scenes/MenuScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/MenuScene.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const GameScene_1 = __webpack_require__(/*! ./GameScene */ "./src/scenes/GameScene.ts");
class MenuScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: MenuScene.TRANSITION_TIME,
        });
    }
    initialise() {
        const background = content_manager_1.default.get('menu-background');
        if (background) {
            this.background = background;
        }
        const title = content_manager_1.default.get('menu-title');
        if (title) {
            this.title = title;
        }
    }
    update(dt) {
        if (input_manager_1.default.keyPressed() || input_manager_1.default.mousePressed()) {
            scene_manager_1.default.push(new GameScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        const largestScreenDimension = Math.max(Game_1.default.screen.x, Game_1.default.screen.y);
        const aspectRatio = this.background.width / this.background.height;
        const backgroundSize = (0, vec_1.vec)(largestScreenDimension * aspectRatio, largestScreenDimension);
        if (this.background) {
            context.drawImage(this.background, Game_1.default.screen.x / 2 - backgroundSize.x / 2, Game_1.default.screen.y / 2 - backgroundSize.y / 2, largestScreenDimension * aspectRatio, largestScreenDimension);
        }
        if (this.title) {
            const y = (0, utils_1.lerp)(-this.title.height, Game_1.default.screen.y / 2 - this.title.height / 2, this.transitionAmount);
            context.drawImage(this.title, Game_1.default.screen.x / 2 - this.title.width / 2, y);
        }
        context.restore();
    }
}
exports["default"] = MenuScene;
MenuScene.TRANSITION_TIME = 1;


/***/ }),

/***/ "./content/content.json":
/*!******************************!*\
  !*** ./content/content.json ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"name":"basement-universe","type":"image","args":["./content/basement-universe.png"]},{"name":"bleep","type":"audio","args":["./content/bleep.wav"]},{"name":"blur-shader","type":"text","args":["http://localhost:8080/content/blur.glsl"],"processors":[{"name":"shader"}]},{"name":"menu-background","type":"image","args":["./content/menu-background.png"]},{"name":"menu-title","type":"image","args":["./content/menu-title.png"]},{"name":"character-spritesheet","type":"image","args":["./content/character-spritesheet.png"]},{"name":"character-texture-atlas-data","type":"json","args":["http://localhost:8080/content/character-texture-atlas.json"],"processors":[{"name":"textureAtlas","args":["character-spritesheet"]}]},{"name":"character-sprite-data","type":"json","args":["http://localhost:8080/content/character-sprite.json"],"processors":[{"name":"sprite"}]},{"name":"terrain-tilesheet","type":"image","args":["./content/terrain-tilesheet.png"]},{"name":"terrain-texture-atlas-data","type":"json","args":["http://localhost:8080/content/terrain-texture-atlas.json"],"processors":[{"name":"textureAtlas","args":["terrain-tilesheet"]}]},{"name":"tile-map-data","type":"json","args":["http://localhost:8080/content/tile-map.json"],"processors":[{"name":"tileMap","args":[{"decompressData":true}]}]}]');

/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"title":"Example Game","showFPS":true}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ./Game */ "./src/Game.ts");
window.onload = () => {
    const game = new Game_1.default(document.querySelector('#game'));
    game.initialise();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtB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QUcsQ0FBQyxFQUN6QyxJQUFJLENBQUMsZ0JBQWdCLENBQ3RCLENBQUM7WUFFRixPQUFPLENBQUMsU0FBUyxDQUNmLElBQUksQ0FBQyxLQUFLLEVBQ1YsY0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsRUFDeEMsQ0FBQyxDQUNGLENBQUM7U0FDSDtRQUVELE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNwQixDQUFDOztBQXRFSCwrQkF1RUM7QUF0RXlCLHlCQUFlLEdBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ1p0RDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7QUNOQSxrRUFBMEI7QUFFMUIsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7SUFDbkIsTUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUNwQixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9zY2VuZS1tYW5hZ2VyL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3RleHR1cmUtYXRsYXMvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvc2hhZGVyLWNhbnZhcy9kaXN0L3NoYWRlci1jYW52YXMuanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL0dhbWUudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2FjdG9ycy9BY3Rvci50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvYWN0b3JzL1BsYXllci50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvYWN0b3JzL1Byb2dyZXNzQmFyLnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9hY3RvcnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvY29udGVudC1wcm9jZXNzb3JzL3NoYWRlci5jb250ZW50LXByb2Nlc3Nvci50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvc2NlbmVzL0dhbWVTY2VuZS50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvc2NlbmVzL0ludHJvU2NlbmUudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL3NjZW5lcy9Mb2FkaW5nU2NlbmUudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL3NjZW5lcy9NZW51U2NlbmUudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICovXFxuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xcblxcbi8qKlxcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcXG4gKi9cXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBpbnRlcnBvbGF0aW9uQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtpbnRlcnBvbGF0aW9uQ2FsbGJhY2t9IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbiA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayB0aW1lc0NhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7dGltZXNDYWxsYmFja30gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIDIgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xcblxcbi8qKlxcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgbGVycCxcXG4gICAgdW5sZXJwLFxcbiAgICBibGVycCxcXG4gICAgcmVtYXAsXFxuICAgIHNtb290aHN0ZXAsXFxuICAgIHJhZGlhbnMsXFxuICAgIGRlZ3JlZXMsXFxuICAgIHJhbmRvbUJldHdlZW4sXFxuICAgIHJhbmRvbUludEJldHdlZW4sXFxuICAgIGNsdFJhbmRvbSxcXG4gICAgY2x0UmFuZG9tSW50LFxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcXG4gICAgbGVycEFycmF5LFxcbiAgICBkb3QsXFxuICAgIGZhY3RvcmlhbCxcXG4gICAgcGVybXV0YXRpb24sXFxuICAgIGNvbWJpbmF0aW9uLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIGNodW5rLFxcbiAgICBzaHVmZmxlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG5mdW5jdGlvbiBjbGFtcChhLCBtaW4gPSAwLCBtYXggPSAxKSB7XFxuICAgIHJldHVybiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcXG59XFxuY2xhc3MgQ2FtZXJhIHtcXG4gICAgY29uc3RydWN0b3IocG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuc2l6ZSA9ICgwLCB2ZWNfMS52ZWMpKCk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKCk7XFxuICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFNjYWxlID0gMTtcXG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAxO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIENhbWVyYS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICB9XFxuICAgIGdldCBwb3NpdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldFBvc2l0aW9uO1xcbiAgICB9XFxuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xcbiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHZhbHVlO1xcbiAgICB9XFxuICAgIHNldCBwb3NpdGlvbkltbWVkaWF0ZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBnZXQgYWN0dWFsUG9zaXRpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsUG9zaXRpb247XFxuICAgIH1cXG4gICAgZ2V0IHNjYWxlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0U2NhbGU7XFxuICAgIH1cXG4gICAgZ2V0IGFjdHVhbFNjYWxlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbFNjYWxlO1xcbiAgICB9XFxuICAgIHNldCBzY2FsZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IGNsYW1wKHZhbHVlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgIH1cXG4gICAgc2V0IHNjYWxlSW1tZWRpYXRlKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLl9hY3R1YWxTY2FsZSA9IGNsYW1wKHZhbHVlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgICAgICB0aGlzLnRhcmdldFNjYWxlID0gdGhpcy5fYWN0dWFsU2NhbGU7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCBzY3JlZW4gYm91bmRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNhbWVyYSBwb3NpdGlvbiBhbmQgc2NhbGVcXG4gICAgICovXFxuICAgIGdldCBib3VuZHMoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHRvcDogdGhpcy5fYWN0dWFsUG9zaXRpb24ueSAtICh0aGlzLnNpemUueSAvIDIpIC8gdGhpcy5fYWN0dWFsU2NhbGUsXFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLl9hY3R1YWxQb3NpdGlvbi55ICsgKHRoaXMuc2l6ZS55IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLl9hY3R1YWxQb3NpdGlvbi54IC0gKHRoaXMuc2l6ZS54IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICByaWdodDogdGhpcy5fYWN0dWFsUG9zaXRpb24ueCArICh0aGlzLnNpemUueCAvIDIpIC8gdGhpcy5fYWN0dWFsU2NhbGVcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnQgYSBzY3JlZW4gcG9zaXRpb24gdG8gYSB3b3JsZCBwb3NpdGlvblxcbiAgICAgKi9cXG4gICAgcG9zaXRpb25Ub1dvcmxkKHBvc2l0aW9uKSB7XFxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmJvdW5kcztcXG4gICAgICAgIHJldHVybiB2ZWNfMS52ZWMuYWRkKHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSwgdmVjXzEudmVjLm11bChwb3NpdGlvbiwgMSAvIHRoaXMuc2NhbGUpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIGNvbnRleHQgdHJhbnNmb3JtcyB0byBtYXRjaCBjYW1lcmEgcG9zaXRpb24gYW5kIHNjYWxlXFxuICAgICAqL1xcbiAgICBkcmF3KGNvbnRleHQsIHNjcmVlbikge1xcbiAgICAgICAgdGhpcy5zaXplID0gKDAsIHZlY18xLnZlYykoc2NyZWVuKTtcXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHBvc2l0aW9uIHRvIGJvdW5kc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcXG4gICAgICAgICAgICBjb25zdCBzY3JlZW5TY2FsZWQgPSB2ZWNfMS52ZWMubWFwKHZlY18xLnZlYy5tdWwodGhpcy5zaXplLCAxIC8gdGhpcy5fYWN0dWFsU2NhbGUpLCBNYXRoLmNlaWwpO1xcbiAgICAgICAgICAgIC8vIElmIHRoZSBzY2FsZWQgc2NyZWVuIHNpemUgaXMgbGFyZ2VyIHRoYW4gYWxsb3dlZCBib3VuZHMsIHdlIHJlc2l6ZVxcbiAgICAgICAgICAgIC8vIHRoZSBib3VuZHMgdG8gcHJldmVudCBqaXR0ZXJpbmdcXG4gICAgICAgICAgICBjb25zdCBhY3R1YWxCb3VuZHMgPSB7XFxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5ib3VuZHMsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBpZiAoc2NyZWVuU2NhbGVkLnggPiBhY3R1YWxCb3VuZHMucmlnaHQgLSBhY3R1YWxCb3VuZHMubGVmdCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHNXaWR0aCA9IGFjdHVhbEJvdW5kcy5yaWdodCAtIGFjdHVhbEJvdW5kcy5sZWZ0O1xcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmRGlmZiA9IChzY3JlZW5TY2FsZWQueCAtIGJvdW5kc1dpZHRoKSAvIDI7XFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kcy5sZWZ0IC09IGhhbGZEaWZmO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMucmlnaHQgKz0gaGFsZkRpZmY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzY3JlZW5TY2FsZWQueSA+IGFjdHVhbEJvdW5kcy5ib3R0b20gLSBhY3R1YWxCb3VuZHMudG9wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IGFjdHVhbEJvdW5kcy5ib3R0b20gLSBhY3R1YWxCb3VuZHMudG9wO1xcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmRGlmZiA9IChzY3JlZW5TY2FsZWQueSAtIGJvdW5kc0hlaWdodCkgLyAyO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMudG9wIC09IGhhbGZEaWZmO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMuYm90dG9tICs9IGhhbGZEaWZmO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBoYWxmU2NyZWVuU2NhbGVkID0gdmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKHNjcmVlblNjYWxlZCwgMSAvIDIpLCBNYXRoLmNlaWwpO1xcbiAgICAgICAgICAgIGNvbnN0IG1pblBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoYWN0dWFsQm91bmRzLmxlZnQgKyBoYWxmU2NyZWVuU2NhbGVkLngsIGFjdHVhbEJvdW5kcy50b3AgKyBoYWxmU2NyZWVuU2NhbGVkLnkpO1xcbiAgICAgICAgICAgIGNvbnN0IG1heFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoYWN0dWFsQm91bmRzLnJpZ2h0IC0gaGFsZlNjcmVlblNjYWxlZC54LCBhY3R1YWxCb3VuZHMuYm90dG9tIC0gaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnggPSBjbGFtcCh0aGlzLnRhcmdldFBvc2l0aW9uLngsIG1pblBvc2l0aW9uLngsIG1heFBvc2l0aW9uLngpO1xcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24ueSA9IGNsYW1wKHRoaXMudGFyZ2V0UG9zaXRpb24ueSwgbWluUG9zaXRpb24ueSwgbWF4UG9zaXRpb24ueSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBkID0gdmVjXzEudmVjLnN1Yih0aGlzLl9hY3R1YWxQb3NpdGlvbiwgdGhpcy50YXJnZXRQb3NpdGlvbik7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9IHZlY18xLnZlYy5hZGQodGhpcy5wb3NpdGlvbiwgdmVjXzEudmVjLm11bChkLCB0aGlzLm9wdGlvbnMubW92ZUVhc2VBbW91bnQpKTtcXG4gICAgICAgIGNvbnN0IHMgPSBjbGFtcCh0aGlzLnRhcmdldFNjYWxlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxTY2FsZSA9IHMgKyAodGhpcy5fYWN0dWFsU2NhbGUgLSBzKSAqIHRoaXMub3B0aW9ucy5zY2FsZUVhc2VBbW91bnQ7XFxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0aGlzLnNpemUueCAvIDIpIC0gdGhpcy5fYWN0dWFsUG9zaXRpb24ueCAqIHRoaXMuX2FjdHVhbFNjYWxlLCAodGhpcy5zaXplLnkgLyAyKSAtIHRoaXMuX2FjdHVhbFBvc2l0aW9uLnkgKiB0aGlzLl9hY3R1YWxTY2FsZSk7XFxuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuX2FjdHVhbFNjYWxlLCB0aGlzLl9hY3R1YWxTY2FsZSk7XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gQ2FtZXJhO1xcbkNhbWVyYS5kZWZhdWx0T3B0aW9ucyA9IHtcXG4gICAgYWxsb3dTY2FsZTogdHJ1ZSxcXG4gICAgbWluU2NhbGU6IDAuNSxcXG4gICAgbWF4U2NhbGU6IDQsXFxuICAgIG1vdmVFYXNlQW1vdW50OiAwLjEsXFxuICAgIHNjYWxlRWFzZUFtb3VudDogMC4xLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2NvbnRlbnQtbG9hZGVycy9hdWRpby5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2F1ZGlvLmxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5BdWRpb0xvYWRlciA9IHZvaWQgMDtcXG5jb25zdCBBdWRpb0xvYWRlciA9IGFzeW5jICh1cmwpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKHVybCk7XFxuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgKCkgPT4ge1xcbiAgICAgICAgICAgIHJlc29sdmUoYXVkaW8pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcXG4gICAgICAgICAgICByZWplY3QoYEVycm9yIGxvYWRpbmcgYXVkaW8gXFxcIiR7dXJsfVxcXCJgKTtcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59O1xcbmV4cG9ydHMuQXVkaW9Mb2FkZXIgPSBBdWRpb0xvYWRlcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LWxvYWRlcnMvYXVkaW8ubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvZm9udC5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LWxvYWRlcnMvZm9udC5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Gb250TG9hZGVyID0gdm9pZCAwO1xcbmNvbnN0IEZvbnRMb2FkZXIgPSBhc3luYyAodXJsLCBmYW1pbHkpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2UoZmFtaWx5LCBgdXJsKCR7dXJsfSlgKTtcXG4gICAgICAgIGZvbnQubG9hZCgpXFxuICAgICAgICAgICAgLnRoZW4oZm9udCA9PiB7XFxuICAgICAgICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnQpO1xcbiAgICAgICAgICAgIHJlc29sdmUoZm9udCk7XFxuICAgICAgICB9KVxcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGZvbnQgXFxcIiR7dXJsfVxcXCJgKTtcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59O1xcbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvaW1hZ2UubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy9pbWFnZS5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuSW1hZ2VMb2FkZXIgPSB2b2lkIDA7XFxuY29uc3QgSW1hZ2VMb2FkZXIgPSBhc3luYyAodXJsKSA9PiB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xcbiAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcXG4gICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XFxuICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGltYWdlIFxcXCIke3VybH1cXFwiYCk7XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufTtcXG5leHBvcnRzLkltYWdlTG9hZGVyID0gSW1hZ2VMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2ltYWdlLmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcXG4gICAgaWYgKCFkZXNjIHx8IChcXFwiZ2V0XFxcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XFxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIG9bazJdID0gbVtrXTtcXG59KSk7XFxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXVkaW8ubG9hZGVyICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9hdWRpby5sb2FkZXIudHNcXFwiKSwgZXhwb3J0cyk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9udC5sb2FkZXIgKi8gXFxcIi4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlLmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvaW1hZ2UubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzb24ubG9hZGVyICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9qc29uLmxvYWRlci50c1xcXCIpLCBleHBvcnRzKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90ZXh0LmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvdGV4dC5sb2FkZXIudHNcXFwiKSwgZXhwb3J0cyk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5KU09OTG9hZGVyID0gdm9pZCAwO1xcbmNvbnN0IEpTT05Mb2FkZXIgPSBhc3luYyAodXJsT3JEYXRhKSA9PiB7XFxuICAgIGlmICh0eXBlb2YgdXJsT3JEYXRhID09PSAnc3RyaW5nJyAmJlxcbiAgICAgICAgdXJsT3JEYXRhLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgICAgICB3aW5kb3cuZmV0Y2godXJsT3JEYXRhLCB7XFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4oanNvbiA9PiB7XFxuICAgICAgICAgICAgICAgIHJlc29sdmUoanNvbik7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGpzb24gXFxcIiR7dXJsT3JEYXRhfVxcXCJgKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiB1cmxPckRhdGE7XFxufTtcXG5leHBvcnRzLkpTT05Mb2FkZXIgPSBKU09OTG9hZGVyO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtbG9hZGVycy9qc29uLmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL3RleHQubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL3RleHQubG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuVGV4dExvYWRlciA9IHZvaWQgMDtcXG5jb25zdCBUZXh0TG9hZGVyID0gYXN5bmMgKHVybE9yVGV4dCkgPT4ge1xcbiAgICBpZiAodXJsT3JUZXh0LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgICAgICB3aW5kb3cuZmV0Y2godXJsT3JUZXh0LCB7XFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIHRleHQgXFxcIiR7dXJsT3JUZXh0fVxcXCJgKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiB1cmxPclRleHQudG9TdHJpbmcoKTtcXG59O1xcbmV4cG9ydHMuVGV4dExvYWRlciA9IFRleHRMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL3RleHQubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5JbWFnZU5hbWVQcm9jZXNzb3IgPSB2b2lkIDA7XFxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGltYWdlTmFtZUZpZWxkTmFtZTogJ2ltYWdlTmFtZScsXFxuICAgIGltYWdlRmllbGROYW1lOiAnaW1hZ2UnLFxcbn07XFxuY29uc3QgSW1hZ2VOYW1lUHJvY2Vzc29yID0gYXN5bmMgKGNvbnRlbnQsIGl0ZW0sIG9wdGlvbnMpID0+IHtcXG4gICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgIGlmICh0eXBlb2YgaXRlbS5jb250ZW50ID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgaXRlbS5jb250ZW50ICE9PSBudWxsKSB7XFxuICAgICAgICBjb25zdCBwcm9jZXNzT2JqZWN0ID0gKG8pID0+IHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBhY3R1YWxPcHRpb25zLmltYWdlTmFtZUZpZWxkTmFtZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VOYW1lID0gb1trZXldO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VJdGVtID0gKF9hID0gY29udGVudFtpbWFnZU5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUl0ZW0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvW2FjdHVhbE9wdGlvbnMuaW1hZ2VGaWVsZE5hbWVdID0gaW1hZ2VJdGVtO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvW2tleV07XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9ba2V5XSA9PT0gJ29iamVjdCcgJiZcXG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc09iamVjdChvW2tleV0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHByb2Nlc3NPYmplY3QoaXRlbS5jb250ZW50KTtcXG4gICAgfVxcbn07XFxuZXhwb3J0cy5JbWFnZU5hbWVQcm9jZXNzb3IgPSBJbWFnZU5hbWVQcm9jZXNzb3I7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1wcm9jZXNzb3JzL2ltYWdlLW5hbWUucHJvY2Vzc29yLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LXByb2Nlc3NvcnMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LXByb2Nlc3NvcnMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xcbiAgICBpZiAoIWRlc2MgfHwgKFxcXCJnZXRcXFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcXG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xcbiAgICB9XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XFxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcXG4gICAgb1trMl0gPSBtW2tdO1xcbn0pKTtcXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXFxcImRlZmF1bHRcXFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZS1uYW1lLnByb2Nlc3NvciAqLyBcXFwiLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHNcXFwiKSwgZXhwb3J0cyk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1wcm9jZXNzb3JzL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkNvbnRlbnRJdGVtU3RhdHVzID0gZXhwb3J0cy5Db250ZW50TWFuYWdlclN0YXR1cyA9IGV4cG9ydHMuQ29udGVudEl0ZW1UeXBlID0gdm9pZCAwO1xcbmNvbnN0IGNvbnRlbnRfbG9hZGVyc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250ZW50LWxvYWRlcnMgKi8gXFxcIi4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzXFxcIik7XFxuY29uc3QgY29udGVudF9wcm9jZXNzb3JzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRlbnQtcHJvY2Vzc29ycyAqLyBcXFwiLi9jb250ZW50LXByb2Nlc3NvcnMvaW5kZXgudHNcXFwiKTtcXG52YXIgQ29udGVudEl0ZW1UeXBlO1xcbihmdW5jdGlvbiAoQ29udGVudEl0ZW1UeXBlKSB7XFxuICAgIENvbnRlbnRJdGVtVHlwZVtcXFwiSlNPTlxcXCJdID0gXFxcImpzb25cXFwiO1xcbiAgICBDb250ZW50SXRlbVR5cGVbXFxcIkZvbnRcXFwiXSA9IFxcXCJmb250XFxcIjtcXG4gICAgQ29udGVudEl0ZW1UeXBlW1xcXCJJbWFnZVxcXCJdID0gXFxcImltYWdlXFxcIjtcXG4gICAgQ29udGVudEl0ZW1UeXBlW1xcXCJBdWRpb1xcXCJdID0gXFxcImF1ZGlvXFxcIjtcXG4gICAgQ29udGVudEl0ZW1UeXBlW1xcXCJUZXh0XFxcIl0gPSBcXFwidGV4dFxcXCI7XFxufSkoQ29udGVudEl0ZW1UeXBlID0gZXhwb3J0cy5Db250ZW50SXRlbVR5cGUgfHwgKGV4cG9ydHMuQ29udGVudEl0ZW1UeXBlID0ge30pKTtcXG52YXIgQ29udGVudE1hbmFnZXJTdGF0dXM7XFxuKGZ1bmN0aW9uIChDb250ZW50TWFuYWdlclN0YXR1cykge1xcbiAgICBDb250ZW50TWFuYWdlclN0YXR1c1tcXFwiSWRsZVxcXCJdID0gXFxcImlkbGVcXFwiO1xcbiAgICBDb250ZW50TWFuYWdlclN0YXR1c1tcXFwiTG9hZGluZ1xcXCJdID0gXFxcImxvYWRpbmdcXFwiO1xcbiAgICBDb250ZW50TWFuYWdlclN0YXR1c1tcXFwiUHJvY2Vzc2luZ1xcXCJdID0gXFxcInByb2Nlc3NpbmdcXFwiO1xcbiAgICBDb250ZW50TWFuYWdlclN0YXR1c1tcXFwiUmVhZHlcXFwiXSA9IFxcXCJyZWFkeVxcXCI7XFxufSkoQ29udGVudE1hbmFnZXJTdGF0dXMgPSBleHBvcnRzLkNvbnRlbnRNYW5hZ2VyU3RhdHVzIHx8IChleHBvcnRzLkNvbnRlbnRNYW5hZ2VyU3RhdHVzID0ge30pKTtcXG52YXIgQ29udGVudEl0ZW1TdGF0dXM7XFxuKGZ1bmN0aW9uIChDb250ZW50SXRlbVN0YXR1cykge1xcbiAgICBDb250ZW50SXRlbVN0YXR1c1tcXFwiSWRsZVxcXCJdID0gXFxcImlkbGVcXFwiO1xcbiAgICBDb250ZW50SXRlbVN0YXR1c1tcXFwiTG9hZGluZ1xcXCJdID0gXFxcImxvYWRpbmdcXFwiO1xcbiAgICBDb250ZW50SXRlbVN0YXR1c1tcXFwiTG9hZGVkXFxcIl0gPSBcXFwibG9hZGVkXFxcIjtcXG4gICAgQ29udGVudEl0ZW1TdGF0dXNbXFxcIlByb2Nlc3NpbmdcXFwiXSA9IFxcXCJwcm9jZXNzaW5nXFxcIjtcXG4gICAgQ29udGVudEl0ZW1TdGF0dXNbXFxcIlByb2Nlc3NlZFxcXCJdID0gXFxcInByb2Nlc3NlZFxcXCI7XFxufSkoQ29udGVudEl0ZW1TdGF0dXMgPSBleHBvcnRzLkNvbnRlbnRJdGVtU3RhdHVzIHx8IChleHBvcnRzLkNvbnRlbnRJdGVtU3RhdHVzID0ge30pKTtcXG5jb25zdCBkZWZhdWx0Q29udGVudExvYWRlcnMgPSB7XFxuICAgIFtDb250ZW50SXRlbVR5cGUuSlNPTl06IGNvbnRlbnRfbG9hZGVyc18xLkpTT05Mb2FkZXIsXFxuICAgIFtDb250ZW50SXRlbVR5cGUuRm9udF06IGNvbnRlbnRfbG9hZGVyc18xLkZvbnRMb2FkZXIsXFxuICAgIFtDb250ZW50SXRlbVR5cGUuSW1hZ2VdOiBjb250ZW50X2xvYWRlcnNfMS5JbWFnZUxvYWRlcixcXG4gICAgW0NvbnRlbnRJdGVtVHlwZS5BdWRpb106IGNvbnRlbnRfbG9hZGVyc18xLkF1ZGlvTG9hZGVyLFxcbiAgICBbQ29udGVudEl0ZW1UeXBlLlRleHRdOiBjb250ZW50X2xvYWRlcnNfMS5UZXh0TG9hZGVyLFxcbn07XFxuY29uc3QgZGVmYXVsdENvbnRlbnRQcm9jZXNzb3JzID0ge1xcbiAgICBpbWFnZU5hbWU6IGNvbnRlbnRfcHJvY2Vzc29yc18xLkltYWdlTmFtZVByb2Nlc3NvcixcXG59O1xcbmFzeW5jIGZ1bmN0aW9uIHNsZWVwKG1zKSB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcXG59XFxuZnVuY3Rpb24gY2xhbXAoYSwgbWluID0gMCwgbWF4ID0gMSkge1xcbiAgICByZXR1cm4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxufVxcbmZ1bmN0aW9uIHJhbmRvbUJldHdlZW4obWluLCBtYXgpIHtcXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG59XFxuY29uc3QgTUlOX1NMRUVQX1RJTUUgPSAxMDAwO1xcbmNvbnN0IE1BWF9TTEVFUF9USU1FID0gMzAwMDtcXG5jbGFzcyBDb250ZW50TWFuYWdlciB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGVudExpc3QgPSBbXTtcXG4gICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gMDtcXG4gICAgICAgIHRoaXMuY3VycmVudFRvdGFsUHJvZ3Jlc3MgPSAwO1xcbiAgICAgICAgdGhpcy5jb250ZW50ID0ge307XFxuICAgICAgICB0aGlzLnN0YXR1cyA9IENvbnRlbnRNYW5hZ2VyU3RhdHVzLklkbGU7XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBDb250ZW50TWFuYWdlci5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHtcXG4gICAgICAgICAgICBsb2FkZXJzOiB7XFxuICAgICAgICAgICAgICAgIC4uLkNvbnRlbnRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLmxvYWRlcnMsXFxuICAgICAgICAgICAgICAgIC4uLigoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9hZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcHJvY2Vzc29yczoge1xcbiAgICAgICAgICAgICAgICAuLi4oKF9iID0gQ29udGVudE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMucHJvY2Vzc29ycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxcbiAgICAgICAgICAgICAgICAuLi4oKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByb2Nlc3NvcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9KSxcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGNvbnRlbnQgbWFuYWdlciBhbmQgcHJvdmlkZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChDb250ZW50TWFuYWdlci5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IG1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgQ29udGVudE1hbmFnZXIob3B0aW9ucyk7XFxuICAgIH1cXG4gICAgc3RhdGljIGRpc3Bvc2UoKSB7XFxuICAgICAgICBpZiAoQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBtYW5hZ2VyIG5vdCBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGVsZXRlIENvbnRlbnRNYW5hZ2VyLmluc3RhbmNlO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmIChDb250ZW50TWFuYWdlci5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IG1hbmFnZXIgbm90IHByb3Blcmx5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gQ29udGVudE1hbmFnZXIuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEN1cnJlbnQgbG9hZGluZyBwcm9ncmVzcywgcmVwcmVzZW50ZWQgYXMgYSB1bml0IHNjYWxhciBbMCwgMV1cXG4gICAgICovXFxuICAgIHN0YXRpYyBnZXQgcHJvZ3Jlc3MoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0UHJvZ3Jlc3MoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ3VycmVudCBjb250ZW50IG1hbmFnZXIgc3RhdHVzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IHN0YXR1cygpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQ29udGVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zdGF0dXM7XFxuICAgIH1cXG4gICAgZ2V0UHJvZ3Jlc3MoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENvbnRlbnRMaXN0Lmxlbmd0aCB8fCB0aGlzLmN1cnJlbnRUb3RhbFByb2dyZXNzID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY2xhbXAodGhpcy5jdXJyZW50UHJvZ3Jlc3MgLyB0aGlzLmN1cnJlbnRUb3RhbFByb2dyZXNzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogTG9hZCBjb250ZW50IGl0ZW1zXFxuICAgICAqXFxuICAgICAqIEV4aXN0aW5nIGNvbnRlbnQgaXRlbXMgd2lsbCBiZSByZXRhaW5lZCwgYW5kIGFueSBjb250ZW50IGl0ZW1zIHdoaWNoXFxuICAgICAqIGFscmVhZHkgZXhpc3Qgd2lsbCBiZSByZS1sb2FkZWRcXG4gICAgICovXFxuICAgIHN0YXRpYyBhc3luYyBsb2FkKGl0ZW1zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xcbiAgICAgICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnMubG9hZGVycyB8fFxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm9wdGlvbnMubG9hZGVycykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZW50IGxvYWRlcnMgZGVmaW5lZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5zdGFuY2UuY3VycmVudENvbnRlbnRMaXN0ID0gaXRlbXM7XFxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdGFza3Mgd2UgbmVlZCB0byBwZXJmb3JtXFxuICAgICAgICBjb25zdCBjb3VudFRvdGFsVG9Mb2FkID0gaXRlbXMubGVuZ3RoO1xcbiAgICAgICAgY29uc3QgY291bnRUb3RhbFRvUHJvY2VzcyA9IGl0ZW1zLnJlZHVjZSgoYSwgYykgPT4geyB2YXIgX2E7IHJldHVybiBhICsgKChfYSA9IGMucHJvY2Vzc29ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDsgfSwgMCk7XFxuICAgICAgICBpbnN0YW5jZS5jdXJyZW50UHJvZ3Jlc3MgPSAwO1xcbiAgICAgICAgaW5zdGFuY2UuY3VycmVudFRvdGFsUHJvZ3Jlc3MgPSBjb3VudFRvdGFsVG9Mb2FkICsgY291bnRUb3RhbFRvUHJvY2VzcztcXG4gICAgICAgIC8vIExvYWQgaXRlbXNcXG4gICAgICAgIGluc3RhbmNlLnN0YXR1cyA9IENvbnRlbnRNYW5hZ2VyU3RhdHVzLkxvYWRpbmc7XFxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcXG4gICAgICAgICAgICBpZiAoIShpdGVtLnR5cGUgaW4gaW5zdGFuY2Uub3B0aW9ucy5sb2FkZXJzKSkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbnRlbnQgbG9hZGVyIGRlZmluZWQgZm9yIHR5cGUgXFxcIiR7aXRlbS50eXBlfVxcXCJgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLm9wdGlvbnMuc2ltdWxhdGVTbG93TG9hZGluZykge1xcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyYW5kb21CZXR3ZWVuKChfYSA9IGluc3RhbmNlLm9wdGlvbnMuc2xvd0xvYWRpbmdUaW1lTWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNSU5fU0xFRVBfVElNRSwgKF9iID0gaW5zdGFuY2Uub3B0aW9ucy5zbG93TG9hZGluZ1RpbWVNYXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1BWF9TTEVFUF9USU1FKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRJdGVtID0ge1xcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXFxuICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcXG4gICAgICAgICAgICAgICAgY29udGVudDogbnVsbCxcXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBDb250ZW50SXRlbVN0YXR1cy5Mb2FkaW5nLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgaW5zdGFuY2UuY29udGVudFtpdGVtLm5hbWVdID0gY29udGVudEl0ZW07XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uY29udGVudCA9IGF3YWl0IGluc3RhbmNlLm9wdGlvbnMubG9hZGVyc1tpdGVtLnR5cGVdKC4uLml0ZW0uYXJncyk7XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uc3RhdHVzID0gQ29udGVudEl0ZW1TdGF0dXMuTG9hZGVkO1xcbiAgICAgICAgICAgIGluc3RhbmNlLmN1cnJlbnRQcm9ncmVzcysrO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gUHJvY2VzcyBpdGVtc1xcbiAgICAgICAgaW5zdGFuY2Uuc3RhdHVzID0gQ29udGVudE1hbmFnZXJTdGF0dXMuUHJvY2Vzc2luZztcXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xcbiAgICAgICAgICAgIGlmICghaXRlbS5wcm9jZXNzb3JzIHx8IGl0ZW0ucHJvY2Vzc29ycy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2Uub3B0aW9ucy5wcm9jZXNzb3JzIHx8XFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm9wdGlvbnMucHJvY2Vzc29ycykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGVudCBwcm9jZXNzb3JzIGRlZmluZWQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29uc3QgY29udGVudEl0ZW0gPSBpbnN0YW5jZS5jb250ZW50W2l0ZW0ubmFtZV07XFxuICAgICAgICAgICAgaWYgKCFjb250ZW50SXRlbSkge1xcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwb2ludDsgdGhlIGl0ZW0gd2lsbCBoYXZlIGJlZW4gbG9hZGVkXFxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGRlZCB0byB0aGUgaW5zdGFuY2UncyBjb250ZW50IGRpY3Rpb25hcnkuLi4gYnV0IGp1c3QgaW4gY2FzZVxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGl0ZW0gd2l0aCBuYW1lIFxcXCIke2l0ZW0ubmFtZX1cXFwiYCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5vcHRpb25zLnNpbXVsYXRlU2xvd1Byb2Nlc3NpbmcpIHtcXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmFuZG9tQmV0d2VlbigoX2MgPSBpbnN0YW5jZS5vcHRpb25zLnNsb3dQcm9jZXNzaW5nVGltZU1pbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTUlOX1NMRUVQX1RJTUUsIChfZCA9IGluc3RhbmNlLm9wdGlvbnMuc2xvd1Byb2Nlc3NpbmdUaW1lTWF4KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBNQVhfU0xFRVBfVElNRSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZW50SXRlbS5zdGF0dXMgPSBDb250ZW50SXRlbVN0YXR1cy5Qcm9jZXNzaW5nO1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGl0ZW0ucHJvY2Vzc29ycykge1xcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzb3IubmFtZSBpbiBpbnN0YW5jZS5vcHRpb25zLnByb2Nlc3NvcnMpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbnRlbnQgcHJvY2Vzc29yIGRlZmluZWQgd2l0aCBuYW1lIFxcXCIke3Byb2Nlc3Nvci5uYW1lfVxcXCJgKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5vcHRpb25zLnByb2Nlc3NvcnNbcHJvY2Vzc29yLm5hbWVdKGluc3RhbmNlLmNvbnRlbnQsIGNvbnRlbnRJdGVtLCAuLi4oKF9lID0gcHJvY2Vzc29yLmFyZ3MpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSk7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmN1cnJlbnRQcm9ncmVzcysrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZW50SXRlbS5zdGF0dXMgPSBDb250ZW50SXRlbVN0YXR1cy5Qcm9jZXNzZWQ7XFxuICAgICAgICB9XFxuICAgICAgICBpbnN0YW5jZS5zdGF0dXMgPSBDb250ZW50TWFuYWdlclN0YXR1cy5SZWFkeTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmV0cmlldmUgYSBjb250ZW50IGl0ZW0gYnkgbmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGdldChuYW1lKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoIShuYW1lIGluIGluc3RhbmNlLmNvbnRlbnQpKSB7XFxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLm9wdGlvbnMudGhyb3dPbk5vdEZvdW5kKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGVudCBpdGVtIFxcXCIke25hbWV9XFxcIiBub3QgZm91bmRgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5jb250ZW50W25hbWVdLmNvbnRlbnQ7XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gQ29udGVudE1hbmFnZXI7XFxuQ29udGVudE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGxvYWRlcnM6IGRlZmF1bHRDb250ZW50TG9hZGVycyxcXG4gICAgcHJvY2Vzc29yczogZGVmYXVsdENvbnRlbnRQcm9jZXNzb3JzLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIGludGVycG9sYXRpb25DYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge2ludGVycG9sYXRpb25DYWxsYmFja30gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IHBlcm11dGF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgY29tYmluYXRpb24gPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXFxuICogQGNhbGxiYWNrIHRpbWVzQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XFxuICogQHBhcmFtIHt0aW1lc0NhbGxiYWNrfSBmXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8Kj59XFxuICovXFxuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcXG4gKi9cXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcXG5cXG4vKipcXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYlxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cXG4gKi9cXG5jb25zdCB6aXAgPSAoYSwgYikgPT4gYS5tYXAoKGssIGkpID0+IFtrLCBiW2ldXSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBwZXJtdXRhdGlvbixcXG4gICAgY29tYmluYXRpb24sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zy8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJjb25zdCB7IHRpbWVzLCBjaHVuaywgZG90IH0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5cXG4vKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZGVidWcvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmNsYXNzIERlYnVnIHtcXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0VmFsdWUpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0Q2hhcnQpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRDaGFydCA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRDaGFydCwgb3B0aW9ucy5kZWZhdWx0Q2hhcnQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0TWFya2VyKSB7XFxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0TWFya2VyID0gT2JqZWN0LmFzc2lnbih7fSwgRGVidWcuZGVmYXVsdE9wdGlvbnMuZGVmYXVsdE1hcmtlciwgb3B0aW9ucy5kZWZhdWx0TWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdEJvcmRlcikge1xcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEJvcmRlciA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRCb3JkZXIsIG9wdGlvbnMuZGVmYXVsdEJvcmRlcik7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XFxuICAgICAgICB0aGlzLmNoYXJ0cyA9IG5ldyBNYXAoKTtcXG4gICAgICAgIHRoaXMubWFya2VycyA9IG5ldyBNYXAoKTtcXG4gICAgICAgIHRoaXMuYm9yZGVycyA9IG5ldyBNYXAoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGlzZSB0aGUgZGVidWcgcmVuZGVyZXIgZm9yIGRpc3BsYXlpbmcgdmFsdWVzIGFuZCBtYXJrZXJzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgaW5pdGlhbGlzZShvcHRpb25zID0ge30pIHtcXG4gICAgICAgIGlmIChEZWJ1Zy5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWJ1ZyBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICBEZWJ1Zy5pbnN0YW5jZSA9IG5ldyBEZWJ1ZyhvcHRpb25zKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XFxuICAgICAgICBpZiAoRGVidWcuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVidWcgbm90IHByb3Blcmx5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gRGVidWcuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBkZWJ1ZyB2YWx1ZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIHZhbHVlKGxhYmVsLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UudmFsdWVzLnNldChsYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucy5kZWZhdWx0VmFsdWUsIChfYSA9IGluc3RhbmNlLnZhbHVlcy5nZXQobGFiZWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHsgbGFiZWwsIHZhbHVlIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2hvdyBhIGRlYnVnIGNoYXJ0XFxuICAgICAqL1xcbiAgICBzdGF0aWMgY2hhcnQobGFiZWwsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgY29uc3QgY3VycmVudENoYXJ0ID0gaW5zdGFuY2UuY2hhcnRzLmdldChsYWJlbCk7XFxuICAgICAgICBpbnN0YW5jZS5jaGFydHMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRDaGFydCwgY3VycmVudENoYXJ0ICE9PSBudWxsICYmIGN1cnJlbnRDaGFydCAhPT0gdm9pZCAwID8gY3VycmVudENoYXJ0IDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7XFxuICAgICAgICAgICAgbGFiZWwsXFxuICAgICAgICAgICAgdmFsdWVzOiBbLi4uKF9hID0gY3VycmVudENoYXJ0ID09PSBudWxsIHx8IGN1cnJlbnRDaGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudENoYXJ0LnZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIHZhbHVlXS5zbGljZSgtKChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YWx1ZUJ1ZmZlclNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdENoYXJ0LnZhbHVlQnVmZmVyU2l6ZSkpLFxcbiAgICAgICAgfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgYSBkZWJ1ZyBjaGFydFxcbiAgICAgKi9cXG4gICAgc3RhdGljIHJlbW92ZUNoYXJ0KGxhYmVsKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS5jaGFydHMuZGVsZXRlKGxhYmVsKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2hvdyBhIG1hcmtlciBpbiB3b3JsZCBvciBzY3JlZW4gc3BhY2VcXG4gICAgICovXFxuICAgIHN0YXRpYyBtYXJrZXIobGFiZWwsIHZhbHVlLCBwb3NpdGlvbiwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UubWFya2Vycy5zZXQobGFiZWwsIE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdE1hcmtlciwgKF9hID0gaW5zdGFuY2UubWFya2Vycy5nZXQobGFiZWwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHsgbGFiZWwsIHZhbHVlLCBwb3NpdGlvbiB9KSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBib3JkZXIgaW4gd29ybGQgb3Igc2NyZWVuIHNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgYm9yZGVyKGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvcmRlclNoYXBlKSA9PT0gJ2NpcmNsZScgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYWRpdXMpID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhlIGJvcmRlciBpZiBpdCdzIGNpcmN1bGFyIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmFkaXVzXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9yZGVyU2hhcGUpICE9PSAnY2lyY2xlJyAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgdGhlIGJvcmRlciBpZiBpdCdzIHJlY3Rhbmd1bGFyIChkZWZhdWx0IGlzIHJlY3Rhbmd1bGFyKSBidXRcXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgc2l6ZVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRCb3JkZXIsIChfYSA9IGluc3RhbmNlLmJvcmRlcnMuZ2V0KGxhYmVsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7IGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24gfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW5kZXIgdGhlIGRlYnVnIHZhbHVlcyBhbmQgbWFya2VycyBvbnRvIGEgY2FudmFzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZHJhdyhjb250ZXh0KSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBEcmF3IHdvcmxkLXNwYWNlIG1hcmtlcnMgJiBib3JkZXJzXFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xcbiAgICAgICAgICAgIGlmIChtYXJrZXIuc3BhY2UgPT09ICd3b3JsZCcpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd01hcmtlcihjb250ZXh0LCBtYXJrZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5mb3JFYWNoKGJvcmRlciA9PiB7XFxuICAgICAgICAgICAgaWYgKGJvcmRlci5zcGFjZSA9PT0gJ3dvcmxkJykge1xcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kcmF3Qm9yZGVyKGNvbnRleHQsIGJvcmRlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgICAgIC8vIERyYXcgdmFsdWVzLCBjaGFydHMgYW5kIHNjcmVlbi1zcGFjZSBtYXJrZXJzICYgYm9yZGVyc1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcXG4gICAgICAgIGxldCBwb3NpdGlvbjtcXG4gICAgICAgIGxldCBsZWZ0WSA9IGluc3RhbmNlLm9wdGlvbnMubWFyZ2luO1xcbiAgICAgICAgbGV0IHJpZ2h0WSA9IGluc3RhbmNlLm9wdGlvbnMubWFyZ2luO1xcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IChpbnN0YW5jZS5vcHRpb25zLmxpbmVIZWlnaHQgK1xcbiAgICAgICAgICAgIGluc3RhbmNlLm9wdGlvbnMucGFkZGluZyAqIDIpO1xcbiAgICAgICAgaW5zdGFuY2UudmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuYWxpZ24pIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGluc3RhbmNlLm9wdGlvbnMubWFyZ2luLCBsZWZ0WSk7XFxuICAgICAgICAgICAgICAgICAgICBsZWZ0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoY29udGV4dC5jYW52YXMuY2xpZW50V2lkdGggLSBpbnN0YW5jZS5vcHRpb25zLm1hcmdpbiwgcmlnaHRZKTtcXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGluc3RhbmNlLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9hID0gdmFsdWUubGFiZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCAoX2IgPSB2YWx1ZS52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsIHZhbHVlLnNob3dMYWJlbCwgdHJ1ZSksIHBvc2l0aW9uLCB2YWx1ZS5hbGlnbiwgKF9jID0gdmFsdWUucGFkZGluZykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogaW5zdGFuY2Uub3B0aW9ucy5wYWRkaW5nLCAoX2QgPSB2YWx1ZS5mb250KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBpbnN0YW5jZS5vcHRpb25zLmZvbnQsIChfZSA9IHZhbHVlLmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGluc3RhbmNlLm9wdGlvbnMuZm9yZWdyb3VuZENvbG91ciwgKF9mID0gdmFsdWUuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogaW5zdGFuY2Uub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3VyKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuY2hhcnRzLmZvckVhY2goY2hhcnQgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XFxuICAgICAgICAgICAgc3dpdGNoIChjaGFydC5hbGlnbikge1xcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIGxlZnRZKTtcXG4gICAgICAgICAgICAgICAgICAgIGxlZnRZICs9IGxpbmVIZWlnaHQgKyBpbnN0YW5jZS5vcHRpb25zLmxpbmVNYXJnaW47XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKShjb250ZXh0LmNhbnZhcy5jbGllbnRXaWR0aCAtIGluc3RhbmNlLm9wdGlvbnMubWFyZ2luLCByaWdodFkpO1xcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRZICs9IGxpbmVIZWlnaHQgKyBpbnN0YW5jZS5vcHRpb25zLmxpbmVNYXJnaW47XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0NoYXJ0KGNvbnRleHQsIERlYnVnLnByZXBhcmVMYWJlbCgoX2EgPSBjaGFydC5sYWJlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsICcnLCBjaGFydC5zaG93TGFiZWwsIGZhbHNlKSwgcG9zaXRpb24sIGNoYXJ0LmFsaWduLCAoX2IgPSBjaGFydC5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbnN0YW5jZS5vcHRpb25zLnBhZGRpbmcsIChfYyA9IGNoYXJ0LmZvbnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGluc3RhbmNlLm9wdGlvbnMuZm9udCwgKF9kID0gY2hhcnQuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogaW5zdGFuY2Uub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3VyLCAoX2UgPSBjaGFydC5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBpbnN0YW5jZS5vcHRpb25zLmJhY2tncm91bmRDb2xvdXIsIGNoYXJ0LmNoYXJ0QmFja2dyb3VuZENvbG91ciwgY2hhcnQudmFsdWVzLCBjaGFydC52YWx1ZUJ1ZmZlclNpemUsIGNoYXJ0LnZhbHVlQnVmZmVyU3RyaWRlLCBjaGFydC5taW5WYWx1ZSwgY2hhcnQubWF4VmFsdWUsIGNoYXJ0LmJhcldpZHRoLCBjaGFydC5iYXJDb2xvdXJzKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiB7XFxuICAgICAgICAgICAgaWYgKG1hcmtlci5zcGFjZSA9PT0gJ3NjcmVlbicpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd01hcmtlcihjb250ZXh0LCBtYXJrZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5mb3JFYWNoKGJvcmRlciA9PiB7XFxuICAgICAgICAgICAgaWYgKGJvcmRlci5zcGFjZSA9PT0gJ3NjcmVlbicpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0JvcmRlcihjb250ZXh0LCBib3JkZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAvLyBDbGVhciB2YWx1ZXMsIG1hcmtlcnMgJiBib3JkZXJzIHJlYWR5IGZvciBuZXh0IGZyYW1lXFxuICAgICAgICBpbnN0YW5jZS52YWx1ZXMuY2xlYXIoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuY2xlYXIoKTtcXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuY2xlYXIoKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgcHJlcGFyZUxhYmVsKGxhYmVsLCB2YWx1ZSwgc2hvd0xhYmVsLCBzaG93VmFsdWUpIHtcXG4gICAgICAgIGNvbnN0IGFjdHVhbExhYmVsID0gKHNob3dMYWJlbCAmJiBsYWJlbCkgPyBsYWJlbCA6ICcnO1xcbiAgICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSAoISFzaG93VmFsdWUgJiYgdmFsdWUgIT09ICcnKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IChhY3R1YWxMYWJlbCAmJiBhY3R1YWxWYWx1ZSkgPyAnOiAnIDogJyc7XFxuICAgICAgICByZXR1cm4gYCR7YWN0dWFsTGFiZWx9JHtzZXBhcmF0b3J9JHthY3R1YWxWYWx1ZX1gO1xcbiAgICB9XFxuICAgIGRyYXdMYWJlbChjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbiwgYWxpZ24sIHBhZGRpbmcsIGZvbnQsIGZvcmVncm91bmRDb2xvdXIsIGJhY2tncm91bmRDb2xvdXIpIHtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XFxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IHtcXG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB4ID0gYWxpZ24gPT09ICdyaWdodCdcXG4gICAgICAgICAgICA/IChwb3NpdGlvbi54IC0gYmFja2dyb3VuZFNpemUud2lkdGgpXFxuICAgICAgICAgICAgOiBwb3NpdGlvbi54O1xcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggLSBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgYmFja2dyb3VuZFNpemUud2lkdGgsIGJhY2tncm91bmRTaXplLmhlaWdodCk7XFxuICAgICAgICAvLyBEcmF3IHRleHRcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q2hhcnQoY29udGV4dCwgbGFiZWwsIHBvc2l0aW9uLCBhbGlnbiwgcGFkZGluZywgZm9udCwgZm9yZWdyb3VuZENvbG91ciwgYmFja2dyb3VuZENvbG91ciwgY2hhcnRCYWNrZ3JvdW5kQ29sb3VyLCB2YWx1ZXMsIHZhbHVlQnVmZmVyU2l6ZSwgdmFsdWVCdWZmZXJTdHJpZGUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgYmFyV2lkdGgsIGJhckNvbG91cnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XFxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xcbiAgICAgICAgY29uc3QgY2hhcnRTaXplID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCAqIE1hdGguY2VpbCh2YWx1ZUJ1ZmZlclNpemUgLyBNYXRoLm1heCh2YWx1ZUJ1ZmZlclN0cmlkZSwgMSkpLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCBsYWJlbFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IChsYWJlbFNpemUud2lkdGggK1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nICtcXG4gICAgICAgICAgICAgICAgY2hhcnRTaXplLndpZHRoKSArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB4ID0gYWxpZ24gPT09ICdyaWdodCdcXG4gICAgICAgICAgICA/IChwb3NpdGlvbi54IC0gYmFja2dyb3VuZFNpemUud2lkdGgpXFxuICAgICAgICAgICAgOiBwb3NpdGlvbi54O1xcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggLSBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgYmFja2dyb3VuZFNpemUud2lkdGgsIGJhY2tncm91bmRTaXplLmhlaWdodCk7XFxuICAgICAgICAvLyBEcmF3IGxhYmVsXFxuICAgICAgICBpZiAobGFiZWwpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZvcmVncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChsYWJlbCwgeCwgcG9zaXRpb24ueSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBEcmF3IGNoYXJ0XFxuICAgICAgICBpZiAoY2hhcnRCYWNrZ3JvdW5kQ29sb3VyKSB7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjaGFydEJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4ICsgcGFkZGluZyArIGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nLCBjaGFydFNpemUud2lkdGgsIGNoYXJ0U2l6ZS5oZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBtYXhWYWx1ZSAtIG1pblZhbHVlO1xcbiAgICAgICAgY29uc3QgYmFyT2Zmc2V0ID0gKDAsIHZlY18xLnZlYykoeCArIHBhZGRpbmcgKyBsYWJlbFNpemUud2lkdGggKyBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZyk7XFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGguY2VpbCh2YWx1ZXMubGVuZ3RoIC8gTWF0aC5tYXgodmFsdWVCdWZmZXJTdHJpZGUsIDEpKTsgaSsrKSB7XFxuICAgICAgICAgICAgbGV0IHZhbHVlO1xcbiAgICAgICAgICAgIGlmICh2YWx1ZUJ1ZmZlclN0cmlkZSA8PSAxKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNcXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpICogdmFsdWVCdWZmZXJTdHJpZGUsIChpICsgMSkgKiB2YWx1ZUJ1ZmZlclN0cmlkZSlcXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHZhbHVlQnVmZmVyU3RyaWRlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBiYXJTaXplID0gKDAsIHZlY18xLnZlYykoYmFyV2lkdGgsIE1hdGgucm91bmQoY2hhcnRTaXplLmhlaWdodCAqICh2YWx1ZSAtIG1pblZhbHVlKSAvIHJhbmdlKSk7XFxuICAgICAgICAgICAgY29uc3QgYmFyUG9zaXRpb24gPSB2ZWNfMS52ZWMuYWRkKGJhck9mZnNldCwgKDAsIHZlY18xLnZlYykoKHZhbHVlcy5sZW5ndGggPCB2YWx1ZUJ1ZmZlclNpemVcXG4gICAgICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHZhbHVlQnVmZmVyU2l6ZSAtIHZhbHVlcy5sZW5ndGgpIC8gdmFsdWVCdWZmZXJTdHJpZGUpICogYmFyV2lkdGhcXG4gICAgICAgICAgICAgICAgOiAwKSArIGkgKiBiYXJXaWR0aCwgY2hhcnRTaXplLmhlaWdodCAtIGJhclNpemUueSkpO1xcbiAgICAgICAgICAgIGNvbnN0IGJhckNvbG91ciA9IChfYiA9IChiYXJDb2xvdXJzXFxuICAgICAgICAgICAgICAgID8gKF9hID0gWy4uLmJhckNvbG91cnNdLnJldmVyc2UoKS5maW5kKGMgPT4gdmFsdWVzW2ldID49IGMub2Zmc2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbG91clxcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZvcmVncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBiYXJDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChiYXJQb3NpdGlvbi54LCBiYXJQb3NpdGlvbi55LCBiYXJTaXplLngsIGJhclNpemUueSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3TWFya2VyKGNvbnRleHQsIG1hcmtlcikge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IChfYSA9IG1hcmtlci5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIGlmIChtYXJrZXIuc2hvd0xhYmVsIHx8IG1hcmtlci5zaG93VmFsdWUpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gbWFya2VyLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gbWFya2VyLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgbWFya2VyLnNob3dMYWJlbCwgbWFya2VyLnNob3dWYWx1ZSksIHZlY18xLnZlYy5hZGQocG9zaXRpb24gIT09IG51bGwgJiYgcG9zaXRpb24gIT09IHZvaWQgMCA/IHBvc2l0aW9uIDogKDAsIHZlY18xLnZlYykoKSwgbWFya2VyLmxhYmVsT2Zmc2V0KSwgJ2xlZnQnLCAoX2QgPSBtYXJrZXIucGFkZGluZykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5vcHRpb25zLnBhZGRpbmcsIChfZSA9IG1hcmtlci5mb250KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLm9wdGlvbnMuZm9udCwgKF9mID0gbWFya2VyLmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3VyLCAoX2cgPSBtYXJrZXIuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvdXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG1hcmtlci5zaG93TWFya2VyKSB7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAyO1xcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb250ZXh0LmZpbGxTdHlsZSA9IG1hcmtlci5tYXJrZXJDb2xvdXI7XFxuICAgICAgICAgICAgc3dpdGNoIChtYXJrZXIubWFya2VyU3R5bGUpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDcm9zcyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBtYXJrZXIubWFya2VyU2l6ZSk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q3Jvc3MoY29udGV4dCwgcG9zaXRpb24sIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDI7XFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54ICsgaGFsZlNpemUsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5hcmMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKTtcXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICB9XFxuICAgIGRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKF9hID0gYm9yZGVyLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgaWYgKGJvcmRlci5zaG93TGFiZWwgfHwgYm9yZGVyLnNob3dWYWx1ZSkge1xcbiAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVsKGNvbnRleHQsIERlYnVnLnByZXBhcmVMYWJlbCgoX2IgPSBib3JkZXIubGFiZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCAoX2MgPSBib3JkZXIudmFsdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLCBib3JkZXIuc2hvd0xhYmVsLCBib3JkZXIuc2hvd1ZhbHVlKSwgdmVjXzEudmVjLmFkZChwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiAoMCwgdmVjXzEudmVjKSgpLCBib3JkZXIubGFiZWxPZmZzZXQpLCAnbGVmdCcsIChfZCA9IGJvcmRlci5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLm9wdGlvbnMucGFkZGluZywgKF9lID0gYm9yZGVyLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3B0aW9ucy5mb250LCAoX2YgPSBib3JkZXIuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IGJvcmRlci5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYm9yZGVyLnNob3dCb3JkZXIpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlci5ib3JkZXJXaWR0aDtcXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29udGV4dC5maWxsU3R5bGUgPSBib3JkZXIuYm9yZGVyQ29sb3VyO1xcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclN0eWxlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyRGFzaFNpemUsIGJvcmRlci5ib3JkZXJEYXNoU2l6ZV0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyV2lkdGgsIGJvcmRlci5ib3JkZXJXaWR0aF0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclNoYXBlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyLnNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5zaXplKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlci5yYWRpdXMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5yYWRpdXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd1JlY3RhbmdsZShjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQucmVjdChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBzaXplLngsIHNpemUueSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIHJhZGl1cykge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQuYXJjKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBEZWJ1ZztcXG5EZWJ1Zy5kZWZhdWx0T3B0aW9ucyA9IHtcXG4gICAgbWFyZ2luOiAxMCxcXG4gICAgcGFkZGluZzogNCxcXG4gICAgZm9udDogJzEwcHQgTHVjaWRhIENvbnNvbGUsIG1vbm9zcGFjZScsXFxuICAgIGxpbmVIZWlnaHQ6IDEyLFxcbiAgICBsaW5lTWFyZ2luOiAwLFxcbiAgICBmb3JlZ3JvdW5kQ29sb3VyOiAnI2ZmZicsXFxuICAgIGJhY2tncm91bmRDb2xvdXI6ICcjMzMzJyxcXG4gICAgZGVmYXVsdFZhbHVlOiB7XFxuICAgICAgICBhbGlnbjogJ2xlZnQnLFxcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICB9LFxcbiAgICBkZWZhdWx0Q2hhcnQ6IHtcXG4gICAgICAgIHZhbHVlczogW10sXFxuICAgICAgICB2YWx1ZUJ1ZmZlclNpemU6IDYwLFxcbiAgICAgICAgdmFsdWVCdWZmZXJTdHJpZGU6IDEsXFxuICAgICAgICBtaW5WYWx1ZTogMCxcXG4gICAgICAgIG1heFZhbHVlOiAxMDAsXFxuICAgICAgICBiYXJXaWR0aDogMixcXG4gICAgICAgIGFsaWduOiAnbGVmdCcsXFxuICAgICAgICBzaG93TGFiZWw6IHRydWUsXFxuICAgICAgICBjaGFydEJhY2tncm91bmRDb2xvdXI6ICcjMjIyJyxcXG4gICAgfSxcXG4gICAgZGVmYXVsdE1hcmtlcjoge1xcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICAgICAgc2hvd1ZhbHVlOiB0cnVlLFxcbiAgICAgICAgc2hvd01hcmtlcjogdHJ1ZSxcXG4gICAgICAgIG1hcmtlclNpemU6IDYsXFxuICAgICAgICBtYXJrZXJTdHlsZTogJ3gnLFxcbiAgICAgICAgbWFya2VyQ29sb3VyOiAnI2NjYycsXFxuICAgICAgICBzcGFjZTogJ3dvcmxkJyxcXG4gICAgICAgIGxhYmVsT2Zmc2V0OiAoMCwgdmVjXzEudmVjKSgxMCksXFxuICAgIH0sXFxuICAgIGRlZmF1bHRCb3JkZXI6IHtcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgICAgIHNob3dWYWx1ZTogdHJ1ZSxcXG4gICAgICAgIHNob3dCb3JkZXI6IHRydWUsXFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcXG4gICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxcbiAgICAgICAgYm9yZGVyU2hhcGU6ICdyZWN0YW5nbGUnLFxcbiAgICAgICAgYm9yZGVyQ29sb3VyOiAnI2NjYycsXFxuICAgICAgICBib3JkZXJEYXNoU2l6ZTogNSxcXG4gICAgICAgIHNwYWNlOiAnd29ybGQnLFxcbiAgICAgICAgbGFiZWxPZmZzZXQ6ICgwLCB2ZWNfMS52ZWMpKDEwKSxcXG4gICAgfSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIGludGVycG9sYXRpb25DYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge2ludGVycG9sYXRpb25DYWxsYmFja30gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IHBlcm11dGF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgY29tYmluYXRpb24gPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYXJyYXkgdmFsdWVzXFxuICogQGNhbGxiYWNrIHRpbWVzQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBUaGUgYXJyYXkgdmFsdWVcXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XFxuICogQHBhcmFtIHt0aW1lc0NhbGxiYWNrfSBmXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8Kj59XFxuICovXFxuY29uc3QgdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgMC0+KG4gLSAxKVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcXG4gKi9cXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcXG5cXG4vKipcXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYlxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cXG4gKi9cXG5jb25zdCB6aXAgPSAoYSwgYikgPT4gYS5tYXAoKGssIGkpID0+IFtrLCBiW2ldXSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGl2ZWx5L25lZ2F0aXZlbHkgd3JhcHBlZCBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBhdCA9IChhLCBpKSA9PiBhW2kgPCAwID8gYS5sZW5ndGggLSAoTWF0aC5hYnMoaSArIDEpICUgYS5sZW5ndGgpIC0gMSA6IGkgJSBhLmxlbmd0aF07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBwZXJtdXRhdGlvbixcXG4gICAgY29tYmluYXRpb24sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWNcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlY30gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gQSBuZXcgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+VmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMoMywgMik7ICAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYyg0KTsgICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjKGEpOyAgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMoKTsgICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMgPSAoeCwgeSkgPT4gKCF4ICYmICF5ID9cXG4gIHsgeDogMCwgeTogMCB9IDogKHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XFxuICAgIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwIH0gOiAoeSA9PT0gbnVsbCB8fCB5ID09PSB1bmRlZmluZWQgP1xcbiAgICAgIHsgeDogeCwgeTogeCB9IDogeyB4OiB4LCB5OiB5IH0pXFxuICApXFxuKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjLnV4ID0gKCkgPT4gdmVjKDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqIEByZXR1cm4ge3ZlY30gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMudXkgPSAoKSA9PiB2ZWMoMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjfSBhICsgYlxcbiAqL1xcbnZlYy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjfSBhICogYlxcbiAqL1xcbnZlYy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogYiwgeTogYS55ICogYiB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAtIGJcXG4gKi9cXG52ZWMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWN9IF5hXFxuICovXFxudmVjLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYy5yYWQgPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLngpO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYy5jcHkgPSBhID0+IHZlYyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjdG9yTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjdG9yTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlY30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYy5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCB0aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQuZGV0ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoYS5tID09PSAxKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF07XFxuICB9XFxuICBpZiAoYS5tID09PSAyKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF0gKiBhLmVudHJpZXNbM10gLSBhLmVudHJpZXNbMV0gKiBhLmVudHJpZXNbMl07XFxuICB9XFxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcXG4gIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xcbiAgICBzaWduICo9IC0xO1xcbiAgfVxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBjaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG5jbGFzcyBJbnB1dE1hbmFnZXIge1xcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgICAgICB0aGlzLmtleWJvYXJkU3RhdGUgPSB7fTtcXG4gICAgICAgIHRoaXMucHJldmlvdXNLZXlib2FyZFN0YXRlID0ge307XFxuICAgICAgICB0aGlzLm1vdXNlU3RhdGUgPSB7IGJ1dHRvbjogZmFsc2UsIHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjKSgpLCB3aGVlbDogMCB9O1xcbiAgICAgICAgdGhpcy5wcmV2aW91c01vdXNlU3RhdGUgPSB7IGJ1dHRvbjogZmFsc2UsIHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjKSgpLCB3aGVlbDogMCB9O1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgSW5wdXRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgICAgICAvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnNcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW91c2UpIHtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuYnV0dG9uID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbiA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKCkgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuYnV0dG9uID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5idXR0b24gPSBmYWxzZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5wb3NpdGlvbi54ID0gZS5vZmZzZXRYO1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUucG9zaXRpb24ueSA9IGUub2Zmc2V0WTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vdXNlV2hlZWwpIHtcXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUud2hlZWwgPSBlLmRlbHRhWSA+IDAgPyAxIDogLTE7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkU3RhdGVbZS5jb2RlXSA9IHRydWU7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTdGF0ZVtlLmNvZGVdID0gZmFsc2U7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGlucHV0IG1hbmFnZXIgZm9yIG1hbmFnaW5nIG1vdXNlIGFuZCBrZXlib2FyZCBpbnB1dFxcbiAgICAgKi9cXG4gICAgc3RhdGljIGluaXRpYWxpc2Uob3B0aW9ucykge1xcbiAgICAgICAgaWYgKElucHV0TWFuYWdlci5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIElucHV0TWFuYWdlci5pbnN0YW5jZSA9IG5ldyBJbnB1dE1hbmFnZXIob3B0aW9ucyk7XFxuICAgIH1cXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xcbiAgICAgICAgaWYgKElucHV0TWFuYWdlci5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtYW5hZ2VyIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIElucHV0TWFuYWdlci5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgZGV2aWNlc1xcbiAgICAgKi9cXG4gICAgc3RhdGljIHVwZGF0ZSgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS5wcmV2aW91c0tleWJvYXJkU3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKTtcXG4gICAgICAgIGluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZSA9IHtcXG4gICAgICAgICAgICAuLi5pbnN0YW5jZS5tb3VzZVN0YXRlLFxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMuY3B5KGluc3RhbmNlLm1vdXNlU3RhdGUucG9zaXRpb24pLFxcbiAgICAgICAgfTtcXG4gICAgICAgIGluc3RhbmNlLm1vdXNlU3RhdGUud2hlZWwgPSAwO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBjdXJyZW50bHkgcHJlc3NlZCBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMga2V5RG93bihjb2RlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGtleSBpcyBkb3duXFxuICAgICAgICBpZiAoIWNvZGUpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtrXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICEhaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtjb2RlXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaGFzIGJlZW4gcHJlc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGtleVByZXNzZWQoY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgd2FzIHByZXNzZWRcXG4gICAgICAgIGlmICghY29kZSkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmXFxuICAgICAgICAgICAgICAgICAgICAoIShrIGluIGluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2tdKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICEhaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtjb2RlXSAmJiAhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2NvZGVdO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIGtleSBoYXMgYmVlbiByZWxlYXNlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGtleVJlbGVhc2VkKGNvZGUpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkga2V5IHdhcyByZWxlYXNlZFxcbiAgICAgICAgaWYgKCFjb2RlKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGluc3RhbmNlLmtleWJvYXJkU3RhdGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmXFxuICAgICAgICAgICAgICAgICAgICAhIWluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZVtrXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdICYmICEhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2NvZGVdO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIG1vdXNlIGJ1dHRvbiBpcyBjdXJyZW50bHkgcHJlc3NlZCBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VEb3duKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiAhIWluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIG1vdXNlIGJ1dHRvbiBoYXMgYmVlbiBwcmVzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VQcmVzc2VkKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiAhIWluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uICYmICFpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9uO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIG1vdXNlIGJ1dHRvbiBoYXMgYmVlbiByZWxlYXNlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlUmVsZWFzZWQoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuICFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbiAmJiAhIWluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZS5idXR0b247XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyB1cFxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlV2hlZWxVcCgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UubW91c2VTdGF0ZS53aGVlbCA+IDA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VXaGVlbERvd24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUud2hlZWwgPCAwO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gaW4gc2NyZWVuLXNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IG1vdXNlUG9zaXRpb24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUucG9zaXRpb247XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gSW5wdXRNYW5hZ2VyO1xcbklucHV0TWFuYWdlci5kZWZhdWx0T3B0aW9ucyA9IHtcXG4gICAgbW91c2U6IHRydWUsXFxuICAgIG1vdXNlV2hlZWw6IHRydWUsXFxuICAgIGtleWJvYXJkOiB0cnVlLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlci8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlNjZW5lID0gZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSA9IHZvaWQgMDtcXG52YXIgU2NlbmVUcmFuc2l0aW9uU3RhdGU7XFxuKGZ1bmN0aW9uIChTY2VuZVRyYW5zaXRpb25TdGF0ZSkge1xcbiAgICBTY2VuZVRyYW5zaXRpb25TdGF0ZVtcXFwiSW5cXFwiXSA9IFxcXCJpblxcXCI7XFxuICAgIFNjZW5lVHJhbnNpdGlvblN0YXRlW1xcXCJPdXRcXFwiXSA9IFxcXCJvdXRcXFwiO1xcbiAgICBTY2VuZVRyYW5zaXRpb25TdGF0ZVtcXFwiTm9uZVxcXCJdID0gXFxcIm5vbmVcXFwiO1xcbn0pKFNjZW5lVHJhbnNpdGlvblN0YXRlID0gZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSB8fCAoZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSA9IHt9KSk7XFxuZnVuY3Rpb24gY2xhbXAoYSwgbWluID0gMCwgbWF4ID0gMSkge1xcbiAgICByZXR1cm4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxufVxcbmNsYXNzIFNjZW5lTWFuYWdlciB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgICAgdGhpcy5zY2VuZXMgPSBbXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGlzZSB0aGUgc2NlbmUgbWFuYWdlciBmb3IgbWFuYWdpbmcgZ2FtZSBzY2VuZXNcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKCkge1xcbiAgICAgICAgaWYgKFNjZW5lTWFuYWdlci5pbnN0YW5jZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmVNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFNjZW5lTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBTY2VuZU1hbmFnZXIoKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XFxuICAgICAgICBpZiAoIVNjZW5lTWFuYWdlci5pbnN0YW5jZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmVNYW5hZ2VyIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFNjZW5lTWFuYWdlci5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUHVzaCBhIHNjZW5lIG9udG8gdGhlIHNjZW5lIHN0YWNrIGFuZCBzdGFydCB0cmFuc2l0aW9uaW5nIGluXFxuICAgICAqL1xcbiAgICBzdGF0aWMgcHVzaChzY2VuZSwgLi4uYXJncykge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnNjZW5lcy5wdXNoKHNjZW5lKTtcXG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHNjZW5lIGFuZCBzdGFydCB0aGUgdHJhbnNpdGlvblxcbiAgICAgICAgc2NlbmUuaW5pdGlhbGlzZSguLi5hcmdzKTtcXG4gICAgICAgIHNjZW5lLnRyYW5zaXRpb25JbigpO1xcbiAgICAgICAgcmV0dXJuIHNjZW5lO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgYSBzY2VuZSBmcm9tIHRoZSBzY2VuZSBzdGFjayBhZnRlciB0cmFuc2l0aW9uaW5nIG91dFxcbiAgICAgKi9cXG4gICAgc3RhdGljIHBvcCgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBsZXQgbGFzdCA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGggLSAxO1xcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG9wLW1vc3Qgc2NlbmUgdGhhdCBpc24ndCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgICAgICB3aGlsZSAobGFzdCA+IDAgJiZcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzW2xhc3RdLnRyYW5zaXRpb25TdGF0ZSA9PT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0KSB7XFxuICAgICAgICAgICAgICAgIGxhc3QtLTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGxhc3QgPj0gMCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBzY2VuZSA9IGluc3RhbmNlLnNjZW5lc1tsYXN0XTtcXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvbk91dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NlbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIGFsbCBzY2VuZSBmcm9tIHRoZSBzY2VuZSBzdGFja1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGNsZWFyKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnNjZW5lcy5mb3JFYWNoKHNjZW5lID0+IHtcXG4gICAgICAgICAgICBpZiAoc2NlbmUudHJhbnNpdGlvblN0YXRlICE9PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5PdXQpIHtcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvbk91dCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIHNjZW5lIG1hbmFnZXIgYW5kIHRoZSBjdXJyZW50IHNjZW5lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgdXBkYXRlKGR0LCAuLi5hcmdzKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaWYgKGluc3RhbmNlLnNjZW5lcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHRvcC1tb3N0IHNjZW5lIHRoYXQgaXNuJ3QgY3VycmVudGx5IHRyYW5zaXRpb25pbmcgb3V0XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnNjZW5lc1tpXS50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk91dCkge1xcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzW2ldLnVwZGF0ZShkdCwgLi4uYXJncyk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNjZW5lIHRyYW5zaXRpb25zXFxuICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzLmZvckVhY2goc2NlbmUgPT4ge1xcbiAgICAgICAgICAgICAgICBzY2VuZS51cGRhdGVUcmFuc2l0aW9uKGR0KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IGRpc3Bvc2VkIHNjZW5lc1xcbiAgICAgICAgICAgIGluc3RhbmNlLnNjZW5lcyA9IGluc3RhbmNlLnNjZW5lcy5maWx0ZXIoc2NlbmUgPT4gIXNjZW5lLmRpc3Bvc2VkKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVuZGVyIHNjZW5lcyBvbiB0aGUgc2NyZWVuXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZHJhdyhjb250ZXh0LCAuLi5hcmdzKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBzY2VuZXMgd2UgbmVlZCB0byBkcmF3XFxuICAgICAgICBjb25zdCBkcmF3TGlzdCA9IFtdO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IGluc3RhbmNlLnNjZW5lc1tpXTtcXG4gICAgICAgICAgICBkcmF3TGlzdC5wdXNoKHNjZW5lKTtcXG4gICAgICAgICAgICAvLyBJZiB0cmFuc2l0aW9uaW5nLCB0aGlzIHNjZW5lIGlzIGFzc3VtZWQgdG8gYmUgdHJhbnNwYXJlbnRcXG4gICAgICAgICAgICAvLyAod2UgbWlnaHQgd2FudCB0byBzaG93IHRoZSBzY2VuZSB1bmRlcm5lYXRoIGlmIHdlJ3JlIGRvaW5nIGUuZy4gYSBmYWRlKVxcbiAgICAgICAgICAgIGlmICghc2NlbmUudHJhbnNwYXJlbnQgJiZcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERyYXcgdGhlIHNjZW5lcyBpbiBib3R0b20gLT4gdG9wIG9yZGVyXFxuICAgICAgICBkcmF3TGlzdC5yZXZlcnNlKCkuZm9yRWFjaChzY2VuZSA9PiB7XFxuICAgICAgICAgICAgc2NlbmUuZHJhdyhjb250ZXh0LCAuLi5hcmdzKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBMZXQgYWxsIHNjZW5lcyBrbm93IHRoYXQgYSByZXNpemUgZXZlbnQgaGFzIG9jY3VycmVkXFxuICAgICAqL1xcbiAgICBzdGF0aWMgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIGluc3RhbmNlLnNjZW5lcykge1xcbiAgICAgICAgICAgIChfYSA9IHNjZW5lLnJlc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc2NlbmUsIHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IFNjZW5lTWFuYWdlcjtcXG5jbGFzcyBTY2VuZSB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWU6IDIsXFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUgPSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lO1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uQW1vdW50ID0gMDtcXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWUgPSAwO1xcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xcbiAgICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVGltZSA9IGFjdHVhbE9wdGlvbnMudHJhbnNpdGlvblRpbWU7XFxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gYWN0dWFsT3B0aW9ucy50cmFuc3BhcmVudDtcXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uZWRJbiA9IGFjdHVhbE9wdGlvbnMub25UcmFuc2l0aW9uZWRJbjtcXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uZWRPdXQgPSBhY3R1YWxPcHRpb25zLm9uVHJhbnNpdGlvbmVkT3V0O1xcbiAgICB9XFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICB0cmFuc2l0aW9uSW4oKSB7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLkluO1xcbiAgICB9XFxuICAgIHRyYW5zaXRpb25PdXQoKSB7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLk91dDtcXG4gICAgfVxcbiAgICB1cGRhdGVUcmFuc2l0aW9uKGR0KSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgY29uc3QgYW1vdW50ID0gZHQgLyB0aGlzLnRyYW5zaXRpb25UaW1lO1xcbiAgICAgICAgLy8gVHJhbnNpdGlvbmluZyBpblxcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Jbikge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25BbW91bnQgPCAxKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkFtb3VudCA9IGNsYW1wKHRoaXMudHJhbnNpdGlvbkFtb3VudCArIGFtb3VudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmU7XFxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMub25UcmFuc2l0aW9uZWRJbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gVHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSA9PT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkFtb3VudCA+IDApIHtcXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQW1vdW50ID0gY2xhbXAodGhpcy50cmFuc2l0aW9uQW1vdW50IC0gYW1vdW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlID0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub25UcmFuc2l0aW9uZWRPdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5leHBvcnRzLlNjZW5lID0gU2NlbmU7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlci8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfbW9kdWxlc19fW1wiLi9pbmRleC50c1wiXSgwLCBfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIGxpYnJhcnkgb2YgdXNlZnVsIGZ1bmN0aW9uc1xcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBSb3VuZCBuIHRvIGQgZGVjaW1hbCBwbGFjZXNcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kXFxuICogQHBhcmFtIHtudW1iZXJ9IFtkPTBdIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcm91bmRlZCBudW1iZXJcXG4gKi9cXG5jb25zdCByb3VuZCA9IChuLCBkID0gMCkgPT4ge1xcbiAgY29uc3QgcCA9IE1hdGgucG93KDEwLCBkKTtcXG4gIHJldHVybiBNYXRoLnJvdW5kKG4gKiBwICsgTnVtYmVyLkVQU0lMT04pIC8gcDtcXG59XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBJbnRlcnBvbGF0aW9uRnVuY3Rpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtJbnRlcnBvbGF0aW9uRnVuY3Rpb259IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBucHIgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gZmFjdG9yaWFsKG4gLSByKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuQ3JcXG4gKi9cXG5jb25zdCBuY3IgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFsbCBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCAyXSxcXG4gKiAgIFsxLCAzXSxcXG4gKiAgIFsyLCAzXVxcbiAqIF1cXG4gKiBgYGBcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgY29tYmluYXRpb24gYXJyYXlzXFxuICovXFxuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcXG4gIGlmIChyID09PSAxKSB7XFxuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XFxuICB9XFxuXFxuICByZXR1cm4gYS5yZWR1Y2UoXFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcXG4gICAgICAuLi5hY2MsXFxuICAgICAgLi4uY29tYmluYXRpb25zKGEuc2xpY2UoaSArIDEpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcXG4gICAgXSxcXG4gICAgW11cXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogYGBganNcXG4gKiBjYXJ0ZXNpYW4oWzEsIDIsIDNdLCBbJ2EnLCAnYiddKTtcXG4gKiBgYGBcXG4gKlxcbiAqIE91dHB1dDpcXG4gKiBgYGBqc29uXFxuICogW1xcbiAqICAgWzEsIFxcXCJhXFxcIl0sXFxuICogICBbMSwgXFxcImJcXFwiXSxcXG4gKiAgIFsyLCBcXFwiYVxcXCJdLFxcbiAqICAgWzIsIFxcXCJiXFxcIl0sXFxuICogICBbMywgXFxcImFcXFwiXSxcXG4gKiAgIFszLCBcXFwiYlxcXCJdXFxuICogXVxcbiAqIGBgYFxcbiAqL1xcbmNvbnN0IGNhcnRlc2lhbiA9ICguLi5hcnIpID0+XFxuICBhcnIucmVkdWNlKFxcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcXG4gICAgW1tdXVxcbiAgKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7VGltZXNGdW5jdGlvbn0gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIDIgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xcblxcbi8qKlxcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7Kn0gVGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxcbiAqL1xcbmNvbnN0IHBlZWsgPSAoYSkgPT4ge1xcbiAgaWYgKCFhLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcXG59O1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG4vKipcXG4gKiBGbGF0dGVuIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIHVzZSBmb3IgY29uY2F0ZW5hdGluZyBrZXlzXFxuICogQHJldHVybiB7b2JqZWN0fSBBIGZsYXR0ZW5lZCBvYmplY3RcXG4gKi9cXG5jb25zdCBmbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcXG4gICAgaWYgKG9ba2V5XSBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgLi4uYWNjLFxcbiAgICAgICAgW2tleV06IG9ba2V5XS50b0lTT1N0cmluZygpLFxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8ICFvW2tleV0pIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgLi4uYWNjLFxcbiAgICAgICAgW2tleV06IG9ba2V5XSxcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQob1trZXldLCBjb25jYXRlbmF0b3IpO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIC4uLmFjYyxcXG4gICAgICAuLi5PYmplY3Qua2V5cyhmbGF0dGVuZWQpLnJlZHVjZShcXG4gICAgICAgIChjaGlsZEFjYywgY2hpbGRLZXkpID0+ICh7XFxuICAgICAgICAgIC4uLmNoaWxkQWNjLFxcbiAgICAgICAgICBbYCR7a2V5fSR7Y29uY2F0ZW5hdG9yfSR7Y2hpbGRLZXl9YF06IGZsYXR0ZW5lZFtjaGlsZEtleV0sXFxuICAgICAgICB9KSxcXG4gICAgICAgIHt9XFxuICAgICAgKSxcXG4gICAgfTtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIFVuZmxhdHRlbiBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byBjaGVjayBmb3IgaW4gY29uY2F0ZW5hdGVkIGtleXNcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIHVuLWZsYXR0ZW5lZCBvYmplY3RcXG4gKi9cXG5jb25zdCB1bmZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XFxuICBsZXQgcmVzdWx0ID0ge30sIHRlbXAsIHN1YnN0cmluZ3MsIHByb3BlcnR5LCBpO1xcblxcbiAgZm9yIChwcm9wZXJ0eSBpbiBvKSB7XFxuICAgIHN1YnN0cmluZ3MgPSBwcm9wZXJ0eS5zcGxpdChjb25jYXRlbmF0b3IpO1xcbiAgICB0ZW1wID0gcmVzdWx0O1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgICBpZiAoIShzdWJzdHJpbmdzW2ldIGluIHRlbXApKSB7XFxuICAgICAgICBpZiAoaXNGaW5pdGUoc3Vic3RyaW5nc1tpICsgMV0pKSB7XFxuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSBbXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdGVtcCA9IHRlbXBbc3Vic3RyaW5nc1tpXV07XFxuICAgIH1cXG4gICAgdGVtcFtzdWJzdHJpbmdzW3N1YnN0cmluZ3MubGVuZ3RoIC0gMV1dID0gb1twcm9wZXJ0eV07XFxuICB9XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogQSBzcGxpdCBwcmVkaWNhdGVcXG4gKiBAY2FsbGJhY2sgU3BsaXRQcmVkaWNhdGVcXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcnJheSBzaG91bGQgc3BsaXQgYXQgdGhpcyBpbmRleFxcbiAqL1xcblxcbi8qKlxcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gc3ViLWFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XFxuICogQHBhcmFtIHtTcGxpdFByZWRpY2F0ZX0gcHJlZGljYXRlXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheXNcXG4gKi9cXG5jb25zdCBzcGxpdCA9IChhcnJheSwgcHJlZGljYXRlKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIGxldCBjdXJyZW50ID0gW107XFxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5KSB7XFxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XFxuICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XFxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcXG4gICAgICB9XFxuICAgICAgY3VycmVudCA9IFt2YWx1ZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcbiAgcmVzdWx0LnB1c2goY3VycmVudCk7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUGx1Y2sga2V5cyBmcm9tIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gcGx1Y2sgZnJvbSB0aGUgb2JqZWN0XFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGx1Y2tlZCBrZXlzXFxuICovXFxuY29uc3QgcGx1Y2sgPSAobywgLi4ua2V5cykgPT4ge1xcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxcbiAgICAocmVzdWx0LCBrZXkpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvW2tleV0gfSksXFxuICAgIHt9XFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogRXhjbHVkZSBrZXlzIGZyb20gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBleGNsdWRlIGZyb20gdGhlIG9iamVjdFxcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGtleXMgZXhjZXB0IGV4Y2x1ZGVkIGtleXNcXG4gKi9cXG5jb25zdCBleGNsdWRlID0gKG8sIC4uLmtleXMpID0+IHtcXG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXFxuICAgIE9iamVjdC5lbnRyaWVzKG8pLmZpbHRlcigoW2tleV0pID0+ICFrZXlzLmluY2x1ZGVzKGtleSkpXFxuICApO1xcbn07XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0ge1xcbiAgICBmbG9hdEVxdWFscyxcXG4gICAgY2xhbXAsXFxuICAgIGZyYWMsXFxuICAgIHJvdW5kLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBucHIsXFxuICAgIG5jcixcXG4gICAgY29tYmluYXRpb25zLFxcbiAgICBjYXJ0ZXNpYW4sXFxuICAgIHRpbWVzLFxcbiAgICByYW5nZSxcXG4gICAgemlwLFxcbiAgICBhdCxcXG4gICAgcGVlayxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICAgIGZsYXQsXFxuICAgIHVuZmxhdCxcXG4gICAgc3BsaXQsXFxuICAgIHBsdWNrLFxcbiAgICBleGNsdWRlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zcHJpdGVPcHRpb25zQ29udGVudFByb2Nlc3NvciA9IGV4cG9ydHMuU3ByaXRlID0gZXhwb3J0cy5TcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlID0gdm9pZCAwO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxudmFyIFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGU7XFxuKGZ1bmN0aW9uIChTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlKSB7XFxuICAgIC8qKlxcbiAgICAgKiBMb29wIHRoaXMgYW5pbWF0aW9uIGluZGVmaW5pdGVseVxcbiAgICAgKi9cXG4gICAgU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZVtcXFwiUmVwZWF0XFxcIl0gPSBcXFwicmVwZWF0XFxcIjtcXG4gICAgLyoqXFxuICAgICAqIFBsYXkgb25jZSBhbmQgdGhlbiBzdG9wIG9uIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlW1xcXCJQbGF5T25jZUFuZFN0b3BcXFwiXSA9IFxcXCJwbGF5LW9uY2UtYW5kLXN0b3BcXFwiO1xcbiAgICAvKipcXG4gICAgICogUGxheSBvbmNlIGFuZCB0aGVuIHJlc2V0IGJhY2sgdG8gdGhlIGZpcnN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlW1xcXCJQbGF5T25jZUFuZFJlc2V0XFxcIl0gPSBcXFwicGxheS1vbmNlLWFuZC1yZXNldFxcXCI7XFxufSkoU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZSA9IGV4cG9ydHMuU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZSB8fCAoZXhwb3J0cy5TcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlID0ge30pKTtcXG5jbGFzcyBTcHJpdGUge1xcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKCk7XFxuICAgICAgICB0aGlzLnNpemUgPSAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgdGhpcy5vcmlnaW4gPSAoMCwgdmVjXzEudmVjKSgpO1xcbiAgICAgICAgdGhpcy5zY2FsZSA9IDE7XFxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcXG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMgPSBudWxsO1xcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUgPSBudWxsO1xcbiAgICAgICAgdGhpcy5jdXJyZW50SW1hZ2UgPSBudWxsO1xcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0YWNobWVudFBvaW50cyA9IG51bGw7XFxuICAgICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgU3ByaXRlLkRFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICAgICAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgT2JqZWN0LmtleXMoYWN0dWFsT3B0aW9ucy5hbmltYXRpb25zKSkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlyZWN0aW9uIG9mIE9iamVjdC5rZXlzKGFjdHVhbE9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dKSkge1xcbiAgICAgICAgICAgICAgICBhY3R1YWxPcHRpb25zLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVtkaXJlY3Rpb25dID0gT2JqZWN0LmFzc2lnbih7fSwgU3ByaXRlLkRFRkFVTFRfQU5JTUFUSU9OX09QVElPTlMsIGFjdHVhbE9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dW2RpcmVjdGlvbl0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghYWN0dWFsT3B0aW9ucy5kZWJ1ZyB8fCBhY3R1YWxPcHRpb25zLmRlYnVnID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgYWN0dWFsT3B0aW9ucy5kZWJ1ZyA9IHtcXG4gICAgICAgICAgICAgICAgc2hvd1Nwcml0ZVRyYW5zZm9ybXM6ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICAgICAgc2hvd1Nwcml0ZUJvdW5kaW5nQm94OiAhIWFjdHVhbE9wdGlvbnMuZGVidWcsXFxuICAgICAgICAgICAgICAgIHNob3dBdHRhY2htZW50UG9pbnRzOiAhIWFjdHVhbE9wdGlvbnMuZGVidWcsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFjdHVhbE9wdGlvbnM7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBvc2l0aW9uKSB7XFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHZlY18xLnZlYy5jcHkodGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSkge1xcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHZlY18xLnZlYy5jcHkodGhpcy5vcHRpb25zLnNpemUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0aGUgc2l6ZSBvZiB0aGUgYmFzZSBpbWFnZSBpZiBvbmUgZXhpc3RzXFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAoMCwgdmVjXzEudmVjKSh0aGlzLm9wdGlvbnMuaW1hZ2Uud2lkdGgsIHRoaXMub3B0aW9ucy5pbWFnZS5oZWlnaHQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBzaXplIG9mIHRoZSBpbWFnZSBpbiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGZpcnN0XFxuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBkaXJlY3Rpb24gb2YgdGhlIGRlZmF1bHQgYW5pbWF0aW9uIGlmIG9uZSBleGlzdHNcXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEFuaW1hdGlvbkRpcmVjdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMub3B0aW9ucy5kZWZhdWx0QW5pbWF0aW9uXSlbMF07XFxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0QW5pbWF0aW9uRGlyZWN0aW9ucyAmJlxcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IChfYSA9IGRlZmF1bHRBbmltYXRpb25EaXJlY3Rpb25zLmltYWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAoMCwgdmVjXzEudmVjKShkZWZhdWx0QW5pbWF0aW9uRGlyZWN0aW9ucy5pbWFnZXNbMF0ud2lkdGgsIGRlZmF1bHRBbmltYXRpb25EaXJlY3Rpb25zLmltYWdlc1swXS5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBsZWF2ZSB0aGUgc2l6ZSBhcyAoMCwgMClcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZ2luKSB7XFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSB2ZWNfMS52ZWMuY3B5KHRoaXMub3B0aW9ucy5vcmlnaW4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0aGUgY2VudGVyIG9mIHRoZSBzcHJpdGUgYmFzZWQgb24gc2l6ZVxcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gdmVjXzEudmVjLm11bCh0aGlzLnNpemUsIDAuNSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxlKSB7XFxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRpb24pIHtcXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gdGhpcy5vcHRpb25zLnJvdGF0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gQ2hlY2sgYW5kIGluaXRpYWxpc2UgZGlyZWN0aW9uXFxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVmYXVsdERpcmVjdGlvbjtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9ucy5sZW5ndGggPT09IDAgfHxcXG4gICAgICAgICAgICAhdGhpcy5vcHRpb25zLmRpcmVjdGlvbnMuaW5jbHVkZXModGhpcy5fZGlyZWN0aW9uKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaXJlY3Rpb24gXFxcIiR7dGhpcy5fZGlyZWN0aW9ufVxcXCJgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIENoZWNrIGFuZCBpbml0aWFsaXNlIGFuaW1hdGlvblxcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gdGhpcy5vcHRpb25zLmRlZmF1bHRBbmltYXRpb247XFxuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmFuaW1hdGlvbnMpO1xcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAwIHx8XFxuICAgICAgICAgICAgIWFuaW1hdGlvbnMuaW5jbHVkZXModGhpcy5fYW5pbWF0aW9uKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhbmltYXRpb24gXFxcIiR7dGhpcy5fYW5pbWF0aW9ufVxcXCJgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhdHRhY2htZW50IHBvaW50IGtleWZyYW1lcyBhcmUgZGVmaW5lZCBpbiBhc2NlbmRpbmdcXG4gICAgICAgIC8vIGZyYW1lIG9yZGVyIGluIGFsbCBhbmltYXRpb25zXFxuICAgICAgICBmb3IgKGNvbnN0IGFuaW1hdGlvbiBvZiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9ucykpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dKSkge1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVtkaXJlY3Rpb25dLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRhY2htZW50UG9pbnQgb2YgT2JqZWN0LmtleXModGhpc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vcHRpb25zXFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVtkaXJlY3Rpb25dXFxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vcHRpb25zXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRpb25zW2FuaW1hdGlvbl1bZGlyZWN0aW9uXVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0YWNobWVudFBvaW50S2V5ZnJhbWVzW2F0dGFjaG1lbnRQb2ludF1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZnJhbWUgLSBiLmZyYW1lKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBnZXQgZGlyZWN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcXG4gICAgfVxcbiAgICBzZXQgZGlyZWN0aW9uKHZhbHVlKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpcmVjdGlvbnMuaW5jbHVkZXModmFsdWUpKSB7XFxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZ2V0IGFuaW1hdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb247XFxuICAgIH1cXG4gICAgc2V0IGFuaW1hdGlvbih2YWx1ZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5hbmltYXRpb25zKS5pbmNsdWRlcyh2YWx1ZSkpIHtcXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2FuaW1hdGlvbjtcXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB2YWx1ZTtcXG4gICAgICAgICAgICAvLyBXaGVuIHN3aXRjaGluZyBhbmltYXRpb25zLCB3ZSBtaWdodCBiZSBwYXJ0LXdheSB0aHJvdWdoIGFuZCB0aGVcXG4gICAgICAgICAgICAvLyBuZXcgYW5pbWF0aW9uIG1pZ2h0IGhhdmUgZmV3ZXIgZnJhbWVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBjbGFtcFxcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGZyYW1lIG51bWJlclxcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZUNvdW50ID0gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdmFsdWVdW3RoaXMuZGlyZWN0aW9uXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyYW1lQ291bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XFxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGcmFtZUNvdW50ID0gKF9kID0gKF9jID0gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbcHJldmlvdXNdW3RoaXMuZGlyZWN0aW9uXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZyYW1lQ291bnQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDE7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZUNvdW50IDwgcHJldmlvdXNGcmFtZUNvdW50ICYmXFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlICYmXFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA+PSBjdXJyZW50RnJhbWVDb3VudCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWUgPSBjdXJyZW50RnJhbWVDb3VudCAtIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHBsYXlBbmltYXRpb24oKSB7XFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUpIHtcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5wbGF5aW5nID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBwYXVzZUFuaW1hdGlvbigpIHtcXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLnBsYXlpbmcgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXNldEFuaW1hdGlvbigpIHtcXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA9IDA7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lVGltZSA9IDA7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZ2V0QXR0YWNobWVudFBvaW50KG5hbWUpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50QXR0YWNobWVudFBvaW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW25hbWVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xcbiAgICB9XFxuICAgIHVwZGF0ZShkdCkge1xcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucyA9IHRoaXMudXBkYXRlQW5pbWF0aW9uT3B0aW9ucygpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUgPSB0aGlzLnVwZGF0ZUFuaW1hdGlvblN0YXRlKGR0KTtcXG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlID0gdGhpcy51cGRhdGVJbWFnZSgpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0YWNobWVudFBvaW50cyA9IHRoaXMudXBkYXRlQXR0YWNobWVudFBvaW50cygpO1xcbiAgICB9XFxuICAgIHVwZGF0ZUFuaW1hdGlvbk9wdGlvbnMoKSB7XFxuICAgICAgICBpZiAoISh0aGlzLl9hbmltYXRpb24gaW4gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnMpKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFuaW1hdGlvbiBcXFwiJHt0aGlzLl9hbmltYXRpb259XFxcImApO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgZGlyZWN0aW9ucyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMuX2FuaW1hdGlvbl0pO1xcbiAgICAgICAgaWYgKGRpcmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkaXJlY3Rpb25zIGF2YWlsYWJsZSBmb3IgYW5pbWF0aW9uIFxcXCIke3RoaXMuX2FuaW1hdGlvbn1cXFwiYCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uIGluIHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMuX2FuaW1hdGlvbl0pIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdGhpcy5fYW5pbWF0aW9uXVt0aGlzLl9kaXJlY3Rpb25dO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCcqJyBpbiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1t0aGlzLl9hbmltYXRpb25dKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMuX2FuaW1hdGlvbl1bJyonXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1t0aGlzLl9hbmltYXRpb25dW2RpcmVjdGlvbnNbMF1dO1xcbiAgICB9XFxuICAgIHVwZGF0ZUFuaW1hdGlvblN0YXRlKGR0KSB7XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMgfHxcXG4gICAgICAgICAgICAhdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUpIHtcXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBwbGF5aW5nOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWU6IDAsXFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZVRpbWU6IDAsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5wbGF5aW5nKSB7XFxuICAgICAgICAgICAgY29uc3QgZnJhbWVUaW1lID0gMSAvIHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuZnJhbWVSYXRlO1xcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZVRpbWUgKz0gZHQ7XFxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZVRpbWUgPiBmcmFtZVRpbWUpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuZnJhbWVDb3VudDtcXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lKys7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZVRpbWUgPSAwO1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID49IGZyYW1lQ291bnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5tb2RlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlLlBsYXlPbmNlQW5kUmVzZXQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLnBsYXlpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlLlBsYXlPbmNlQW5kU3RvcDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUucGxheWluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWUgPSBmcmFtZUNvdW50IC0gMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlLlJlcGVhdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGU7XFxuICAgIH1cXG4gICAgdXBkYXRlSW1hZ2UoKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucyB8fFxcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmltYWdlcyB8fFxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuaW1hZ2VzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9wdGlvbnMuaW1hZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKF9jID0gKF9iID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5pbWFnZXNbdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5vcHRpb25zLmltYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsO1xcbiAgICB9XFxuICAgIHVwZGF0ZUF0dGFjaG1lbnRQb2ludHMoKSB7XFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdHRhY2htZW50UG9pbnRzIHx8XFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmF0dGFjaG1lbnRQb2ludHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpIHtcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMub3B0aW9ucy5hdHRhY2htZW50UG9pbnRzLm1hcChhdHRhY2htZW50UG9pbnQgPT4gW1xcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50UG9pbnQubmFtZSxcXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudFBvaW50Lm9mZnNldFxcbiAgICAgICAgICAgIF0pKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zICYmXFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5hdHRhY2htZW50UG9pbnRLZXlmcmFtZXMgJiZcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzKSkge1xcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcyAmJlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5hdHRhY2htZW50UG9pbnRLZXlmcmFtZXNbbmFtZV0ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNLZXlmcmFtZSA9IHRoaXMuZmluZFByZXZpb3VzS2V5ZnJhbWUodGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5hdHRhY2htZW50UG9pbnRLZXlmcmFtZXNbbmFtZV0sIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzW25hbWVdID0gcHJldmlvdXNLZXlmcmFtZS5vZmZzZXQ7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QXR0YWNobWVudFBvaW50cztcXG4gICAgfVxcbiAgICBmaW5kUHJldmlvdXNLZXlmcmFtZShrZXlmcmFtZXMsIGN1cnJlbnRGcmFtZSkge1xcbiAgICAgICAgY29uc3QgZm91bmQgPSBbLi4ua2V5ZnJhbWVzXS5yZXZlcnNlKCkuZmluZChrZXlmcmFtZSA9PiBrZXlmcmFtZS5mcmFtZSA8PSBjdXJyZW50RnJhbWUpO1xcbiAgICAgICAgaWYgKCFmb3VuZCkge1xcbiAgICAgICAgICAgIHJldHVybiBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xcbiAgICB9XFxuICAgIGRyYXcoY29udGV4dCkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUpO1xcbiAgICAgICAgY29udGV4dC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XFxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLnByZVJlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGNvbnRleHQsIHRoaXMpO1xcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEltYWdlKSB7XFxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jdXJyZW50SW1hZ2UsIC10aGlzLm9yaWdpbi54LCAtdGhpcy5vcmlnaW4ueSwgdGhpcy5jdXJyZW50SW1hZ2Uud2lkdGgsIHRoaXMuY3VycmVudEltYWdlLmhlaWdodCk7XFxuICAgICAgICB9XFxuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLm9wdGlvbnMpLnBvc3RSZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBjb250ZXh0LCB0aGlzKTtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd1Nwcml0ZUJvdW5kaW5nQm94KSB7XFxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFNwcml0ZS5ERUJVR19CT1VORElOR19CT1hfQ09MT1VSO1xcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gU3ByaXRlLkRFQlVHX0JPVU5ESU5HX0JPWF9MSU5FX1dJRFRIO1xcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgtdGhpcy5vcmlnaW4ueCwgLXRoaXMub3JpZ2luLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnLnNob3dTcHJpdGVUcmFuc2Zvcm1zKSB7XFxuICAgICAgICAgICAgdGhpcy5kcmF3VHJhbnNmb3Jtc01hcmtlcihjb250ZXh0LCAoMCwgdmVjXzEudmVjKSgpLCBTcHJpdGUuREVCVUdfVFJBTlNGT1JNU19DT0xPVVJfWCwgU3ByaXRlLkRFQlVHX1RSQU5TRk9STVNfQ09MT1VSX1ksIFNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX0xJTkVfV0lEVEgsIFNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX1NJWkUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zy5zaG93QXR0YWNobWVudFBvaW50cyAmJlxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnRQb2ludCBvZiBPYmplY3QudmFsdWVzKHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Nyb3NzKGNvbnRleHQsIGF0dGFjaG1lbnRQb2ludCwgU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfQ09MT1VSLCBTcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9MSU5FX1dJRFRILCBTcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9TSVpFKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3VHJhbnNmb3Jtc01hcmtlcihjb250ZXh0LCBwb3NpdGlvbiwgeENvbG91ciwgeUNvbG91ciwgbGluZVdpZHRoLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHhDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54ICsgc2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHlDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55ICsgc2l6ZSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd0Nyb3NzKGNvbnRleHQsIHBvc2l0aW9uLCBjb2xvdXIsIGxpbmVXaWR0aCwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gTWF0aC5jZWlsKHNpemUgLyAyKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxufVxcbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xcblNwcml0ZS5ERUZBVUxUX09QVElPTlMgPSB7XFxuICAgIGRpcmVjdGlvbnM6IFsnZGVmYXVsdCddLFxcbiAgICBkZWZhdWx0RGlyZWN0aW9uOiAnZGVmYXVsdCcsXFxuICAgIGFuaW1hdGlvbnM6IHtcXG4gICAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgICAgICAnKic6IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICAgICAgICAgICAgICBmcmFtZUNvdW50OiAxLFxcbiAgICAgICAgICAgICAgICBmcmFtZVJhdGU6IDEsXFxuICAgICAgICAgICAgICAgIG1vZGU6IFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUuUGxheU9uY2VBbmRTdG9wLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICB9LFxcbiAgICB9LFxcbiAgICBkZWZhdWx0QW5pbWF0aW9uOiAnZGVmYXVsdCcsXFxufTtcXG5TcHJpdGUuREVGQVVMVF9BTklNQVRJT05fT1BUSU9OUyA9IHtcXG4gICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICBmcmFtZUNvdW50OiAxLFxcbiAgICBmcmFtZVJhdGU6IDEsXFxuICAgIG1vZGU6IFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUuUmVwZWF0LFxcbn07XFxuU3ByaXRlLkRFQlVHX0JPVU5ESU5HX0JPWF9DT0xPVVIgPSAnZ3JlZW4nO1xcblNwcml0ZS5ERUJVR19CT1VORElOR19CT1hfTElORV9XSURUSCA9IDI7XFxuU3ByaXRlLkRFQlVHX1RSQU5TRk9STVNfQ09MT1VSX1ggPSAncmVkJztcXG5TcHJpdGUuREVCVUdfVFJBTlNGT1JNU19DT0xPVVJfWSA9ICdvcmFuZ2UnO1xcblNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX0xJTkVfV0lEVEggPSAxO1xcblNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX1NJWkUgPSAxMDtcXG5TcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9DT0xPVVIgPSAnYmx1ZSc7XFxuU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfTElORV9XSURUSCA9IDI7XFxuU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfU0laRSA9IDU7XFxuLyoqXFxuICogQ29udGVudCBNYW5hZ2VyIFByb2Nlc3NvciB3cmFwcGVyIHdoaWNoIGNvbnZlcnRzIFNwcml0ZU9wdGlvbnNEYXRhIGludG9cXG4gKiBTcHJpdGVPcHRpb25zXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlclxcbiAqL1xcbmFzeW5jIGZ1bmN0aW9uIHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yKGNvbnRlbnQsIGRhdGEpIHtcXG4gICAgY29uc3QgZ2V0SW1hZ2VGcm9tQ29udGVudCA9IChuYW1lKSA9PiB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBjb25zdCBpbWFnZSA9IChfYSA9IGNvbnRlbnRbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xcbiAgICAgICAgaWYgKCFpbWFnZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGltYWdlO1xcbiAgICB9O1xcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmNvbnRlbnQ7XFxuICAgIGlmIChyZXN1bHQuaW1hZ2VOYW1lKSB7XFxuICAgICAgICByZXN1bHQuaW1hZ2UgPSBnZXRJbWFnZUZyb21Db250ZW50KHJlc3VsdC5pbWFnZU5hbWUpO1xcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5pbWFnZU5hbWU7XFxuICAgIH1cXG4gICAgaWYgKHJlc3VsdC5hbmltYXRpb25zKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IFthbmltYXRpb25OYW1lLCBhbmltYXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC5hbmltYXRpb25zKSkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2RpcmVjdGlvbk5hbWUsIGRpcmVjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoYW5pbWF0aW9uKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmltYWdlTmFtZXMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdW2RpcmVjdGlvbk5hbWVdLmltYWdlcyA9IGRpcmVjdGlvblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbWFnZU5hbWVzXFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChnZXRJbWFnZUZyb21Db250ZW50KTtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXVtkaXJlY3Rpb25OYW1lXS5pbWFnZU5hbWVzO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGRhdGEuY29udGVudCA9IHJlc3VsdDtcXG59XFxuZXhwb3J0cy5zcHJpdGVPcHRpb25zQ29udGVudFByb2Nlc3NvciA9IHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3Nwcml0ZS8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IgPSBleHBvcnRzLnRleHR1cmVBdGxhcyA9IHZvaWQgMDtcXG5jb25zdCBERUZBVUxUX1JFUEVBVElOR19SRUdJT05fTkFNRV9GT1JNQVQgPSAne25hbWV9LXtufSc7XFxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xcbiAgICByZWxhdGl2ZTogdHJ1ZSxcXG4gICAgd2lkdGg6IDEsXFxuICAgIGhlaWdodDogMSxcXG4gICAgcmVnaW9uczoge1xcbiAgICAgICAgZGVmYXVsdDoge1xcbiAgICAgICAgICAgIHg6IDAsXFxuICAgICAgICAgICAgeTogMCxcXG4gICAgICAgIH0sXFxuICAgIH0sXFxuICAgIGNlbGxNYXJnaW46IDAsXFxufTtcXG4vKipcXG4gKiBUYWtlcyBhbiBpbWFnZSBhbmQgc29tZSB0ZXh0dXJlIGF0bGFzIG9wdGlvbnMgYW5kIHJldHVybnMgYSBkaWN0aW9uYXJ5XFxuICogb2YgY2FudmFzZXMgaW5kZXhlZCBieSByZWdpb24gbmFtZVxcbiAqL1xcbmZ1bmN0aW9uIHRleHR1cmVBdGxhcyhpbWFnZSwgb3B0aW9ucykge1xcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XFxuICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgaWYgKGFjdHVhbE9wdGlvbnMud2lkdGggPD0gMCB8fCBhY3R1YWxPcHRpb25zLmhlaWdodCA8PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xcbiAgICB9XFxuICAgIGlmIChPYmplY3Qua2V5cyhhY3R1YWxPcHRpb25zLnJlZ2lvbnMpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWdpb25zIGRlZmluZWQnKTtcXG4gICAgfVxcbiAgICBsZXQgY2VsbFdpZHRoID0gMTtcXG4gICAgbGV0IGNlbGxIZWlnaHQgPSAxO1xcbiAgICBpZiAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZSkge1xcbiAgICAgICAgbGV0IGltYWdlV2lkdGggPSBpbWFnZS53aWR0aDtcXG4gICAgICAgIGxldCBpbWFnZUhlaWdodCA9IGltYWdlLmhlaWdodDtcXG4gICAgICAgIGlmIChhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW4gPiAwKSB7XFxuICAgICAgICAgICAgaW1hZ2VXaWR0aCAtPSBhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW47XFxuICAgICAgICAgICAgaW1hZ2VIZWlnaHQgLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5jZWlsKGltYWdlV2lkdGggLyBhY3R1YWxPcHRpb25zLndpZHRoKTtcXG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLmNlaWwoaW1hZ2VIZWlnaHQgLyBhY3R1YWxPcHRpb25zLmhlaWdodCk7XFxuICAgIH1cXG4gICAgY29uc3QgbWFwID0ge307XFxuICAgIGZvciAoY29uc3QgW25hbWUsIHJlZ2lvbl0gb2YgT2JqZWN0LmVudHJpZXMoYWN0dWFsT3B0aW9ucy5yZWdpb25zKSkge1xcbiAgICAgICAgbGV0IGFic29sdXRlWCA9IE1hdGguZmxvb3IocmVnaW9uLnggKiBjZWxsV2lkdGgpO1xcbiAgICAgICAgbGV0IGFic29sdXRlWSA9IE1hdGguZmxvb3IocmVnaW9uLnkgKiBjZWxsSGVpZ2h0KTtcXG4gICAgICAgIGxldCBhYnNvbHV0ZVdpZHRoID0gTWF0aC5jZWlsKHJlZ2lvbi53aWR0aFxcbiAgICAgICAgICAgID8gKGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgPyByZWdpb24ud2lkdGggKiBjZWxsV2lkdGhcXG4gICAgICAgICAgICAgICAgOiByZWdpb24ud2lkdGgpXFxuICAgICAgICAgICAgOiAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcbiAgICAgICAgICAgICAgICA/IGNlbGxXaWR0aFxcbiAgICAgICAgICAgICAgICA6IGltYWdlLndpZHRoIC0gYWJzb2x1dGVYKSk7XFxuICAgICAgICBsZXQgYWJzb2x1dGVIZWlnaHQgPSBNYXRoLmNlaWwocmVnaW9uLmhlaWdodFxcbiAgICAgICAgICAgID8gKGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgPyByZWdpb24uaGVpZ2h0ICogY2VsbEhlaWdodFxcbiAgICAgICAgICAgICAgICA6IHJlZ2lvbi5oZWlnaHQpXFxuICAgICAgICAgICAgOiAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcbiAgICAgICAgICAgICAgICA/IGNlbGxIZWlnaHRcXG4gICAgICAgICAgICAgICAgOiBpbWFnZS5oZWlnaHQgLSBhYnNvbHV0ZVkpKTtcXG4gICAgICAgIGlmIChhY3R1YWxPcHRpb25zLnJlbGF0aXZlICYmIGFjdHVhbE9wdGlvbnMuY2VsbE1hcmdpbiA+IDApIHtcXG4gICAgICAgICAgICBhYnNvbHV0ZVggKz0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcbiAgICAgICAgICAgIGFic29sdXRlWSArPSBhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW47XFxuICAgICAgICAgICAgYWJzb2x1dGVXaWR0aCAtPSBhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW47XFxuICAgICAgICAgICAgYWJzb2x1dGVIZWlnaHQgLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlZ2lvbi5yZXBlYXQgJiYgcmVnaW9uLnJlcGVhdCA+IDApIHtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbi5yZXBlYXQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICBjb25zdCByZXBlYXROYW1lID0gZ2V0UmVwZWF0aW5nUmVnaW9uTmFtZShuYW1lLCBpICsgMSwgcmVnaW9uLnJlcGVhdE5hbWVGb3JtYXQpO1xcbiAgICAgICAgICAgICAgICBsZXQgcmVwZWF0T2Zmc2V0WCA9IE1hdGguZmxvb3IoKCgoX2EgPSByZWdpb24ucmVwZWF0T2Zmc2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IHVuZGVmaW5lZCAmJlxcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IHJlZ2lvbi5yZXBlYXRPZmZzZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi54KSAhPT0gbnVsbClcXG4gICAgICAgICAgICAgICAgICAgID8gKGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZ2lvbi5yZXBlYXRPZmZzZXQueCAqIGNlbGxXaWR0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVnaW9uLnJlcGVhdE9mZnNldC54KVxcbiAgICAgICAgICAgICAgICAgICAgOiBjZWxsV2lkdGgpO1xcbiAgICAgICAgICAgICAgICBsZXQgcmVwZWF0T2Zmc2V0WSA9IE1hdGguZmxvb3IoKCgoX2MgPSByZWdpb24ucmVwZWF0T2Zmc2V0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSkgIT09IHVuZGVmaW5lZCAmJlxcbiAgICAgICAgICAgICAgICAgICAgKChfZCA9IHJlZ2lvbi5yZXBlYXRPZmZzZXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC55KSAhPT0gbnVsbClcXG4gICAgICAgICAgICAgICAgICAgID8gKGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZ2lvbi5yZXBlYXRPZmZzZXQueSAqIGNlbGxIZWlnaHRcXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZ2lvbi5yZXBlYXRPZmZzZXQueSlcXG4gICAgICAgICAgICAgICAgICAgIDogMCk7XFxuICAgICAgICAgICAgICAgIG1hcFtyZXBlYXROYW1lXSA9IGNob3BSZWdpb24oaW1hZ2UsIGFic29sdXRlWCArIHJlcGVhdE9mZnNldFggKiBpLCBhYnNvbHV0ZVkgKyByZXBlYXRPZmZzZXRZICogaSwgYWJzb2x1dGVXaWR0aCwgYWJzb2x1dGVIZWlnaHQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIG1hcFtuYW1lXSA9IGNob3BSZWdpb24oaW1hZ2UsIGFic29sdXRlWCwgYWJzb2x1dGVZLCBhYnNvbHV0ZVdpZHRoLCBhYnNvbHV0ZUhlaWdodCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG1hcDtcXG59XFxuZXhwb3J0cy50ZXh0dXJlQXRsYXMgPSB0ZXh0dXJlQXRsYXM7XFxuLyoqXFxuICogQ2hvcCBhIHJlY3Rhbmd1bGFyIHJlZ2lvbiBmcm9tIGFuIGltYWdlIGludG8gYSBuZXcgY2FudmFzXFxuICovXFxuZnVuY3Rpb24gY2hvcFJlZ2lvbihpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcXG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcXG4gICAgaWYgKCFjb250ZXh0KSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgMkQgY29udGV4dCcpO1xcbiAgICB9XFxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcXG4gICAgcmV0dXJuIGNhbnZhcztcXG59XFxuLyoqXFxuICogR2V0IHRoZSBuYW1lIG9mIGEgcmVwZWF0aW5nIHJlZ2lvblxcbiAqL1xcbmZ1bmN0aW9uIGdldFJlcGVhdGluZ1JlZ2lvbk5hbWUocmVnaW9uTmFtZSwgcmVwZXRpdGlvbkluZGV4LCByZWdpb25OYW1lRm9ybWF0KSB7XFxuICAgIHJldHVybiAocmVnaW9uTmFtZUZvcm1hdCAhPT0gbnVsbCAmJiByZWdpb25OYW1lRm9ybWF0ICE9PSB2b2lkIDAgPyByZWdpb25OYW1lRm9ybWF0IDogREVGQVVMVF9SRVBFQVRJTkdfUkVHSU9OX05BTUVfRk9STUFUKVxcbiAgICAgICAgLnJlcGxhY2UoJ3tuYW1lfScsIHJlZ2lvbk5hbWUpXFxuICAgICAgICAucmVwbGFjZSgne259JywgcmVwZXRpdGlvbkluZGV4LnRvU3RyaW5nKCkpO1xcbn1cXG4vKipcXG4gKiBDb250ZW50IE1hbmFnZXIgUHJvY2Vzc29yIHdyYXBwZXIgd2hpY2ggYWxsb3dzIHRoZSB0ZXh0dXJlQXRsYXMgZnVuY3Rpb25cXG4gKiB0byBiZSB1c2VkIGFzIGEgcHJvY2Vzc29yIGluIGEgQ29udGVudCBNYW5hZ2VyXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlclxcbiAqL1xcbmFzeW5jIGZ1bmN0aW9uIHRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IoY29udGVudCwgZGF0YSwgaW1hZ2VOYW1lKSB7XFxuICAgIHZhciBfYTtcXG4gICAgY29uc3QgaW1hZ2UgPSAoX2EgPSBjb250ZW50W2ltYWdlTmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xcbiAgICBpZiAoIWltYWdlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlICcke2ltYWdlTmFtZX0nIG5vdCBmb3VuZGApO1xcbiAgICB9XFxuICAgIGNvbnN0IG1hcCA9IHRleHR1cmVBdGxhcyhpbWFnZSwgZGF0YS5jb250ZW50KTtcXG4gICAgZm9yIChjb25zdCBbbmFtZSwgY2FudmFzXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XFxuICAgICAgICBjb250ZW50W25hbWVdID0ge1xcbiAgICAgICAgICAgIG5hbWUsXFxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcXG4gICAgICAgICAgICBjb250ZW50OiBjYW52YXMsXFxuICAgICAgICAgICAgc3RhdHVzOiA0LFxcbiAgICAgICAgfTtcXG4gICAgfVxcbn1cXG5leHBvcnRzLnRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IgPSB0ZXh0dXJlQXRsYXNDb250ZW50UHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RleHR1cmUtYXRsYXMvLi9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1tcIi4vaW5kZXgudHNcIl0oMCwgX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICovXFxuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xcblxcbi8qKlxcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcXG4gKi9cXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XFxuXFxuLyoqXFxuICogUm91bmQgbiB0byBkIGRlY2ltYWwgcGxhY2VzXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZD0wXSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJvdW5kZWQgbnVtYmVyXFxuICovXFxuY29uc3Qgcm91bmQgPSAobiwgZCA9IDApID0+IHtcXG4gIGNvbnN0IHAgPSBNYXRoLnBvdygxMCwgZCk7XFxuICByZXR1cm4gTWF0aC5yb3VuZChuICogcCArIE51bWJlci5FUFNJTE9OKSAvIHA7XFxufVxcblxcbi8qKlxcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWUsIHNob3VsZCBiZSBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IGxlcnAgPSAoYSwgYiwgaSkgPT4gYSArIChiIC0gYSkgKiBpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqL1xcbmNvbnN0IHVubGVycCA9IChhLCBiLCBpKSA9PiAoaSAtIGEpIC8gKGIgLSBhKTtcXG5cXG4vKipcXG4gKiBEbyBhIGJpbGluZWFyIGludGVycG9sYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gYzAwIFRvcC1sZWZ0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMxMCBUb3AtcmlnaHQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzAxIEJvdHRvbS1sZWZ0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMxMSBCb3R0b20tcmlnaHQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaXggSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB4XFxuICogQHBhcmFtIHtudW1iZXJ9IGl5IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBiaWxpbmVhciBpbnRlcnBvbGF0ZWQgdmFsdWVcXG4gKi9cXG5jb25zdCBibGVycCA9IChjMDAsIGMxMCwgYzAxLCBjMTEsIGl4LCBpeSkgPT4gbGVycChsZXJwKGMwMCwgYzEwLCBpeCksIGxlcnAoYzAxLCBjMTEsIGl4KSwgaXkpO1xcblxcbi8qKlxcbiAqIFJlLW1hcCBhIG51bWJlciBpIGZyb20gcmFuZ2UgYTEuLi5hMiB0byBiMS4uLmIyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIG51bWJlciB0byByZS1tYXBcXG4gKiBAcGFyYW0ge251bWJlcn0gYTFcXG4gKiBAcGFyYW0ge251bWJlcn0gYTJcXG4gKiBAcGFyYW0ge251bWJlcn0gYjFcXG4gKiBAcGFyYW0ge251bWJlcn0gYjJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuY29uc3QgcmVtYXAgPSAoaSwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKGkgLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSk7XFxuXFxuLyoqXFxuICogRG8gYSBzbW9vdGggaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBzbW9vdGhzdGVwID0gKGEsIGIsIGkpID0+IGxlcnAoYSwgYiwgMyAqIE1hdGgucG93KGksIDIpIC0gMiAqIE1hdGgucG93KGksIDMpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gcmFkaWFuc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xcbiAqL1xcbmNvbnN0IHJhZGlhbnMgPSBkZWdyZWVzID0+IChNYXRoLlBJIC8gMTgwKSAqIGRlZ3JlZXM7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBUaGUgYW5nbGUgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKi9cXG5jb25zdCBkZWdyZWVzID0gcmFkaWFucyA9PiAoMTgwIC8gTWF0aC5QSSkgKiByYWRpYW5zO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggRXhjbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKi9cXG5jb25zdCByYW5kb21CZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKi9cXG5jb25zdCByYW5kb21JbnRCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gW211PTAuNV0gVGhlIG1lYW4gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpZ21hPTAuNV0gVGhlIHN0YW5kYXJkIGRldmlhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlcz0yXSBUaGUgbnVtYmVyIG9mIHNhbXBsZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbSA9IChtdSA9IDAuNSwgc2lnbWEgPSAwLjUsIHNhbXBsZXMgPSAyKSA9PiB7XFxuICBsZXQgdG90YWwgPSAwO1xcbiAgZm9yIChsZXQgaSA9IHNhbXBsZXM7IGktLTspIHtcXG4gICAgdG90YWwgKz0gTWF0aC5yYW5kb20oKTtcXG4gIH1cXG4gIHJldHVybiBtdSArICh0b3RhbCAtIHNhbXBsZXMgLyAyKSAvIChzYW1wbGVzIC8gMikgKiBzaWdtYTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tSW50ID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKG1pbiArIGNsdFJhbmRvbSgwLjUsIDAuNSwgMikgKiAobWF4ICsgMSAtIG1pbikpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHdlaWdodGVkIHJhbmRvbSBpbnRlZ2VyXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB3IEFuIGFycmF5IG9mIHdlaWdodHNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGluZGV4IGZyb20gd1xcbiAqL1xcbmNvbnN0IHdlaWdodGVkUmFuZG9tID0gdyA9PiB7XFxuICBsZXQgdG90YWwgPSB3LnJlZHVjZSgoYSwgaSkgPT4gYSArIGksIDApLCBuID0gMDtcXG4gIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogdG90YWw7XFxuICB3aGlsZSAodG90YWwgPiByKSB7XFxuICAgIHRvdGFsIC09IHdbbisrXTtcXG4gIH1cXG4gIHJldHVybiBuIC0gMTtcXG59O1xcblxcbi8qKlxcbiAqIEFuIGludGVycG9sYXRpb24gZnVuY3Rpb25cXG4gKiBAY2FsbGJhY2sgSW50ZXJwb2xhdGlvbkZ1bmN0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWUsIHNob3VsZCBiZSBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gaW50ZXJwb2xhdGVkIHZhbHVlIGZyb20gYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgQW4gYXJyYXkgb2YgdmFsdWVzIGludGVycG9sYXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgQSBudW1iZXIgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEBwYXJhbSB7SW50ZXJwb2xhdGlvbkZ1bmN0aW9ufSBbZj1NYXRoLmxlcnBdIFRoZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRvIHVzZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbbWluKGEpLCBtYXgoYSldXFxuICovXFxuY29uc3QgbGVycEFycmF5ID0gKGEsIGksIGYgPSBsZXJwKSA9PiB7XFxuICBjb25zdCBzID0gaSAqIChhLmxlbmd0aCAtIDEpO1xcbiAgY29uc3QgcCA9IGNsYW1wKE1hdGgudHJ1bmMocyksIDAsIGEubGVuZ3RoIC0gMSk7XFxuICByZXR1cm4gZihhW3BdIHx8IDAsIGFbcCArIDFdIHx8IDAsIGZyYWMocykpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbmNvbnN0IGRvdCA9IChhLCBiKSA9PiBhLnJlZHVjZSgobiwgdiwgaSkgPT4gbiArIHYgKiBiW2ldLCAwKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGZhY3RvcmlhbCBvZiBhIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXFxuICogQHJldHVybiB7bnVtYmVyfSBhIVxcbiAqL1xcbmNvbnN0IGZhY3RvcmlhbCA9IGEgPT4ge1xcbiAgbGV0IHJlc3VsdCA9IDE7XFxuICBmb3IgKGxldCBpID0gMjsgaSA8PSBhOyBpKyspIHtcXG4gICAgcmVzdWx0ICo9IGk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gblByXFxuICovXFxuY29uc3QgbnByID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIGZhY3RvcmlhbChuIC0gcik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcGFyYW0ge251bWJlcn0gclxcbiAqIEByZXR1cm4ge251bWJlcn0gbkNyXFxuICovXFxuY29uc3QgbmNyID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbGwgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiBgYGBqc1xcbiAqIGNvbWJpbmF0aW9ucyhbMSwgMiwgM10sIDIpO1xcbiAqIGBgYFxcbiAqXFxuICogT3V0cHV0OlxcbiAqIGBgYGpzb25cXG4gKiBbXFxuICogICBbMSwgMl0sXFxuICogICBbMSwgM10sXFxuICogICBbMiwgM11cXG4gKiBdXFxuICogYGBgXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY2hvb3NlIGluIGVhY2ggY29tYmluYXRpb25cXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGNvbWJpbmF0aW9uIGFycmF5c1xcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9ucyA9IChhLCByKSA9PiB7XFxuICBpZiAociA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGEucmVkdWNlKFxcbiAgICAoYWNjLCBpdGVtLCBpKSA9PiBbXFxuICAgICAgLi4uYWNjLFxcbiAgICAgIC4uLmNvbWJpbmF0aW9ucyhhLnNsaWNlKGkgKyAxKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXFxuICAgIF0sXFxuICAgIFtdXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY2FydGVzaWFuIHByb2R1Y3Qgb2YgYXJyYXlzXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogY2FydGVzaWFuKFsxLCAyLCAzXSwgWydhJywgJ2InXSk7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCBcXFwiYVxcXCJdLFxcbiAqICAgWzEsIFxcXCJiXFxcIl0sXFxuICogICBbMiwgXFxcImFcXFwiXSxcXG4gKiAgIFsyLCBcXFwiYlxcXCJdLFxcbiAqICAgWzMsIFxcXCJhXFxcIl0sXFxuICogICBbMywgXFxcImJcXFwiXVxcbiAqIF1cXG4gKiBgYGBcXG4gKi9cXG5jb25zdCBjYXJ0ZXNpYW4gPSAoLi4uYXJyKSA9PlxcbiAgYXJyLnJlZHVjZShcXG4gICAgKGEsIGIpID0+IGEuZmxhdE1hcChjID0+IGIubWFwKGQgPT4gWy4uLmMsIGRdKSksXFxuICAgIFtbXV1cXG4gICk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhcnJheSB2YWx1ZXNcXG4gKiBAY2FsbGJhY2sgVGltZXNGdW5jdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IFRoZSBhcnJheSB2YWx1ZVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIGxlbmd0aCBuIGJ5IGNhbGxpbmcgZnVuY3Rpb24gZihpKSBvbiBlYWNoIGVsZW1lbnRcXG4gKiBAcGFyYW0ge1RpbWVzRnVuY3Rpb259IGZcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTwqPn1cXG4gKi9cXG5jb25zdCB0aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyAwLT4obiAtIDEpXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgb2YgaW50ZWdlcnMgMC0+KG4gLSAxKVxcbiAqL1xcbmNvbnN0IHJhbmdlID0gbiA9PiB0aW1lcyhpID0+IGksIG4pO1xcblxcbi8qKlxcbiAqIFppcCAyIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBiXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fVxcbiAqL1xcbmNvbnN0IHppcCA9IChhLCBiKSA9PiBhLm1hcCgoaywgaSkgPT4gW2ssIGJbaV1dKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYXJyYXlbaV0gd2l0aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgd3JhcHBpbmdcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHBvc2l0aXZlbHkvbmVnYXRpdmVseSB3cmFwcGVkIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gQW4gZWxlbWVudCBmcm9tIHRoZSBhcnJheVxcbiAqL1xcbmNvbnN0IGF0ID0gKGEsIGkpID0+IGFbaSA8IDAgPyBhLmxlbmd0aCAtIChNYXRoLmFicyhpICsgMSkgJSBhLmxlbmd0aCkgLSAxIDogaSAlIGEubGVuZ3RoXTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSB3aXRob3V0IHJlbW92aW5nIGl0XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4geyp9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBwZWVrID0gKGEpID0+IHtcXG4gIGlmICghYS5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIH1cXG5cXG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XFxufTtcXG5cXG4vKipcXG4gKiBDaG9wIGFuIGFycmF5IGludG8gY2h1bmtzIG9mIHNpemUgblxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY2h1bmsgc2l6ZVxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgYXJyYXkgY2h1bmtzXFxuICovXFxuY29uc3QgY2h1bmsgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XFxuXFxuLyoqXFxuICogUmFuZG9tbHkgc2h1ZmZsZSBhIHNoYWxsb3cgY29weSBvZiBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gVGhlIHNodWZmbGVkIGFycmF5XFxuICovXFxuY29uc3Qgc2h1ZmZsZSA9IGEgPT4gYS5zbGljZSgpLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XFxuXFxuLyoqXFxuICogRmxhdHRlbiBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byB1c2UgZm9yIGNvbmNhdGVuYXRpbmcga2V5c1xcbiAqIEByZXR1cm4ge29iamVjdH0gQSBmbGF0dGVuZWQgb2JqZWN0XFxuICovXFxuY29uc3QgZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcXG4gIHJldHVybiBPYmplY3Qua2V5cyhvKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XFxuICAgIGlmIChvW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIC4uLmFjYyxcXG4gICAgICAgIFtrZXldOiBvW2tleV0udG9JU09TdHJpbmcoKSxcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb1trZXldICE9PSAnb2JqZWN0JyB8fCAhb1trZXldKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIC4uLmFjYyxcXG4gICAgICAgIFtrZXldOiBvW2tleV0sXFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBmbGF0KG9ba2V5XSwgY29uY2F0ZW5hdG9yKTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAuLi5hY2MsXFxuICAgICAgLi4uT2JqZWN0LmtleXMoZmxhdHRlbmVkKS5yZWR1Y2UoXFxuICAgICAgICAoY2hpbGRBY2MsIGNoaWxkS2V5KSA9PiAoe1xcbiAgICAgICAgICAuLi5jaGlsZEFjYyxcXG4gICAgICAgICAgW2Ake2tleX0ke2NvbmNhdGVuYXRvcn0ke2NoaWxkS2V5fWBdOiBmbGF0dGVuZWRbY2hpbGRLZXldLFxcbiAgICAgICAgfSksXFxuICAgICAgICB7fVxcbiAgICAgICksXFxuICAgIH07XFxuICB9LCB7fSk7XFxufTtcXG5cXG4vKipcXG4gKiBVbmZsYXR0ZW4gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIGluIGNvbmNhdGVuYXRlZCBrZXlzXFxuICogQHJldHVybiB7b2JqZWN0fSBBbiB1bi1mbGF0dGVuZWQgb2JqZWN0XFxuICovXFxuY29uc3QgdW5mbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xcbiAgbGV0IHJlc3VsdCA9IHt9LCB0ZW1wLCBzdWJzdHJpbmdzLCBwcm9wZXJ0eSwgaTtcXG5cXG4gIGZvciAocHJvcGVydHkgaW4gbykge1xcbiAgICBzdWJzdHJpbmdzID0gcHJvcGVydHkuc3BsaXQoY29uY2F0ZW5hdG9yKTtcXG4gICAgdGVtcCA9IHJlc3VsdDtcXG4gICAgZm9yIChpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgaWYgKCEoc3Vic3RyaW5nc1tpXSBpbiB0ZW1wKSkge1xcbiAgICAgICAgaWYgKGlzRmluaXRlKHN1YnN0cmluZ3NbaSArIDFdKSkge1xcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0gW107XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0ge307XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHRlbXAgPSB0ZW1wW3N1YnN0cmluZ3NbaV1dO1xcbiAgICB9XFxuICAgIHRlbXBbc3Vic3RyaW5nc1tzdWJzdHJpbmdzLmxlbmd0aCAtIDFdXSA9IG9bcHJvcGVydHldO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEEgc3BsaXQgcHJlZGljYXRlXFxuICogQGNhbGxiYWNrIFNwbGl0UHJlZGljYXRlXFxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJyYXkgc2hvdWxkIHNwbGl0IGF0IHRoaXMgaW5kZXhcXG4gKi9cXG5cXG4vKipcXG4gKiBTcGxpdCBhbiBhcnJheSBpbnRvIHN1Yi1hcnJheXMgYmFzZWQgb24gYSBwcmVkaWNhdGVcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxcbiAqIEBwYXJhbSB7U3BsaXRQcmVkaWNhdGV9IHByZWRpY2F0ZVxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgYXJyYXlzXFxuICovXFxuY29uc3Qgc3BsaXQgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBsZXQgY3VycmVudCA9IFtdO1xcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCkge1xcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XFxuICAgICAgfVxcbiAgICAgIGN1cnJlbnQgPSBbdmFsdWVdO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG4gIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFBsdWNrIGtleXMgZnJvbSBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIHBsdWNrIGZyb20gdGhlIG9iamVjdFxcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBsdWNrZWQga2V5c1xcbiAqL1xcbmNvbnN0IHBsdWNrID0gKG8sIC4uLmtleXMpID0+IHtcXG4gIHJldHVybiBrZXlzLnJlZHVjZShcXG4gICAgKHJlc3VsdCwga2V5KSA9PiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBba2V5XTogb1trZXldIH0pLFxcbiAgICB7fVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIEV4Y2x1ZGUga2V5cyBmcm9tIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBvYmplY3RcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBrZXlzIGV4Y2VwdCBleGNsdWRlZCBrZXlzXFxuICovXFxuY29uc3QgZXhjbHVkZSA9IChvLCAuLi5rZXlzKSA9PiB7XFxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxcbiAgICBPYmplY3QuZW50cmllcyhvKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKVxcbiAgKTtcXG59O1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgZmxvYXRFcXVhbHMsXFxuICAgIGNsYW1wLFxcbiAgICBmcmFjLFxcbiAgICByb3VuZCxcXG4gICAgbGVycCxcXG4gICAgdW5sZXJwLFxcbiAgICBibGVycCxcXG4gICAgcmVtYXAsXFxuICAgIHNtb290aHN0ZXAsXFxuICAgIHJhZGlhbnMsXFxuICAgIGRlZ3JlZXMsXFxuICAgIHJhbmRvbUJldHdlZW4sXFxuICAgIHJhbmRvbUludEJldHdlZW4sXFxuICAgIGNsdFJhbmRvbSxcXG4gICAgY2x0UmFuZG9tSW50LFxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcXG4gICAgbGVycEFycmF5LFxcbiAgICBkb3QsXFxuICAgIGZhY3RvcmlhbCxcXG4gICAgbnByLFxcbiAgICBuY3IsXFxuICAgIGNvbWJpbmF0aW9ucyxcXG4gICAgY2FydGVzaWFuLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIHBlZWssXFxuICAgIGNodW5rLFxcbiAgICBzaHVmZmxlLFxcbiAgICBmbGF0LFxcbiAgICB1bmZsYXQsXFxuICAgIHNwbGl0LFxcbiAgICBwbHVjayxcXG4gICAgZXhjbHVkZSxcXG4gIH07XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcmxlL2RlY29kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZmFzdC1ybGUvZGVjb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCJjb25zdCBkZWNvZGUgPSBudW1zID0+IHtcXG4gIGNvbnN0IGRlY29kZWQgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkgKz0gMikge1xcbiAgICBjb25zdCBydW5fbGVuZ3RoID0gbnVtc1tpXTtcXG4gICAgY29uc3QgdmFsdWUgPSBudW1zW2kgKyAxXTtcXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJ1bl9sZW5ndGg7IGlpKyspIHtcXG4gICAgICBkZWNvZGVkLnB1c2godmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGVjb2RlZDtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vbm9kZV9tb2R1bGVzL2Zhc3QtcmxlL2RlY29kZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2xydV9tYXAvZGlzdC9scnUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9scnVfbWFwL2Rpc3QvbHJ1LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIiFmdW5jdGlvbihnLGMpeyB0cnVlP2MoZXhwb3J0cyk6MH0odGhpcyxmdW5jdGlvbihnKXtjb25zdCBjPVN5bWJvbChcXFwibmV3ZXJcXFwiKSxlPVN5bWJvbChcXFwib2xkZXJcXFwiKTtjbGFzcyBue2NvbnN0cnVjdG9yKGEsYil7dHlwZW9mIGEhPT1cXFwibnVtYmVyXFxcIiYmKGI9YSxhPTApLHRoaXMuc2l6ZT0wLHRoaXMubGltaXQ9YSx0aGlzLm9sZGVzdD10aGlzLm5ld2VzdD12b2lkIDAsdGhpcy5fa2V5bWFwPW5ldyBNYXAoKSxiJiYodGhpcy5hc3NpZ24oYiksYTwxJiYodGhpcy5saW1pdD10aGlzLnNpemUpKX1fbWFya0VudHJ5QXNVc2VkKGEpe2lmKGE9PT10aGlzLm5ld2VzdClyZXR1cm47YVtjXSYmKGE9PT10aGlzLm9sZGVzdCYmKHRoaXMub2xkZXN0PWFbY10pLGFbY11bZV09YVtlXSksYVtlXSYmKGFbZV1bY109YVtjXSksYVtjXT12b2lkIDAsYVtlXT10aGlzLm5ld2VzdCx0aGlzLm5ld2VzdCYmKHRoaXMubmV3ZXN0W2NdPWEpLHRoaXMubmV3ZXN0PWF9YXNzaWduKGEpe2xldCBiLGQ9dGhpcy5saW1pdHx8TnVtYmVyLk1BWF9WQUxVRTt0aGlzLl9rZXltYXAuY2xlYXIoKTtsZXQgbT1hW1N5bWJvbC5pdGVyYXRvcl0oKTtmb3IobGV0IGg9bS5uZXh0KCk7IWguZG9uZTtoPW0ubmV4dCgpKXtsZXQgZj1uZXcgbChoLnZhbHVlWzBdLGgudmFsdWVbMV0pO3RoaXMuX2tleW1hcC5zZXQoZi5rZXksZiksYj8oYltjXT1mLGZbZV09Yik6dGhpcy5vbGRlc3Q9ZixiPWY7aWYoZC0tPT0wKXRocm93IG5ldyBFcnJvcihcXFwib3ZlcmZsb3dcXFwiKX10aGlzLm5ld2VzdD1iLHRoaXMuc2l6ZT10aGlzLl9rZXltYXAuc2l6ZX1nZXQoYSl7dmFyIGI9dGhpcy5fa2V5bWFwLmdldChhKTtyZXR1cm4gYj8odGhpcy5fbWFya0VudHJ5QXNVc2VkKGIpLGIudmFsdWUpOnZvaWQgMH1zZXQoYSxiKXt2YXIgZD10aGlzLl9rZXltYXAuZ2V0KGEpO3JldHVybiBkPyhkLnZhbHVlPWIsdGhpcy5fbWFya0VudHJ5QXNVc2VkKGQpLHRoaXMpOih0aGlzLl9rZXltYXAuc2V0KGEsZD1uZXcgbChhLGIpKSx0aGlzLm5ld2VzdD8odGhpcy5uZXdlc3RbY109ZCxkW2VdPXRoaXMubmV3ZXN0KTp0aGlzLm9sZGVzdD1kLHRoaXMubmV3ZXN0PWQsKyt0aGlzLnNpemUsdGhpcy5zaXplPnRoaXMubGltaXQmJnRoaXMuc2hpZnQoKSx0aGlzKX1zaGlmdCgpe3ZhciBhPXRoaXMub2xkZXN0O2lmKGEpcmV0dXJuIHRoaXMub2xkZXN0W2NdPyh0aGlzLm9sZGVzdD10aGlzLm9sZGVzdFtjXSx0aGlzLm9sZGVzdFtlXT12b2lkIDApOih0aGlzLm9sZGVzdD12b2lkIDAsdGhpcy5uZXdlc3Q9dm9pZCAwKSxhW2NdPWFbZV09dm9pZCAwLHRoaXMuX2tleW1hcC5kZWxldGUoYS5rZXkpLC0tdGhpcy5zaXplLFthLmtleSxhLnZhbHVlXX1maW5kKGEpe2xldCBiPXRoaXMuX2tleW1hcC5nZXQoYSk7cmV0dXJuIGI/Yi52YWx1ZTp2b2lkIDB9aGFzKGEpe3JldHVybiB0aGlzLl9rZXltYXAuaGFzKGEpfWRlbGV0ZShhKXt2YXIgYj10aGlzLl9rZXltYXAuZ2V0KGEpO3JldHVybiBiPyh0aGlzLl9rZXltYXAuZGVsZXRlKGIua2V5KSxiW2NdJiZiW2VdPyhiW2VdW2NdPWJbY10sYltjXVtlXT1iW2VdKTpiW2NdPyhiW2NdW2VdPXZvaWQgMCx0aGlzLm9sZGVzdD1iW2NdKTpiW2VdPyhiW2VdW2NdPXZvaWQgMCx0aGlzLm5ld2VzdD1iW2VdKTp0aGlzLm9sZGVzdD10aGlzLm5ld2VzdD12b2lkIDAsdGhpcy5zaXplLS0sYi52YWx1ZSk6dm9pZCAwfWNsZWFyKCl7dGhpcy5vbGRlc3Q9dGhpcy5uZXdlc3Q9dm9pZCAwLHRoaXMuc2l6ZT0wLHRoaXMuX2tleW1hcC5jbGVhcigpfWtleXMoKXtyZXR1cm4gbmV3IGoodGhpcy5vbGRlc3QpfXZhbHVlcygpe3JldHVybiBuZXcgayh0aGlzLm9sZGVzdCl9ZW50cmllcygpe3JldHVybiB0aGlzfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIG5ldyBpKHRoaXMub2xkZXN0KX1mb3JFYWNoKGEsYil7dHlwZW9mIGIhPT1cXFwib2JqZWN0XFxcIiYmKGI9dGhpcyk7bGV0IGQ9dGhpcy5vbGRlc3Q7Zm9yKDtkOylhLmNhbGwoYixkLnZhbHVlLGQua2V5LHRoaXMpLGQ9ZFtjXX10b0pTT04oKXtmb3IodmFyIGE9bmV3IEFycmF5KHRoaXMuc2l6ZSksYj0wLGQ9dGhpcy5vbGRlc3Q7ZDspYVtiKytdPXtrZXk6ZC5rZXksdmFsdWU6ZC52YWx1ZX0sZD1kW2NdO3JldHVybiBhfXRvU3RyaW5nKCl7Zm9yKHZhciBhPVxcXCJcXFwiLGI9dGhpcy5vbGRlc3Q7YjspYSs9U3RyaW5nKGIua2V5KStcXFwiOlxcXCIrYi52YWx1ZSxiPWJbY10sYiYmKGErPVxcXCIgPCBcXFwiKTtyZXR1cm4gYX19Zy5MUlVNYXA9bjtmdW5jdGlvbiBsKGEsYil7dGhpcy5rZXk9YSx0aGlzLnZhbHVlPWIsdGhpc1tjXT12b2lkIDAsdGhpc1tlXT12b2lkIDB9ZnVuY3Rpb24gaShhKXt0aGlzLmVudHJ5PWF9aS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxpLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7bGV0IGE9dGhpcy5lbnRyeTtyZXR1cm4gYT8odGhpcy5lbnRyeT1hW2NdLHtkb25lOiExLHZhbHVlOlthLmtleSxhLnZhbHVlXX0pOntkb25lOiEwLHZhbHVlOnZvaWQgMH19O2Z1bmN0aW9uIGooYSl7dGhpcy5lbnRyeT1hfWoucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sai5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2xldCBhPXRoaXMuZW50cnk7cmV0dXJuIGE/KHRoaXMuZW50cnk9YVtjXSx7ZG9uZTohMSx2YWx1ZTphLmtleX0pOntkb25lOiEwLHZhbHVlOnZvaWQgMH19O2Z1bmN0aW9uIGsoYSl7dGhpcy5lbnRyeT1hfWsucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30say5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2xldCBhPXRoaXMuZW50cnk7cmV0dXJuIGE/KHRoaXMuZW50cnk9YVtjXSx7ZG9uZTohMSx2YWx1ZTphLnZhbHVlfSk6e2RvbmU6ITAsdmFsdWU6dm9pZCAwfX19KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUuanMubWFwXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAvLi9ub2RlX21vZHVsZXMvbHJ1X21hcC9kaXN0L2xydS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vYml0bWFwLWRlY29tcG9zZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9iaXRtYXAtZGVjb21wb3NlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYml0bWFwVG9SZWN0YW5nbGVzID0gdm9pZCAwO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxuZnVuY3Rpb24gYml0bWFwVG9SZWN0YW5nbGVzKGJpdG1hcCkge1xcbiAgICBjb25zdCByZWN0YW5nbGVzID0gW107XFxuICAgIC8vIFN0ZXAgMSAtIGNyZWF0ZSAxLXVuaXQgdGFsbCByZWN0YW5nbGVzIGZvciBlYWNoIHJvd1xcbiAgICBmb3IgKGNvbnN0IFt5LCByb3ddIG9mIGJpdG1hcC5lbnRyaWVzKCkpIHtcXG4gICAgICAgIGxldCBjdXJyZW50UmVjdGFuZ2xlID0gbnVsbDtcXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93Lmxlbmd0aDsgeCsrKSB7XFxuICAgICAgICAgICAgaWYgKHJvd1t4XSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRSZWN0YW5nbGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN0YW5nbGUgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMpKHgsIHkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMpKDEsIDEpLFxcbiAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN0YW5nbGUuc2l6ZS54Kys7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVjdGFuZ2xlKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGVzLnB1c2goY3VycmVudFJlY3RhbmdsZSk7XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdGFuZ2xlID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBTdGVwIDIgLSBleHRlbmQgZWFjaCByZWN0YW5nbGUgZG93bndhcmRzIGlmIHBvc3NpYmxlXFxuICAgIGxldCBwYWlyO1xcbiAgICB3aGlsZSAocGFpciA9IGZpbmRSZWN0YW5nbGVUb0V4dGVuZChyZWN0YW5nbGVzKSkge1xcbiAgICAgICAgY29uc3QgW2EsIGJdID0gcGFpcjtcXG4gICAgICAgIHJlY3RhbmdsZXMuc3BsaWNlKGluZGV4T2YoYiwgcmVjdGFuZ2xlcyksIDEsIC4uLmNob3BSZWN0YW5nbGUoYiwgYSkpO1xcbiAgICAgICAgYS5zaXplLnkgKz0gYi5zaXplLnk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlY3RhbmdsZXM7XFxufVxcbmV4cG9ydHMuYml0bWFwVG9SZWN0YW5nbGVzID0gYml0bWFwVG9SZWN0YW5nbGVzO1xcbi8qKlxcbiAqIEdldCB0aGUgaW5kZXggb2YgcmVjdGFuZ2xlIGEgaW4gYSBsaXN0IG9mIHJlY3RhbmdsZXNcXG4gKi9cXG5mdW5jdGlvbiBpbmRleE9mKGEsIHJlY3RhbmdsZXMpIHtcXG4gICAgcmV0dXJuIHJlY3RhbmdsZXMuZmluZEluZGV4KGIgPT4gdmVjXzEudmVjLmVxKGEucG9zaXRpb24sIGIucG9zaXRpb24pICYmIHZlY18xLnZlYy5lcShhLnNpemUsIGIuc2l6ZSkpO1xcbn1cXG4vKipcXG4gKiBGaW5kIGEgcGFpciBvZiByZWN0YW5nbGVzIHdoZXJlIHRoZSBmaXJzdCBvbmUgY2FuIGJlIGV4dGVuZGVkIGludG8gdGhlXFxuICogc2Vjb25kIG9uZVxcbiAqXFxuICogSWYgbm8gc3VjaCBwYWlyIGV4aXN0cywgcmV0dXJuIG51bGxcXG4gKi9cXG5mdW5jdGlvbiBmaW5kUmVjdGFuZ2xlVG9FeHRlbmQocmVjdGFuZ2xlcykge1xcbiAgICBmb3IgKGNvbnN0IGEgb2YgcmVjdGFuZ2xlcykge1xcbiAgICAgICAgY29uc3QgYiA9IGZpbmRSZWN0YW5nbGVUb0V4dGVuZEludG8oYSwgcmVjdGFuZ2xlcyk7XFxuICAgICAgICBpZiAoYikge1xcbiAgICAgICAgICAgIHJldHVybiBbYSwgYl07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxufVxcbi8qKlxcbiAqIEZpbmQgYSByZWN0YW5nbGUgd2hpY2ggcmVjdGFuZ2xlIGEgY2FuIGV4dGVuZCBpbnRvLCBvciBudWxsIGlmIG5vbmUgY2FuIGJlXFxuICogZm91bmRcXG4gKlxcbiAqIEEgcmVjdGFuZ2xlIGNhbiBleHRlbmQgaW50byBhbm90aGVyIG9uZSBpZiB0aGUgb3RoZXIgb25lIGlzIGV4YWN0bHkgYmVsb3dcXG4gKiBhbmQgdGhlaXIgeC1heGlzIHByb2plY3Rpb25zIG92ZXJsYXBcXG4gKi9cXG5mdW5jdGlvbiBmaW5kUmVjdGFuZ2xlVG9FeHRlbmRJbnRvKGEsIHJlY3RhbmdsZXMpIHtcXG4gICAgdmFyIF9hO1xcbiAgICByZXR1cm4gKF9hID0gcmVjdGFuZ2xlcy5maW5kKG90aGVyID0+IChcXG4gICAgLy8gVGhlIG90aGVyIHJlY3RhbmdsZSBpcyBleGFjdGx5IGJlbG93IHRoZSBjdXJyZW50IG9uZVxcbiAgICBvdGhlci5wb3NpdGlvbi55ID09PSBhLnBvc2l0aW9uLnkgKyBhLnNpemUueSAmJlxcbiAgICAgICAgLy8gVGhlIG90aGVyIHJlY3RhbmdsZSBzdGFydHMgYmVmb3JlIChvciBhdCkgdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IG9uZVxcbiAgICAgICAgb3RoZXIucG9zaXRpb24ueCA8PSBhLnBvc2l0aW9uLnggJiZcXG4gICAgICAgIC8vIFRoZSBvdGhlciByZWN0YW5nbGUgZW5kcyBhZnRlciAob3IgYXQpIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgb25lXFxuICAgICAgICBvdGhlci5wb3NpdGlvbi54ICsgb3RoZXIuc2l6ZS54ID49IGEucG9zaXRpb24ueCArIGEuc2l6ZS54KSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XFxufVxcbi8qKlxcbiAqIFN1YnRyYWN0IHJlY3RhbmdsZSBiIGZyb20gcmVjdGFuZ2xlIGEsIGlnbm9yaW5nIGhlaWdodCAoaS5lLiBvbmx5IGluIHRoZVxcbiAqIHgtYXhpcykgYW5kIHJldHVybiAwLCAxIG9yIDIgcmVzdWx0aW5nIHJlY3RhbmdsZXNcXG4gKi9cXG5mdW5jdGlvbiBjaG9wUmVjdGFuZ2xlKGEsIGIpIHtcXG4gICAgY29uc3QgcmVzdWx0ID0gW107XFxuICAgIGlmIChiLnBvc2l0aW9uLnggPiBhLnBvc2l0aW9uLngpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYykoYS5wb3NpdGlvbi54LCBhLnBvc2l0aW9uLnkpLFxcbiAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMpKGIucG9zaXRpb24ueCAtIGEucG9zaXRpb24ueCwgYS5zaXplLnkpLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKGIucG9zaXRpb24ueCArIGIuc2l6ZS54IDwgYS5wb3NpdGlvbi54ICsgYS5zaXplLngpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYykoYi5wb3NpdGlvbi54ICsgYi5zaXplLngsIGEucG9zaXRpb24ueSksXFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYykoKGEucG9zaXRpb24ueCArIGEuc2l6ZS54KSAtIChiLnBvc2l0aW9uLnggKyBiLnNpemUueCksIGEuc2l6ZS55KSxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vYml0bWFwLWRlY29tcG9zZS50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XFxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXFxcImRlZmF1bHRcXFwiOiBtb2QgfTtcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRpbGVNYXBPcHRpb25zQ29udGVudFByb2Nlc3NvciA9IGV4cG9ydHMuVGlsZU1hcCA9IGV4cG9ydHMuY2FtZXJhQm91bmRzU2l6ZSA9IGV4cG9ydHMuY2FtZXJhQm91bmRzVG9UaWxlTWFwQm91bmRzID0gZXhwb3J0cy5UaWxlQWxpZ25tZW50ID0gdm9pZCAwO1xcbmNvbnN0IGxydV9tYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxydV9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2xydV9tYXAvZGlzdC9scnUuanNcXFwiKTtcXG5jb25zdCBkZWNvZGVfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmYXN0LXJsZS9kZWNvZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcmxlL2RlY29kZS5qc1xcXCIpKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmNvbnN0IHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5jb25zdCBiaXRtYXBfZGVjb21wb3NlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2JpdG1hcC1kZWNvbXBvc2UgKi8gXFxcIi4vYml0bWFwLWRlY29tcG9zZS50c1xcXCIpO1xcbnZhciBUaWxlQWxpZ25tZW50O1xcbihmdW5jdGlvbiAoVGlsZUFsaWdubWVudCkge1xcbiAgICBUaWxlQWxpZ25tZW50W1xcXCJUb3BMZWZ0XFxcIl0gPSBcXFwidG9wLWxlZnRcXFwiO1xcbiAgICBUaWxlQWxpZ25tZW50W1xcXCJUb3BcXFwiXSA9IFxcXCJ0b3BcXFwiO1xcbiAgICBUaWxlQWxpZ25tZW50W1xcXCJUb3BSaWdodFxcXCJdID0gXFxcInRvcC1yaWdodFxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIkxlZnRcXFwiXSA9IFxcXCJsZWZ0XFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiQ2VudGVyXFxcIl0gPSBcXFwiY2VudGVyXFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiUmlnaHRcXFwiXSA9IFxcXCJyaWdodFxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIkJvdHRvbUxlZnRcXFwiXSA9IFxcXCJib3R0b20tbGVmdFxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIkJvdHRvbVxcXCJdID0gXFxcImJvdHRvbVxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIkJvdHRvbVJpZ2h0XFxcIl0gPSBcXFwiYm90dG9tLXJpZ2h0XFxcIjtcXG59KShUaWxlQWxpZ25tZW50ID0gZXhwb3J0cy5UaWxlQWxpZ25tZW50IHx8IChleHBvcnRzLlRpbGVBbGlnbm1lbnQgPSB7fSkpO1xcbmZ1bmN0aW9uIHBvaW50SW5SZWN0YW5nbGUocG9pbnQsIHRvcExlZnQsIGJvdHRvbVJpZ2h0KSB7XFxuICAgIHJldHVybiAocG9pbnQueCA+PSB0b3BMZWZ0LnggJiZcXG4gICAgICAgIHBvaW50LnkgPj0gdG9wTGVmdC55ICYmXFxuICAgICAgICBwb2ludC54IDwgYm90dG9tUmlnaHQueCAmJlxcbiAgICAgICAgcG9pbnQueSA8IGJvdHRvbVJpZ2h0LnkpO1xcbn1cXG5mdW5jdGlvbiBjYW1lcmFCb3VuZHNUb1RpbGVNYXBCb3VuZHMoYm91bmRzKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgICB0b3BMZWZ0OiAoMCwgdmVjXzEudmVjKShib3VuZHMubGVmdCwgYm91bmRzLnRvcCksXFxuICAgICAgICBib3R0b21SaWdodDogKDAsIHZlY18xLnZlYykoYm91bmRzLnJpZ2h0LCBib3VuZHMuYm90dG9tKSxcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5jYW1lcmFCb3VuZHNUb1RpbGVNYXBCb3VuZHMgPSBjYW1lcmFCb3VuZHNUb1RpbGVNYXBCb3VuZHM7XFxuZnVuY3Rpb24gY2FtZXJhQm91bmRzU2l6ZShib3VuZHMpIHtcXG4gICAgY29uc3QgY29udmVydGVkQm91bmRzID0gY2FtZXJhQm91bmRzVG9UaWxlTWFwQm91bmRzKGJvdW5kcyk7XFxuICAgIHJldHVybiB2ZWNfMS52ZWMuc3ViKGNvbnZlcnRlZEJvdW5kcy5ib3R0b21SaWdodCwgY29udmVydGVkQm91bmRzLnRvcExlZnQpO1xcbn1cXG5leHBvcnRzLmNhbWVyYUJvdW5kc1NpemUgPSBjYW1lcmFCb3VuZHNTaXplO1xcbmNsYXNzIFRpbGVNYXAge1xcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgVGlsZU1hcC5ERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgICAgIGZvciAoY29uc3QgW2ksIGxheWVyXSBvZiBhY3R1YWxPcHRpb25zLmxheWVycy5lbnRyaWVzKCkpIHtcXG4gICAgICAgICAgICBhY3R1YWxPcHRpb25zLmxheWVyc1tpXSA9IE9iamVjdC5hc3NpZ24oe30sIFRpbGVNYXAuREVGQVVMVF9MQVlFUl9PUFRJT05TLCBsYXllcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWFjdHVhbE9wdGlvbnMuZGVidWcgfHwgYWN0dWFsT3B0aW9ucy5kZWJ1ZyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIGFjdHVhbE9wdGlvbnMuZGVidWcgPSB7XFxuICAgICAgICAgICAgICAgIHNob3dPcmlnaW46ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICAgICAgc2hvd0NodW5rQm9yZGVyczogISFhY3R1YWxPcHRpb25zLmRlYnVnLFxcbiAgICAgICAgICAgICAgICBzaG93Q2h1bmtMYWJlbHM6ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICAgICAgc2hvd1RpbGVCb3JkZXJzOiAhIWFjdHVhbE9wdGlvbnMuZGVidWcsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFjdHVhbE9wdGlvbnM7XFxuICAgICAgICB0aGlzLmNodW5rQnVmZmVyID0gbmV3IGxydV9tYXBfMS5MUlVNYXAodGhpcy5vcHRpb25zLmNodW5rQnVmZmVyTWF4U2l6ZSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCBhIChyb3VnaGx5IG1pbmltYWwpIHNldCBvZiByZWN0YW5nbGVzIHdoaWNoIGNvdmVyIHRoZSB0aWxlcyBpbiBhXFxuICAgICAqIGdpdmVuIGxheWVyXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBsYXllck5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyIHRvIGdldCByZWN0YW5nbGVzIGZvclxcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lIFdlIHdpbGwgY2hlY2sgdGhlIHRydXRoeW5lc3Mgb2YgdGhpcyBmaWVsZCBpbiB0aGVcXG4gICAgICogdGlsZSBkZWZpbml0aW9uXFxuICAgICAqIEBwYXJhbSB0aWxlQm91bmRzIE9wdGlvbmFsIGJvdW5kcyB0byBjaGVjayB3aXRoaW4sIHJlbGF0aXZlIHRvIGJvdW5kc1xcbiAgICAgKiBkZWZpbmVkIGluIG9wdGlvbnMgaWYgYW55IGV4aXN0LCBvdGhlcndpc2UgcmVsYXRpdmUgdG8gKDAsIDApXFxuICAgICAqL1xcbiAgICBnZXRMYXllclJlY3RhbmdsZXMobGF5ZXJOYW1lLCBmaWVsZE5hbWUsIHRpbGVCb3VuZHMpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLm9wdGlvbnMubGF5ZXJzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbGF5ZXJOYW1lKTtcXG4gICAgICAgIGlmICghbGF5ZXIpIHtcXG4gICAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gKF9hID0gdGlsZUJvdW5kcyA9PT0gbnVsbCB8fCB0aWxlQm91bmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlQm91bmRzLnRvcExlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLCB2ZWNfMS52ZWMpKDApO1xcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSAoX2IgPSB0aWxlQm91bmRzID09PSBudWxsIHx8IHRpbGVCb3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbGVCb3VuZHMuYm90dG9tUmlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgwLCB2ZWNfMS52ZWMpKE1hdGgubWF4KC4uLihfZCA9IChfYyA9IGxheWVyLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAocm93ID0+IHJvdy5sZW5ndGgpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbMF0pLCAoX2YgPSAoX2UgPSBsYXllci5kYXRhKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwKTtcXG4gICAgICAgIGlmIChib3R0b21SaWdodC54IDw9IHRvcExlZnQueCB8fCBib3R0b21SaWdodC55IDw9IHRvcExlZnQueSkge1xcbiAgICAgICAgICAgIHJldHVybiBbXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IFtdO1xcbiAgICAgICAgZm9yIChsZXQgeSA9IHRvcExlZnQueTsgeSA8IGJvdHRvbVJpZ2h0Lnk7IHkrKykge1xcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0Lng7IHggPCBib3R0b21SaWdodC54OyB4KyspIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgdGlsZURhdGEgPSAoX2ggPSAoX2cgPSBsYXllci5kYXRhKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbeV0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFt4XTtcXG4gICAgICAgICAgICAgICAgaWYgKHRpbGVEYXRhID09PSB1bmRlZmluZWQgfHwgdGlsZURhdGEgPT09IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gKF9qID0gbGF5ZXIudGlsZXMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfalt0aWxlRGF0YV07XFxuICAgICAgICAgICAgICAgIGlmICghdGlsZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAmJiAhdGlsZVtmaWVsZE5hbWVdKSB7XFxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaChmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByb3cucHVzaCh0cnVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYml0bWFwLnB1c2gocm93KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoMCwgYml0bWFwX2RlY29tcG9zZV8xLmJpdG1hcFRvUmVjdGFuZ2xlcykoYml0bWFwKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IHRoZSB0aWxlIGF0IGEgZ2l2ZW4gcG9zaXRpb24gYW5kIGluIHRoZSBzcGVjaWZpZWQgbGF5ZXJcXG4gICAgICpcXG4gICAgICogSWYgbm8gbGF5ZXIgaXMgc3BlY2lmaWVkLCByZXR1cm4gYSBkaWN0aW9uYXJ5IG9mIGxheWVyIG5hbWVzIHRvIHRpbGVcXG4gICAgICogZGVmaW5pdGlvbnMgKGkuZS4gcmV0dXJuIGFsbCBsYXllcnMpXFxuICAgICAqXFxuICAgICAqIElmIG5vIHRpbGUgZXhpc3RzIGF0IHRoaXMgcG9zaXRpb24sIHJldHVybiBudWxsXFxuICAgICAqL1xcbiAgICBnZXRUaWxlQXRQb3NpdGlvbihwb3NpdGlvbiwgbGF5ZXJOYW1lKSB7XFxuICAgICAgICBpZiAobGF5ZXJOYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUF0UG9zaXRpb25JbkxheWVyKHBvc2l0aW9uLCBsYXllck5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XFxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMub3B0aW9ucy5sYXllcnMpIHtcXG4gICAgICAgICAgICByZXN1bHRbbGF5ZXIubmFtZV0gPSB0aGlzLmdldFRpbGVBdFBvc2l0aW9uSW5MYXllcihwb3NpdGlvbiwgbGF5ZXIubmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICAgIGdldFRpbGVBdFBvc2l0aW9uSW5MYXllcihwb3NpdGlvbiwgbGF5ZXJOYW1lKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcXG4gICAgICAgIGNvbnN0IHRpbGVQb3NpdGlvbiA9IHZlY18xLnZlYy5tYXAodmVjXzEudmVjLm11bChwb3NpdGlvbiwgMSAvIHRoaXMub3B0aW9ucy50aWxlU2l6ZSksIE1hdGguZmxvb3IpO1xcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLm9wdGlvbnMubGF5ZXJzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbGF5ZXJOYW1lKTtcXG4gICAgICAgIGlmICghbGF5ZXIpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IHRpbGVEYXRhID0gKF9iID0gKF9hID0gbGF5ZXIuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RpbGVQb3NpdGlvbi55XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3RpbGVQb3NpdGlvbi54XTtcXG4gICAgICAgIGlmICh0aWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHRpbGVEYXRhID09PSAtMSkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGxheWVyLnRpbGVzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChfYyA9IGxheWVyLnRpbGVzW3RpbGVEYXRhXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIGhhc2hWZWN0b3Iodikge1xcbiAgICAgICAgcmV0dXJuIHZlY18xLnZlYy5zdHIodik7XFxuICAgIH1cXG4gICAgZHJhdyhjb250ZXh0LCBhLCBiLCBjKSB7XFxuICAgICAgICBpZiAoYiAmJiBjKSB7XFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtRHJhdyhjb250ZXh0LCBhLCBiLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbiA9IGNhbWVyYUJvdW5kc1NpemUoYS5ib3VuZHMpO1xcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybURyYXcoY29udGV4dCwgc2NyZWVuLCBhLmFjdHVhbFBvc2l0aW9uLCBhLmFjdHVhbFNjYWxlLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcGVyZm9ybURyYXcoY29udGV4dCwgc2NyZWVuLCBwb3NpdGlvbiwgc2NhbGUsIGRvVHJhbnNmb3JtcyA9IHRydWUpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcXG4gICAgICAgIGNvbnN0IGFic29sdXRlQ2h1bmtTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplICogdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcXG4gICAgICAgIGNvbnN0IGNodW5rQm9yZGVyID0gKDAsIHZlY18xLnZlYykodGhpcy5vcHRpb25zLmNodW5rQm9yZGVyKTtcXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHNjYWxlXFxuICAgICAgICBsZXQgYWN0dWFsU2NhbGUgPSBzY2FsZTtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluU2NhbGUgJiYgYWN0dWFsU2NhbGUgPCB0aGlzLm9wdGlvbnMubWluU2NhbGUpIHtcXG4gICAgICAgICAgICBhY3R1YWxTY2FsZSA9IHRoaXMub3B0aW9ucy5taW5TY2FsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4U2NhbGUgJiYgYWN0dWFsU2NhbGUgPiB0aGlzLm9wdGlvbnMubWF4U2NhbGUpIHtcXG4gICAgICAgICAgICBhY3R1YWxTY2FsZSA9IHRoaXMub3B0aW9ucy5tYXhTY2FsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHBvc2l0aW9uIHRvIGJvdW5kc1xcbiAgICAgICAgbGV0IGFjdHVhbFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykocG9zaXRpb24pO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgJiYgdGhpcy5vcHRpb25zLmNsYW1wUG9zaXRpb25Ub0JvdW5kcykge1xcbiAgICAgICAgICAgIGNvbnN0IHRpbGVTaXplU2NhbGVkID0gdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gYWN0dWFsU2NhbGU7XFxuICAgICAgICAgICAgY29uc3QgaGFsZlNjcmVlblNjYWxlZCA9IHZlY18xLnZlYy5tYXAodmVjXzEudmVjLm11bChzY3JlZW4sIDEgLyAoYWN0dWFsU2NhbGUgKiAyKSksIE1hdGguY2VpbCk7XFxuICAgICAgICAgICAgY29uc3QgbWluUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSh0aGlzLm9wdGlvbnMuYm91bmRzLnRvcExlZnQueCAqIHRpbGVTaXplU2NhbGVkICsgaGFsZlNjcmVlblNjYWxlZC54LCB0aGlzLm9wdGlvbnMuYm91bmRzLnRvcExlZnQueSAqIHRpbGVTaXplU2NhbGVkICsgaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICBjb25zdCBtYXhQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKHRoaXMub3B0aW9ucy5ib3VuZHMuYm90dG9tUmlnaHQueCAqIHRpbGVTaXplU2NhbGVkIC0gaGFsZlNjcmVlblNjYWxlZC54LCB0aGlzLm9wdGlvbnMuYm91bmRzLmJvdHRvbVJpZ2h0LnkgKiB0aWxlU2l6ZVNjYWxlZCAtIGhhbGZTY3JlZW5TY2FsZWQueSk7XFxuICAgICAgICAgICAgYWN0dWFsUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSgoMCwgdXRpbHNfMS5jbGFtcCkoYWN0dWFsUG9zaXRpb24ueCwgbWluUG9zaXRpb24ueCwgbWF4UG9zaXRpb24ueCksICgwLCB1dGlsc18xLmNsYW1wKShhY3R1YWxQb3NpdGlvbi55LCBtaW5Qb3NpdGlvbi55LCBtYXhQb3NpdGlvbi55KSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBzY3JlZW5TaXplSW5DaHVua3MgPSB2ZWNfMS52ZWMubWFwKHZlY18xLnZlYy5tdWwoc2NyZWVuLCAxIC8gKGFic29sdXRlQ2h1bmtTaXplICogYWN0dWFsU2NhbGUpKSwgTWF0aC5jZWlsKTtcXG4gICAgICAgIGNvbnN0IHNjcmVlbkNlbnRlckNodW5rID0gdmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKGFjdHVhbFBvc2l0aW9uLCAxIC8gYWJzb2x1dGVDaHVua1NpemUpLCBNYXRoLmZsb29yKTtcXG4gICAgICAgIGNvbnN0IHRvcExlZnRDaHVuayA9IHZlY18xLnZlYy5zdWIodmVjXzEudmVjLnN1YihzY3JlZW5DZW50ZXJDaHVuaywgdmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKHNjcmVlblNpemVJbkNodW5rcywgMC41KSwgTWF0aC5jZWlsKSksIGNodW5rQm9yZGVyKTtcXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0Q2h1bmsgPSB2ZWNfMS52ZWMuYWRkKHZlY18xLnZlYy5hZGQoc2NyZWVuQ2VudGVyQ2h1bmssIHZlY18xLnZlYy5tYXAodmVjXzEudmVjLm11bChzY3JlZW5TaXplSW5DaHVua3MsIDAuNSksIE1hdGguY2VpbCkpLCBjaHVua0JvcmRlcik7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGlmIChkb1RyYW5zZm9ybXMpIHtcXG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKGFjdHVhbFNjYWxlLCBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWFjdHVhbFBvc2l0aW9uLnggKyBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCAtYWN0dWFsUG9zaXRpb24ueSArIHNjcmVlbi55IC8gKGFjdHVhbFNjYWxlICogMikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5wcmVSZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBjb250ZXh0LCB0aGlzLCBzY3JlZW4sIGFjdHVhbFBvc2l0aW9uLCBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAvLyBSZW5kZXIgY2h1bmtzXFxuICAgICAgICBmb3IgKGxldCB5ID0gdG9wTGVmdENodW5rLnk7IHkgPCBib3R0b21SaWdodENodW5rLnk7IHkrKykge1xcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0Q2h1bmsueDsgeCA8IGJvdHRvbVJpZ2h0Q2h1bmsueDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSh4LCB5KTtcXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtBYnNvbHV0ZVBvc2l0aW9uID0gdmVjXzEudmVjLm11bChjaHVua1Bvc2l0aW9uLCBhYnNvbHV0ZUNodW5rU2l6ZSk7XFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhpcyBjaHVuayBpbiB0aGUgY2FjaGVcXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtIYXNoID0gdGhpcy5oYXNoVmVjdG9yKGNodW5rUG9zaXRpb24pO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2h1bmtCdWZmZXIuaGFzKGNodW5rSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWZmZXIuc2V0KGNodW5rSGFzaCwgdGhpcy5nZW5lcmF0ZUNodW5rKGNodW5rUG9zaXRpb24sIGFic29sdXRlQ2h1bmtTaXplKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rQnVmZmVyLmdldChjaHVua0hhc2gpO1xcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGNodW5rLmltYWdlLCBjaHVua0Fic29sdXRlUG9zaXRpb24ueCwgY2h1bmtBYnNvbHV0ZVBvc2l0aW9uLnkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5vcHRpb25zKS5wb3N0UmVuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgY29udGV4dCwgdGhpcywgc2NyZWVuLCBhY3R1YWxQb3NpdGlvbiwgYWN0dWFsU2NhbGUpO1xcbiAgICAgICAgLy8gUmVuZGVyIGRlYnVnIGhlbHBlcnNcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd1RpbGVCb3JkZXJzKSB7XFxuICAgICAgICAgICAgY29uc3QgdG9wTGVmdFRpbGUgPSB2ZWNfMS52ZWMubXVsKHZlY18xLnZlYy5zdWIoc2NyZWVuQ2VudGVyQ2h1bmssIHZlY18xLnZlYy5hZGQodmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKHNjcmVlblNpemVJbkNodW5rcywgMC41KSwgTWF0aC5jZWlsKSwgKDAsIHZlY18xLnZlYykoMSkpKSwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XFxuICAgICAgICAgICAgY29uc3QgYm90dG9tUmlnaHRUaWxlID0gdmVjXzEudmVjLm11bCh2ZWNfMS52ZWMuYWRkKHNjcmVlbkNlbnRlckNodW5rLCB2ZWNfMS52ZWMuYWRkKHZlY18xLnZlYy5tYXAodmVjXzEudmVjLm11bChzY3JlZW5TaXplSW5DaHVua3MsIDAuNSksIE1hdGguY2VpbCksICgwLCB2ZWNfMS52ZWMpKDEpKSksIHRoaXMub3B0aW9ucy5jaHVua1NpemUpO1xcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0VGlsZS55OyB5IDwgYm90dG9tUmlnaHRUaWxlLnk7IHkrKykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGNvbnRleHQsICgwLCB2ZWNfMS52ZWMpKGFjdHVhbFBvc2l0aW9uLnggLSBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCB5ICogdGhpcy5vcHRpb25zLnRpbGVTaXplKSwgKDAsIHZlY18xLnZlYykoYWN0dWFsUG9zaXRpb24ueCArIHNjcmVlbi54IC8gKGFjdHVhbFNjYWxlICogMiksIHkgKiB0aGlzLm9wdGlvbnMudGlsZVNpemUpLCBUaWxlTWFwLkRFQlVHX1RJTEVfQk9SREVSX0NPTE9VUiwgVGlsZU1hcC5ERUJVR19USUxFX0JPUkRFUl9MSU5FX1dJRFRIKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHRvcExlZnRUaWxlLng7IHggPCBib3R0b21SaWdodFRpbGUueDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoY29udGV4dCwgKDAsIHZlY18xLnZlYykoeCAqIHRoaXMub3B0aW9ucy50aWxlU2l6ZSwgYWN0dWFsUG9zaXRpb24ueSAtIHNjcmVlbi55IC8gKGFjdHVhbFNjYWxlICogMikpLCAoMCwgdmVjXzEudmVjKSh4ICogdGhpcy5vcHRpb25zLnRpbGVTaXplLCBhY3R1YWxQb3NpdGlvbi55ICsgc2NyZWVuLnkgLyAoYWN0dWFsU2NhbGUgKiAyKSksIFRpbGVNYXAuREVCVUdfVElMRV9CT1JERVJfQ09MT1VSLCBUaWxlTWFwLkRFQlVHX1RJTEVfQk9SREVSX0xJTkVfV0lEVEgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd0NodW5rQm9yZGVycykge1xcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0Q2h1bmsueTsgeSA8IGJvdHRvbVJpZ2h0Q2h1bmsueTsgeSsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoY29udGV4dCwgKDAsIHZlY18xLnZlYykoYWN0dWFsUG9zaXRpb24ueCAtIHNjcmVlbi54IC8gKGFjdHVhbFNjYWxlICogMiksIHkgKiBhYnNvbHV0ZUNodW5rU2l6ZSksICgwLCB2ZWNfMS52ZWMpKGFjdHVhbFBvc2l0aW9uLnggKyBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCB5ICogYWJzb2x1dGVDaHVua1NpemUpLCBUaWxlTWFwLkRFQlVHX0NIVU5LX0JPUkRFUl9DT0xPVVIsIFRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0xJTkVfV0lEVEgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gdG9wTGVmdENodW5rLng7IHggPCBib3R0b21SaWdodENodW5rLng7IHgrKykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGNvbnRleHQsICgwLCB2ZWNfMS52ZWMpKHggKiBhYnNvbHV0ZUNodW5rU2l6ZSwgYWN0dWFsUG9zaXRpb24ueSAtIHNjcmVlbi55IC8gKGFjdHVhbFNjYWxlICogMikpLCAoMCwgdmVjXzEudmVjKSh4ICogYWJzb2x1dGVDaHVua1NpemUsIGFjdHVhbFBvc2l0aW9uLnkgKyBzY3JlZW4ueSAvIChhY3R1YWxTY2FsZSAqIDIpKSwgVGlsZU1hcC5ERUJVR19DSFVOS19CT1JERVJfQ09MT1VSLCBUaWxlTWFwLkRFQlVHX0NIVU5LX0JPUkRFUl9MSU5FX1dJRFRIKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnLnNob3dDaHVua0xhYmVscykge1xcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gVGlsZU1hcC5ERUJVR19DSFVOS19MQUJFTF9DT0xPVVI7XFxuICAgICAgICAgICAgY29udGV4dC5mb250ID0gVGlsZU1hcC5ERUJVR19DSFVOS19MQUJFTF9GT05UO1xcbiAgICAgICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XFxuICAgICAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gdG9wTGVmdENodW5rLnk7IHkgPCBib3R0b21SaWdodENodW5rLnk7IHkrKykge1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gdG9wTGVmdENodW5rLng7IHggPCBib3R0b21SaWdodENodW5rLng7IHgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChgJHt4fSwgJHt5fWAsIHggKiBhYnNvbHV0ZUNodW5rU2l6ZSArIGFic29sdXRlQ2h1bmtTaXplIC8gMiwgeSAqIGFic29sdXRlQ2h1bmtTaXplICsgYWJzb2x1dGVDaHVua1NpemUgLyAyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd09yaWdpbiAmJlxcbiAgICAgICAgICAgIHBvaW50SW5SZWN0YW5nbGUoKDAsIHZlY18xLnZlYykoMCwgMCksIHRvcExlZnRDaHVuaywgYm90dG9tUmlnaHRDaHVuaykpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdDcm9zcyhjb250ZXh0LCAoMCwgdmVjXzEudmVjKSgwLCAwKSwgVGlsZU1hcC5ERUJVR19PUklHSU5fQ09MT1VSLCBUaWxlTWFwLkRFQlVHX09SSUdJTl9MSU5FX1dJRFRILCBUaWxlTWFwLkRFQlVHX09SSUdJTl9TSVpFKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGdlbmVyYXRlQ2h1bmsoY2h1bmtQb3NpdGlvbiwgYWJzb2x1dGVDaHVua1NpemUpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xcbiAgICAgICAgY29uc3QgY2h1bmtDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgICAgIGNvbnN0IGNodW5rQ29udGV4dCA9IGNodW5rQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XFxuICAgICAgICBjaHVua0NhbnZhcy53aWR0aCA9IGFic29sdXRlQ2h1bmtTaXplO1xcbiAgICAgICAgY2h1bmtDYW52YXMuaGVpZ2h0ID0gYWJzb2x1dGVDaHVua1NpemU7XFxuICAgICAgICBsZXQgY2h1bmsgPSB7XFxuICAgICAgICAgICAgY2h1bmtQb3NpdGlvbixcXG4gICAgICAgICAgICBpbWFnZTogY2h1bmtDYW52YXMsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgdG9wTGVmdFRpbGUgPSB2ZWNfMS52ZWMubXVsKGNodW5rUG9zaXRpb24sIHRoaXMub3B0aW9ucy5jaHVua1NpemUpO1xcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHRUaWxlID0gdmVjXzEudmVjLmFkZCh0b3BMZWZ0VGlsZSwgKDAsIHZlY18xLnZlYykodGhpcy5vcHRpb25zLmNodW5rU2l6ZSAtIDEpKTtcXG4gICAgICAgIGNvbnN0IGJvdW5kc1RvcExlZnQgPSAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuYm91bmRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9wTGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKDAsIHZlY18xLnZlYykoMCk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZUdlbmVyYXRlQ2h1bmspIHtcXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm9wdGlvbnMucHJlR2VuZXJhdGVDaHVuayhjaHVua0NvbnRleHQsIHRoaXMsIHtcXG4gICAgICAgICAgICAgICAgdG9wTGVmdDogdG9wTGVmdFRpbGUsXFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodFRpbGUsXFxuICAgICAgICAgICAgfSwgY2h1bmtQb3NpdGlvbik7XFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFsxXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRGVmYXVsdCBnZW5lcmF0aW9uLCByZW5kZXIgdGlsZXMgZnJvbSB0aWxlbWFwIGRhdGFcXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5vcHRpb25zLmxheWVycykge1xcbiAgICAgICAgICAgIGNodW5rQ29udGV4dC5zYXZlKCk7XFxuICAgICAgICAgICAgY2h1bmtDb250ZXh0Lmdsb2JhbEFscGhhID0gKF9jID0gbGF5ZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMTtcXG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSAoX2QgPSBsYXllci5hbGlnbm1lbnQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFRpbGVBbGlnbm1lbnQuQ2VudGVyO1xcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0VGlsZS55OyB5IDw9IGJvdHRvbVJpZ2h0VGlsZS55OyB5KyspIHtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHRvcExlZnRUaWxlLng7IHggPD0gYm90dG9tUmlnaHRUaWxlLng7IHgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoeCwgeSk7XFxuICAgICAgICAgICAgICAgICAgICAoX2UgPSBsYXllci5wcmVSZW5kZXJUaWxlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChsYXllciwgY2h1bmtDb250ZXh0LCB0aGlzLCBsYXllciwgY2h1bmtQb3NpdGlvbiwgdGlsZVBvc2l0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVEYXRhUG9zaXRpb24gPSB2ZWNfMS52ZWMuc3ViKHRpbGVQb3NpdGlvbiwgYm91bmRzVG9wTGVmdCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZURhdGFQb3NpdGlvbi54IDwgMCB8fCB0aWxlRGF0YVBvc2l0aW9uLnkgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlRGF0YSA9IChfZyA9IChfZiA9IGxheWVyLmRhdGEpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlt0aWxlRGF0YVBvc2l0aW9uLnldKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbdGlsZURhdGFQb3NpdGlvbi54XTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHRpbGVEYXRhID09PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZUltYWdlID0gKF9qID0gKF9oID0gbGF5ZXIudGlsZXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFt0aWxlRGF0YV0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5pbWFnZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlsZUltYWdlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlQWJzb2x1dGVQb3NpdGlvbiA9IHZlY18xLnZlYy5zdWIodmVjXzEudmVjLm11bCh0aWxlUG9zaXRpb24sIHRoaXMub3B0aW9ucy50aWxlU2l6ZSksIHZlY18xLnZlYy5tdWwoY2h1bmtQb3NpdGlvbiwgYWJzb2x1dGVDaHVua1NpemUpKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpbGUgY2xpcHBpbmdcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5jbGlwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDb250ZXh0LnNhdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0NvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDb250ZXh0LnJlY3QodGlsZUFic29sdXRlUG9zaXRpb24ueCwgdGlsZUFic29sdXRlUG9zaXRpb24ueSwgdGhpcy5vcHRpb25zLnRpbGVTaXplLCB0aGlzLm9wdGlvbnMudGlsZVNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5jbGlwKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvLyBUaWxlIGFsaWdubWVudFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb247XFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5Ub3BMZWZ0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykodGlsZUFic29sdXRlUG9zaXRpb24pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuVG9wOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnggKyB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyAyKSAtIHRpbGVJbWFnZS53aWR0aCAvIDIsIHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuVG9wUmlnaHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54ICsgdGhpcy5vcHRpb25zLnRpbGVTaXplIC0gdGlsZUltYWdlLndpZHRoLCB0aWxlQWJzb2x1dGVQb3NpdGlvbi55KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaWxlQWxpZ25tZW50LkxlZnQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54LCAodGlsZUFic29sdXRlUG9zaXRpb24ueSArIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIpIC0gdGlsZUltYWdlLmhlaWdodCAvIDIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuQ2VudGVyOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnggKyB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyAyKSAtIHRpbGVJbWFnZS53aWR0aCAvIDIsICh0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICsgdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMikgLSB0aWxlSW1hZ2UuaGVpZ2h0IC8gMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5SaWdodDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnggKyB0aGlzLm9wdGlvbnMudGlsZVNpemUgLSB0aWxlSW1hZ2Uud2lkdGgsICh0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICsgdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMikgLSB0aWxlSW1hZ2UuaGVpZ2h0IC8gMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5Cb3R0b21MZWZ0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykodGlsZUFic29sdXRlUG9zaXRpb24ueCwgdGlsZUFic29sdXRlUG9zaXRpb24ueSArIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtIHRpbGVJbWFnZS5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuQm90dG9tOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnggKyB0aGlzLm9wdGlvbnMudGlsZVNpemUgLyAyKSAtIHRpbGVJbWFnZS53aWR0aCAvIDIsIHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnkgKyB0aGlzLm9wdGlvbnMudGlsZVNpemUgLSB0aWxlSW1hZ2UuaGVpZ2h0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaWxlQWxpZ25tZW50LkJvdHRvbVJpZ2h0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykodGlsZUFic29sdXRlUG9zaXRpb24ueCArIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtIHRpbGVJbWFnZS53aWR0aCwgdGlsZUFic29sdXRlUG9zaXRpb24ueSArIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtIHRpbGVJbWFnZS5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5kcmF3SW1hZ2UodGlsZUltYWdlLCB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uLngsIHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb24ueSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIuY2xpcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAoX2sgPSBsYXllci5wb3N0UmVuZGVyVGlsZSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmNhbGwobGF5ZXIsIGNodW5rQ2FudmFzLCBjaHVua0NvbnRleHQsIHRoaXMsIGxheWVyLCBjaHVua1Bvc2l0aW9uLCB0aWxlUG9zaXRpb24pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNodW5rQ29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICB9XFxuICAgICAgICAoX20gPSAoX2wgPSB0aGlzLm9wdGlvbnMpLnBvc3RHZW5lcmF0ZUNodW5rKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uY2FsbChfbCwgY2h1bmtDYW52YXMsIGNodW5rQ29udGV4dCwgdGhpcywge1xcbiAgICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnRUaWxlLFxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodFRpbGUsXFxuICAgICAgICB9LCBjaHVua1Bvc2l0aW9uKTtcXG4gICAgICAgIHJldHVybiBjaHVuaztcXG4gICAgfVxcbiAgICBkcmF3TGluZShjb250ZXh0LCBzdGFydCwgZW5kLCBjb2xvdXIsIGxpbmVXaWR0aCkge1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDcm9zcyhjb250ZXh0LCBwb3NpdGlvbiwgY29sb3VyLCBsaW5lV2lkdGgsIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IE1hdGguY2VpbChzaXplIC8gMik7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3VyO1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzLlRpbGVNYXAgPSBUaWxlTWFwO1xcblRpbGVNYXAuREVGQVVMVF9PUFRJT05TID0ge1xcbiAgICBjbGFtcFBvc2l0aW9uVG9Cb3VuZHM6IHRydWUsXFxuICAgIHRpbGVTaXplOiAxNixcXG4gICAgbGF5ZXJzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICAgICAgfSxcXG4gICAgXSxcXG4gICAgY2h1bmtTaXplOiA4LFxcbiAgICBjaHVua0JvcmRlcjogMSxcXG4gICAgY2h1bmtCdWZmZXJNYXhTaXplOiA2NCxcXG59O1xcblRpbGVNYXAuREVGQVVMVF9MQVlFUl9PUFRJT05TID0ge1xcbiAgICBuYW1lOiAnZGVmYXVsdCcsXFxufTtcXG5UaWxlTWFwLkRFQlVHX09SSUdJTl9DT0xPVVIgPSAnY3lhbic7XFxuVGlsZU1hcC5ERUJVR19PUklHSU5fTElORV9XSURUSCA9IDI7XFxuVGlsZU1hcC5ERUJVR19PUklHSU5fU0laRSA9IDEwO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0NPTE9VUiA9ICd5ZWxsb3cnO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0xJTkVfV0lEVEggPSAyO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfTEFCRUxfQ09MT1VSID0gJ3doaXRlJztcXG5UaWxlTWFwLkRFQlVHX0NIVU5LX0xBQkVMX0ZPTlQgPSAnMTJweCBtb25vc3BhY2UnO1xcblRpbGVNYXAuREVCVUdfVElMRV9CT1JERVJfQ09MT1VSID0gJ29yYW5nZSc7XFxuVGlsZU1hcC5ERUJVR19USUxFX0JPUkRFUl9MSU5FX1dJRFRIID0gMTtcXG4vKipcXG4gKiBDb250ZW50IE1hbmFnZXIgUHJvY2Vzc29yIHdyYXBwZXIgd2hpY2ggY29udmVydHMgVGlsZU1hcE9wdGlvbnNEYXRhIGludG9cXG4gKiBUaWxlTWFwT3B0aW9uc1xcbiAqXFxuICogQHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXJcXG4gKi9cXG5hc3luYyBmdW5jdGlvbiB0aWxlTWFwT3B0aW9uc0NvbnRlbnRQcm9jZXNzb3IoY29udGVudCwgZGF0YSwgb3B0aW9ucykge1xcbiAgICBjb25zdCBnZXRJbWFnZUZyb21Db250ZW50ID0gKG5hbWUpID0+IHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGltYWdlID0gKF9hID0gY29udGVudFtuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XFxuICAgICAgICBpZiAoIWltYWdlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaW1hZ2U7XFxuICAgIH07XFxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuY29udGVudDtcXG4gICAgaWYgKHJlc3VsdC5sYXllcnMpIHtcXG4gICAgICAgIGZvciAoY29uc3QgW2ksIGxheWVyXSBvZiByZXN1bHQubGF5ZXJzLmVudHJpZXMoKSkge1xcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgaW1hZ2VOYW1lIHdpdGggaW1hZ2UgaW4gdGhlIHRpbGUgZGVmaW5pdGlvbnMgYXJyYXlcXG4gICAgICAgICAgICBpZiAobGF5ZXIudGlsZXMpIHtcXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaiwgdGlsZV0gb2YgbGF5ZXIudGlsZXMuZW50cmllcygpKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGF5ZXJzW2ldLnRpbGVzW2pdLmltYWdlID0gZ2V0SW1hZ2VGcm9tQ29udGVudCh0aWxlLmltYWdlTmFtZSk7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LmxheWVyc1tpXS50aWxlc1tqXS5pbWFnZU5hbWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gRGVjb21wcmVzcyBsYXllciBkYXRhXFxuICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb21wcmVzc0RhdGEpICYmIGxheWVyLmRhdGEgJiYgbGF5ZXIud2lkdGgpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0LmxheWVyc1tpXS5kYXRhID0gKDAsIHV0aWxzXzEuY2h1bmspKCgwLCBkZWNvZGVfMS5kZWZhdWx0KShsYXllci5kYXRhKSwgbGF5ZXIud2lkdGgpO1xcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LmxheWVyc1tpXS53aWR0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLy8gQHRzLWlnbm9yZVxcbiAgICBkYXRhLmNvbnRlbnQgPSByZXN1bHQ7XFxufVxcbmV4cG9ydHMudGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yID0gdGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXG4gKiBAcGFyYW0ge251bWJlcn0gW3A9TnVtYmVyLkVQU0lMT05dIFRoZSBwcmVjaXNpb24gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gKi9cbmNvbnN0IGZsb2F0RXF1YWxzID0gKGEsIGIsIHAgPSBOdW1iZXIuRVBTSUxPTikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgcDtcblxuLyoqXG4gKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxuICovXG5jb25zdCBjbGFtcCA9IChhLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcblxuLyoqXG4gKiBHZXQgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiBhIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxuICovXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XG5cbi8qKlxuICogUm91bmQgbiB0byBkIGRlY2ltYWwgcGxhY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW2Q9MF0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xuICogQHJldHVybiB7bnVtYmVyfSBBIHJvdW5kZWQgbnVtYmVyXG4gKi9cbmNvbnN0IHJvdW5kID0gKG4sIGQgPSAwKSA9PiB7XG4gIGNvbnN0IHAgPSBNYXRoLnBvdygxMCwgZCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKG4gKiBwICsgTnVtYmVyLkVQU0lMT04pIC8gcDtcbn1cblxuLyoqXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxuICovXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XG5cbi8qKlxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYzAwIFRvcC1sZWZ0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMxMSBCb3R0b20tcmlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcbiAqIEByZXR1cm4ge251bWJlcn0gQSBiaWxpbmVhciBpbnRlcnBvbGF0ZWQgdmFsdWVcbiAqL1xuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcblxuLyoqXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIG51bWJlciB0byByZS1tYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxuICogQHBhcmFtIHtudW1iZXJ9IGEyXG4gKiBAcGFyYW0ge251bWJlcn0gYjFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcblxuLyoqXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXG4gKi9cbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xuXG4vKipcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xuXG4vKipcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xuICovXG5jb25zdCBkZWdyZWVzID0gcmFkaWFucyA9PiAoMTgwIC8gTWF0aC5QSSkgKiByYWRpYW5zO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcbiAqL1xuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKi9cbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpZ21hPTAuNV0gVGhlIHN0YW5kYXJkIGRldmlhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcbiAqL1xuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IHNhbXBsZXM7IGktLTspIHtcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIHJldHVybiBtdSArICh0b3RhbCAtIHNhbXBsZXMgLyAyKSAvIChzYW1wbGVzIC8gMikgKiBzaWdtYTtcbn07XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcbiAqL1xuY29uc3QgY2x0UmFuZG9tSW50ID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKG1pbiArIGNsdFJhbmRvbSgwLjUsIDAuNSwgMikgKiAobWF4ICsgMSAtIG1pbikpO1xuXG4vKipcbiAqIFJldHVybiBhIHdlaWdodGVkIHJhbmRvbSBpbnRlZ2VyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcbiAqL1xuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XG4gIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogdG90YWw7XG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcbiAgICB0b3RhbCAtPSB3W24rK107XG4gIH1cbiAgcmV0dXJuIG4gLSAxO1xufTtcblxuLyoqXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXG4gKiBAY2FsbGJhY2sgSW50ZXJwb2xhdGlvbkZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWUsIHNob3VsZCBiZSBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5cbi8qKlxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgQW4gYXJyYXkgb2YgdmFsdWVzIGludGVycG9sYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gKiBAcGFyYW0ge0ludGVycG9sYXRpb25GdW5jdGlvbn0gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbbWluKGEpLCBtYXgoYSldXG4gKi9cbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xuICBjb25zdCBzID0gaSAqIChhLmxlbmd0aCAtIDEpO1xuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxuICovXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XG5cbi8qKlxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXG4gKi9cbmNvbnN0IGZhY3RvcmlhbCA9IGEgPT4ge1xuICBsZXQgcmVzdWx0ID0gMTtcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XG4gICAgcmVzdWx0ICo9IGk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBuIGVsZW1lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtudW1iZXJ9IHJcbiAqIEByZXR1cm4ge251bWJlcn0gblByXG4gKi9cbmNvbnN0IG5wciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSByXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxuICovXG5jb25zdCBuY3IgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb21iaW5hdGlvbnMoWzEsIDIsIDNdLCAyKTtcbiAqIGBgYFxuICpcbiAqIE91dHB1dDpcbiAqIGBgYGpzb25cbiAqIFtcbiAqICAgWzEsIDJdLFxuICogICBbMSwgM10sXG4gKiAgIFsyLCAzXVxuICogXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNob29zZSBpbiBlYWNoIGNvbWJpbmF0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGNvbWJpbmF0aW9uIGFycmF5c1xuICovXG5jb25zdCBjb21iaW5hdGlvbnMgPSAoYSwgcikgPT4ge1xuICBpZiAociA9PT0gMSkge1xuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XG4gIH1cblxuICByZXR1cm4gYS5yZWR1Y2UoXG4gICAgKGFjYywgaXRlbSwgaSkgPT4gW1xuICAgICAgLi4uYWNjLFxuICAgICAgLi4uY29tYmluYXRpb25zKGEuc2xpY2UoaSArIDEpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcbiAgICBdLFxuICAgIFtdXG4gICk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNhcnRlc2lhbiBwcm9kdWN0IG9mIGFycmF5c1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY2FydGVzaWFuKFsxLCAyLCAzXSwgWydhJywgJ2InXSk7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCBcImFcIl0sXG4gKiAgIFsxLCBcImJcIl0sXG4gKiAgIFsyLCBcImFcIl0sXG4gKiAgIFsyLCBcImJcIl0sXG4gKiAgIFszLCBcImFcIl0sXG4gKiAgIFszLCBcImJcIl1cbiAqIF1cbiAqIGBgYFxuICovXG5jb25zdCBjYXJ0ZXNpYW4gPSAoLi4uYXJyKSA9PlxuICBhcnIucmVkdWNlKFxuICAgIChhLCBiKSA9PiBhLmZsYXRNYXAoYyA9PiBiLm1hcChkID0+IFsuLi5jLCBkXSkpLFxuICAgIFtbXV1cbiAgKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xuICogQGNhbGxiYWNrIFRpbWVzRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBhcnJheSBpbmRleFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBsZW5ndGggbiBieSBjYWxsaW5nIGZ1bmN0aW9uIGYoaSkgb24gZWFjaCBlbGVtZW50XG4gKiBAcGFyYW0ge1RpbWVzRnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXk8Kj59XG4gKi9cbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgb2YgaW50ZWdlcnMgMC0+KG4gLSAxKVxuICovXG5jb25zdCByYW5nZSA9IG4gPT4gdGltZXMoaSA9PiBpLCBuKTtcblxuLyoqXG4gKiBaaXAgMiBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn1cbiAqL1xuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xuXG4vKipcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHBvc2l0aXZlbHkvbmVnYXRpdmVseSB3cmFwcGVkIGFycmF5IGluZGV4XG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKi9cbmNvbnN0IGF0ID0gKGEsIGkpID0+IGFbaSA8IDAgPyBhLmxlbmd0aCAtIChNYXRoLmFicyhpICsgMSkgJSBhLmxlbmd0aCkgLSAxIDogaSAlIGEubGVuZ3RoXTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSB3aXRob3V0IHJlbW92aW5nIGl0XG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcmV0dXJuIHsqfSBUaGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKi9cbmNvbnN0IHBlZWsgPSAoYSkgPT4ge1xuICBpZiAoIWEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY2h1bmsgc2l6ZVxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcbiAqL1xuY29uc3QgY2h1bmsgPSAoYSwgbikgPT4gdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XG5cbi8qKlxuICogUmFuZG9tbHkgc2h1ZmZsZSBhIHNoYWxsb3cgY29weSBvZiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxuICovXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcblxuLyoqXG4gKiBGbGF0dGVuIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byB1c2UgZm9yIGNvbmNhdGVuYXRpbmcga2V5c1xuICogQHJldHVybiB7b2JqZWN0fSBBIGZsYXR0ZW5lZCBvYmplY3RcbiAqL1xuY29uc3QgZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAob1trZXldIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBba2V5XTogb1trZXldLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb1trZXldICE9PSAnb2JqZWN0JyB8fCAhb1trZXldKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBvW2tleV0sXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmbGF0dGVuZWQgPSBmbGF0KG9ba2V5XSwgY29uY2F0ZW5hdG9yKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICAuLi5PYmplY3Qua2V5cyhmbGF0dGVuZWQpLnJlZHVjZShcbiAgICAgICAgKGNoaWxkQWNjLCBjaGlsZEtleSkgPT4gKHtcbiAgICAgICAgICAuLi5jaGlsZEFjYyxcbiAgICAgICAgICBbYCR7a2V5fSR7Y29uY2F0ZW5hdG9yfSR7Y2hpbGRLZXl9YF06IGZsYXR0ZW5lZFtjaGlsZEtleV0sXG4gICAgICAgIH0pLFxuICAgICAgICB7fVxuICAgICAgKSxcbiAgICB9O1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIFVuZmxhdHRlbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIGluIGNvbmNhdGVuYXRlZCBrZXlzXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIHVuLWZsYXR0ZW5lZCBvYmplY3RcbiAqL1xuY29uc3QgdW5mbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xuICBsZXQgcmVzdWx0ID0ge30sIHRlbXAsIHN1YnN0cmluZ3MsIHByb3BlcnR5LCBpO1xuXG4gIGZvciAocHJvcGVydHkgaW4gbykge1xuICAgIHN1YnN0cmluZ3MgPSBwcm9wZXJ0eS5zcGxpdChjb25jYXRlbmF0b3IpO1xuICAgIHRlbXAgPSByZXN1bHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoIShzdWJzdHJpbmdzW2ldIGluIHRlbXApKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzdWJzdHJpbmdzW2kgKyAxXSkpIHtcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wID0gdGVtcFtzdWJzdHJpbmdzW2ldXTtcbiAgICB9XG4gICAgdGVtcFtzdWJzdHJpbmdzW3N1YnN0cmluZ3MubGVuZ3RoIC0gMV1dID0gb1twcm9wZXJ0eV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBIHNwbGl0IHByZWRpY2F0ZVxuICogQGNhbGxiYWNrIFNwbGl0UHJlZGljYXRlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFycmF5IHNob3VsZCBzcGxpdCBhdCB0aGlzIGluZGV4XG4gKi9cblxuLyoqXG4gKiBTcGxpdCBhbiBhcnJheSBpbnRvIHN1Yi1hcnJheXMgYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XG4gKiBAcGFyYW0ge1NwbGl0UHJlZGljYXRlfSBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgYXJyYXlzXG4gKi9cbmNvbnN0IHNwbGl0ID0gKGFycmF5LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50ID0gW107XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IFt2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBsdWNrIGtleXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBwbHVjayBmcm9tIHRoZSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBsdWNrZWQga2V5c1xuICovXG5jb25zdCBwbHVjayA9IChvLCAuLi5rZXlzKSA9PiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShcbiAgICAocmVzdWx0LCBrZXkpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvW2tleV0gfSksXG4gICAge31cbiAgKTtcbn07XG5cbi8qKlxuICogRXhjbHVkZSBrZXlzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGtleXMgZXhjZXB0IGV4Y2x1ZGVkIGtleXNcbiAqL1xuY29uc3QgZXhjbHVkZSA9IChvLCAuLi5rZXlzKSA9PiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobykuZmlsdGVyKChba2V5XSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSlcbiAgKTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmbG9hdEVxdWFscyxcbiAgICBjbGFtcCxcbiAgICBmcmFjLFxuICAgIHJvdW5kLFxuICAgIGxlcnAsXG4gICAgdW5sZXJwLFxuICAgIGJsZXJwLFxuICAgIHJlbWFwLFxuICAgIHNtb290aHN0ZXAsXG4gICAgcmFkaWFucyxcbiAgICBkZWdyZWVzLFxuICAgIHJhbmRvbUJldHdlZW4sXG4gICAgcmFuZG9tSW50QmV0d2VlbixcbiAgICBjbHRSYW5kb20sXG4gICAgY2x0UmFuZG9tSW50LFxuICAgIHdlaWdodGVkUmFuZG9tLFxuICAgIGxlcnBBcnJheSxcbiAgICBkb3QsXG4gICAgZmFjdG9yaWFsLFxuICAgIG5wcixcbiAgICBuY3IsXG4gICAgY29tYmluYXRpb25zLFxuICAgIGNhcnRlc2lhbixcbiAgICB0aW1lcyxcbiAgICByYW5nZSxcbiAgICB6aXAsXG4gICAgYXQsXG4gICAgcGVlayxcbiAgICBjaHVuayxcbiAgICBzaHVmZmxlLFxuICAgIGZsYXQsXG4gICAgdW5mbGF0LFxuICAgIHNwbGl0LFxuICAgIHBsdWNrLFxuICAgIGV4Y2x1ZGUsXG4gIH07XG59XG4iLCJjb25zdCB7IHRpbWVzLCBjaHVuaywgZG90IH0gPSByZXF1aXJlKCdAYmFzZW1lbnR1bml2ZXJzZS91dGlscycpO1xuXG4vKipcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXG4gKi9cblxuLyoqXG4gKiBBIDJkIHZlY3RvclxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlY30gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+VmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYygzLCAyKTsgIC8vICgzLCAyKVxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcbiAqIGxldCBjID0gdmVjKGEpOyAgICAgLy8gKDMsIDIpXG4gKiBsZXQgZCA9IHZlYygpOyAgICAgIC8vICgwLCAwKVxuICovXG5jb25zdCB2ZWMgPSAoeCwgeSkgPT4gKCF4ICYmICF5ID9cbiAgeyB4OiAwLCB5OiAwIH0gOiAodHlwZW9mIHggPT09ICdvYmplY3QnID9cbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHsgeDogeCwgeTogeCB9IDogeyB4OiB4LCB5OiB5IH0pXG4gIClcbik7XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxuICovXG52ZWMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcbiAqIEByZXR1cm4ge3ZlY30gQSB1bml0IHZlY3RvciAoMSwgMClcbiAqL1xudmVjLnV4ID0gKCkgPT4gdmVjKDEsIDApO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxuICovXG52ZWMudXkgPSAoKSA9PiB2ZWMoMCwgMSk7XG5cbi8qKlxuICogQWRkIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjfSBhICsgYlxuICovXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcbiAqL1xudmVjLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiBiLCB5OiBhLnkgKiBiIH0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjfSBhIC0gYlxuICovXG52ZWMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xuXG4vKipcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcbiAqIEByZXR1cm4ge3ZlY30gXmFcbiAqL1xudmVjLm5vciA9IGEgPT4ge1xuICBsZXQgbGVuID0gdmVjLmxlbihhKTtcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxuICovXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYy5yb3QgPSAoYSwgcikgPT4ge1xuICBsZXQgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbnZlYy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcbiAqIEByZXR1cm4ge3ZlY30gQSBjb3B5IG9mIHZlY3RvciBhXG4gKi9cbnZlYy5jcHkgPSBhID0+IHZlYyhhKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBjYWxsYmFjayB2ZWN0b3JNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWN0b3JNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcbiAqL1xudmVjLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcblxuLyoqXG4gKiBBIG1hdHJpeFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxuICovXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XG4gIG0sIG4sXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcbn0pO1xuXG4vKipcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxuICovXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xuXG4vKipcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcbiAqL1xubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xuXG4vKipcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxuICovXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XG5cbi8qKlxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxuICovXG5tYXQucm93ID0gKGEsIG0pID0+IHtcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LmNvbCA9IChhLCBuKSA9PiB0aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XG5cbi8qKlxuICogQWRkIG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcbiAqL1xubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXG4gKi9cbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XG5cbi8qKlxuICogTXVsdGlwbHkgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2NhbGUgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxuICogQHJldHVybiB7bWF0fSBhICogYlxuICovXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gdHJhbnNwb3NlXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcbiAqL1xubWF0LnRyYW5zID0gYSA9PiBtYXQoYS5uLCBhLm0sIHRpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xuXG4vKipcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxuICovXG5tYXQubWlub3IgPSAoYSwgaSwgaikgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgZm9yIChsZXQgaWkgPSAxOyBpaSA8PSBhLm07IGlpKyspIHtcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xuICAgICAgaWYgKGpqID09PSBqKSB7IGNvbnRpbnVlOyB9XG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXG4gKi9cbm1hdC5kZXQgPSBhID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYS5tID09PSAxKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcbiAgfVxuICBpZiAoYS5tID09PSAyKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcbiAgfVxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcbiAgICBzaWduICo9IC0xO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxuICovXG5tYXQubm9yID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxuICovXG5tYXQuYWRqID0gYSA9PiB7XG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXG4gKi9cbm1hdC5pbnYgPSBhID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCBkID0gbWF0LmRldChhKTtcbiAgaWYgKGQgPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XG5cbi8qKlxuICogQ29weSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJuIHttYXR9IEEgY29weSBvZiBtYXRyaXggYVxuICovXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxuICogQGNhbGxiYWNrIG1hdHJpeE1hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIGFycmF5IG9mIG1hdHJpeCBlbnRyaWVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcbiAqL1xubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW21zPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciBjb2x1bW5zXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXG4nXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3Igcm93c1xuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdC5zdHIgPSAoYSwgbXMgPSAnLCAnLCBucyA9ICdcXG4nKSA9PiBjaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcbn1cbiIsImNvbnN0IGRlZmF1bHRWZXJ0ZXhTaGFkZXIgPSBgXG4gICNpZmRlZiBHTF9FU1xuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgI2VuZGlmXG4gIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICB2b2lkIG1haW4oKSB7XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gIH1cbmA7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSBgXG4gICNpZmRlZiBHTF9FU1xuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgI2VuZGlmXG4gIHZvaWQgbWFpbigpIHtcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XG4gIH1cbmA7XG5leHBvcnQgY2xhc3MgU2hhZGVyQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZG9tRWxlbWVudC5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBnZXQgd2ViZ2wgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgaWYgKCF2cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdnM7XG4gICAgICAgIGNvbnN0IHZzRXJycyA9IGNvbXBpbGVTaGFkZXIodGhpcy5nbCwgdGhpcy52ZXJ0ZXhTaGFkZXIsIGRlZmF1bHRWZXJ0ZXhTaGFkZXIpO1xuICAgICAgICBpZiAodnNFcnJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZzID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICBpZiAoIWZzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGZyYWdtZW50IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnM7XG4gICAgICAgIGNvbnN0IGZzRXJycyA9IGNvbXBpbGVTaGFkZXIodGhpcy5nbCwgdGhpcy5mcmFnbWVudFNoYWRlciwgZGVmYXVsdEZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgaWYgKGZzRXJycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYWRlclByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKHRoaXMuZ2wsIHRoaXMudmVydGV4U2hhZGVyLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgYmluZFBvc2l0aW9uQXR0cmlidXRlKHRoaXMuZ2wsIHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKDQwMCwgNDAwKTtcbiAgICB9XG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5kb21FbGVtZW50LndpZHRoLCB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0KTtcbiAgICB9XG4gICAgLy8gZ2V0UmVzb2x1dGlvbiBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZ2V0dGluZyBhIHZlYzIgcmVwcmVzZW50aW5nIHRoZVxuICAgIC8vIHNpemUgaW4gcGh5c2ljYWwgcGl4ZWxzIG9mIHRoZSBjYW52YXMuXG4gICAgLy8gVHlwaWNhbCB1c2FnZSBpczpcbiAgICAvLyAgIHNoYWRlckNhbnZhcy5zZXRVbmlmb3JtKFwidV9yZXNvbHV0aW9uXCIsIHNoYWRlckNhbnZhcy5nZXRSZXNvbHV0aW9uKCkpO1xuICAgIGdldFJlc29sdXRpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzZXRTaGFkZXIoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgY29uc3QgZXJycyA9IGNvbXBpbGVTaGFkZXIoZ2wsIHRoaXMuZnJhZ21lbnRTaGFkZXIsIHNvdXJjZSk7XG4gICAgICAgIGlmIChlcnJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJycztcbiAgICAgICAgfVxuICAgICAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLnNoYWRlclByb2dyYW0pO1xuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5zaGFkZXJQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5zaGFkZXJQcm9ncmFtKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gbGluayBwcm9ncmFtXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRlc3RVbmlmb3JtKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIG5hbWUpO1xuICAgICAgICByZXR1cm4gbG9jYXRpb24gIT09IG51bGw7XG4gICAgfVxuICAgIHNldFVuaWZvcm0obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgbmFtZT9cbiAgICAgICAgLy8gVE9ETyBPUFRJTUlaRTogY2FjaGUgdW5pZm9ybSBsb2NhdGlvblxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmlmb3JtIGxvY2F0aW9uIGZvciAke25hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBhY2NlcHQgb3B0aW9ucywgbGlrZSBmb3JtYXQsIGZpbHRlciwgd3JhcCwgZXRjLlxuICAgIHNldFRleHR1cmUobmFtZSwgaW1hZ2UpIHtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgbmFtZT9cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBsZXQgdCA9IHRoaXMudGV4dHVyZXNbbmFtZV07XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgY29uc3QgZ2xUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgaWYgKCFnbFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBjcmVhdGUgZ2xUZXh0dXJlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0ge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZSxcbiAgICAgICAgICAgICAgICB1bml0OiBsb3dlc3RVbnVzZWQoT2JqZWN0LmtleXModGhpcy50ZXh0dXJlcykubWFwKChrKSA9PiB0aGlzLnRleHR1cmVzW2tdLnVuaXQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzW25hbWVdID0gdDtcbiAgICAgICAgfVxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdC51bml0KTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdC5nbFRleHR1cmUpO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAxKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmlmb3JtIGxvY2F0aW9uIGZvciB0ZXh0dXJlICR7bmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0LnVuaXQpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlciwgc291cmNlKSB7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBjb21waWxlLCBidXQgZm91bmQgbm8gZXJyb3IgbG9nXCIpO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGluZm8pO1xuICAgIHJldHVybiBwYXJzZUVycm9yTWVzc2FnZXMoaW5mbyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCB2cywgZnMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGlmIChwcm9ncmFtID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgc2hhZGVyIHByb2dyYW1cIik7XG4gICAgfVxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2cyk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZzKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihpbmZvKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGxpbmsgcHJvZ3JhbVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG59XG5mdW5jdGlvbiBiaW5kUG9zaXRpb25BdHRyaWJ1dGUoZ2wsIHByb2dyYW0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgLTEuMCwgLTEuMCxcbiAgICAgICAgLTEuMCwgMS4wLFxuICAgICAgICAxLjAsIC0xLjAsXG4gICAgICAgIDEuMCwgMS4wLFxuICAgIF0pO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbnMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBjb25zdCBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJwb3NpdGlvblwiKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG59XG5mdW5jdGlvbiBwYXJzZUVycm9yTWVzc2FnZXMobXNnKSB7XG4gICAgY29uc3QgZXJyb3JSZWdleCA9IC9eRVJST1I6IFxcZCs6KFxcZCspLiokL21nO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgbGV0IG1hdGNoID0gZXJyb3JSZWdleC5leGVjKG1zZyk7XG4gICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0sXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9vayBmb3IgYW5vdGhlciBlcnJvcjpcbiAgICAgICAgbWF0Y2ggPSBlcnJvclJlZ2V4LmV4ZWMobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuLy8gVGhpcyBpcyBhIGZsYXZvciBvZiBTaGxlbWllbCB0aGUgcGFpbnRlcidzIGFsZ29yaXRobS5cbi8vIGh0dHA6Ly93aWtpLmMyLmNvbS8/U2hsZW1pZWxUaGVQYWludGVyXG4vL1xuLy8gVE9ETzogZmlndXJlIG91dCBob3cgdG8gcnVuIHRlc3RzLCBidXQgSSd2ZSBzcG90IGNoZWNrZWQgdGhlc2U6XG4vLyAgIFtdID0+IDBcbi8vICAgWzAsIDEsIDIsIDMsIDRdID0+IDVcbi8vICAgWzAsIDEsIDMsIDRdID0+IDJcbi8vICAgWzEsIDMsIDRdID0+IDBcbi8vICAgWzRdID0+IDBcbi8vICAgWzQsIDMsIDIsIDEsIDBdID0+IDVcbi8vICAgWzQsIDIsIDEsIDBdID0+IDNcbi8vICAgWzQsIDIsIDEsIDEwXSA9PiAwXG4vLyAgIFsyLCAwLCAzLCA0XSA9PiAxXG5mdW5jdGlvbiBsb3dlc3RVbnVzZWQoeHMpIHtcbiAgICBsZXQgdW51c2VkID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0gdW51c2VkKSB7XG4gICAgICAgICAgICB1bnVzZWQrKztcbiAgICAgICAgICAgIGkgPSAtMTsgLy8gZ28gYmFjayB0byB0aGUgYmVnaW5uaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVudXNlZDtcbn1cbiIsImltcG9ydCB7IHZlYyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3ZlYyc7XG5pbXBvcnQgQ29udGVudE1hbmFnZXIsIHsgQ29udGVudFByb2Nlc3NvciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgRGVidWcgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgTG9hZGluZ1NjZW5lIGZyb20gJy4vc2NlbmVzL0xvYWRpbmdTY2VuZSc7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi9jb25maWcuanNvbic7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgU2hhZGVyUHJvY2Vzc29yIH0gZnJvbSAnLi9jb250ZW50LXByb2Nlc3NvcnMvc2hhZGVyLmNvbnRlbnQtcHJvY2Vzc29yJztcbmltcG9ydCB7IHRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS90ZXh0dXJlLWF0bGFzJztcbmltcG9ydCB7IHRpbGVNYXBPcHRpb25zQ29udGVudFByb2Nlc3NvciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwJztcbmltcG9ydCB7IHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZSB7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcblxuICBwcml2YXRlIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcblxuICBwcml2YXRlIGxhc3RGcmFtZUNvdW50VGltZTogbnVtYmVyO1xuXG4gIHByaXZhdGUgZnJhbWVSYXRlOiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgZnJhbWVDb3VudDogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgc3RhdGljIHNjcmVlbjogdmVjO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCkge1xuICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSB2YWxpZCBjb250YWluZXIgZWxlbWVudCBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdjYW52YXMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRhaW5lciBlbGVtZW50IG11c3QgYmUgYSBjYW52YXMuJyk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzID0gY29udGFpbmVyIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuXG4gICAgLy8gR2V0IGEgMmQgY29udGV4dFxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBnZXQgYSAyZCBjb250ZXh0LlwiKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVzaXplXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNpemUoKSB7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZSgpIHtcbiAgICAvLyBJbml0aWFsaXNlIHN1YnN5c3RlbXNcbiAgICBDb250ZW50TWFuYWdlci5pbml0aWFsaXNlKHtcbiAgICAgIHNpbXVsYXRlU2xvd0xvYWRpbmc6IGNvbnN0YW50cy5ERUJVRyxcbiAgICAgIHNsb3dMb2FkaW5nVGltZU1pbjogMTAwLFxuICAgICAgc2xvd0xvYWRpbmdUaW1lTWF4OiA1MDAsXG4gICAgICBwcm9jZXNzb3JzOiB7XG4gICAgICAgIHNoYWRlcjogU2hhZGVyUHJvY2Vzc29yLFxuICAgICAgICB0ZXh0dXJlQXRsYXM6IHRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IgYXMgdW5rbm93biBhcyBDb250ZW50UHJvY2Vzc29yLFxuICAgICAgICB0aWxlTWFwOiB0aWxlTWFwT3B0aW9uc0NvbnRlbnRQcm9jZXNzb3IgYXMgdW5rbm93biBhcyBDb250ZW50UHJvY2Vzc29yLFxuICAgICAgICBzcHJpdGU6IHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yIGFzIHVua25vd24gYXMgQ29udGVudFByb2Nlc3NvcixcbiAgICAgIH0sXG4gICAgICB0aHJvd09uTm90Rm91bmQ6IHRydWUsXG4gICAgfSk7XG4gICAgRGVidWcuaW5pdGlhbGlzZSh7XG4gICAgICBsaW5lTWFyZ2luOiA1LFxuICAgIH0pO1xuICAgIElucHV0TWFuYWdlci5pbml0aWFsaXNlKCk7XG4gICAgU2NlbmVNYW5hZ2VyLmluaXRpYWxpc2UoKTtcblxuICAgIC8vIFN0YXJ0IGdhbWUgbG9vcFxuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRoaXMubGFzdEZyYW1lQ291bnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5sb29wKCk7XG5cbiAgICAvLyBQdXNoIHRoZSBpbml0aWFsIHNjZW5lXG4gICAgU2NlbmVNYW5hZ2VyLnB1c2gobmV3IExvYWRpbmdTY2VuZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9vcCgpIHtcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IE1hdGgubWluKG5vdyAtIHRoaXMubGFzdEZyYW1lVGltZSwgY29uc3RhbnRzLkZQU19NSU4pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGZyYW1lcmF0ZVxuICAgIGlmIChub3cgLSB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA+PSAxMDAwKSB7XG4gICAgICB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA9IG5vdztcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5mcmFtZUNvdW50O1xuICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gbm93O1xuICAgIGlmIChjb25maWcuc2hvd0ZQUykge1xuICAgICAgRGVidWcudmFsdWUoJ0ZQUycsIHRoaXMuZnJhbWVSYXRlLCB7IGFsaWduOiAncmlnaHQnIH0pO1xuICAgICAgRGVidWcuY2hhcnQoJ0ZQUycsIHRoaXMuZnJhbWVSYXRlLCB7IG1pblZhbHVlOiAwLCBtYXhWYWx1ZTogNzAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gZ2FtZSBsb29wXG4gICAgdGhpcy51cGRhdGUoZWxhcHNlZFRpbWUpO1xuICAgIHRoaXMuZHJhdygpO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5sb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgdXBkYXRlKGR0OiBudW1iZXIpIHtcbiAgICBHYW1lLnNjcmVlbiA9IHZlYyh0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgIERlYnVnLnZhbHVlKCdzdGF0dXMnLCBDb250ZW50TWFuYWdlci5zdGF0dXMpO1xuICAgIERlYnVnLnZhbHVlKCdwcm9ncmVzcycsIENvbnRlbnRNYW5hZ2VyLnByb2dyZXNzKTtcblxuICAgIFNjZW5lTWFuYWdlci51cGRhdGUoZHQpO1xuICAgIElucHV0TWFuYWdlci51cGRhdGUoKTsgIC8vIElucHV0IG1hbmFnZXIgc2hvdWxkIGJlIHVwZGF0ZWQgbGFzdFxuICB9XG5cbiAgZHJhdygpIHtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgU2NlbmVNYW5hZ2VyLmRyYXcodGhpcy5jb250ZXh0KTtcbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBBY3RvciB7XG4gIHVwZGF0ZShkdDogbnVtYmVyKTogdm9pZDtcbiAgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkO1xufVxuIiwiaW1wb3J0IHsgU3ByaXRlLCBTcHJpdGVPcHRpb25zIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlJztcbmltcG9ydCB7IEFjdG9yIH0gZnJvbSAnLi9BY3Rvcic7XG5pbXBvcnQgeyB2ZWMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBQbGF5ZXJEaXJlY3Rpb24gPSAnbicgfCAnbmUnIHwgJ2UnIHwgJ3NlJyB8ICdzJyB8ICdzdycgfCAndycgfCAnbncnO1xuXG5leHBvcnQgY2xhc3MgUGxheWVyIGltcGxlbWVudHMgQWN0b3Ige1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTUEVFRDogbnVtYmVyID0gNDA7XG5cbiAgcHJpdmF0ZSBzcHJpdGU6IFNwcml0ZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHBvc2l0aW9uOiB2ZWMsXG4gICAgcHVibGljIGRpcmVjdGlvbjogUGxheWVyRGlyZWN0aW9uLFxuICAgIHNwcml0ZURhdGE6IFNwcml0ZU9wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBuZXcgU3ByaXRlKHtcbiAgICAgIC4uLnNwcml0ZURhdGEsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGRlZmF1bHREaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG1vdmVWZWN0b3IgPSB2ZWMoKTtcblxuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5RG93bignQXJyb3dVcCcpKSB7XG4gICAgICBtb3ZlVmVjdG9yLnktLTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlEb3duKCdBcnJvd0Rvd24nKSkge1xuICAgICAgbW92ZVZlY3Rvci55Kys7XG4gICAgfVxuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5RG93bignQXJyb3dMZWZ0JykpIHtcbiAgICAgIG1vdmVWZWN0b3IueC0tO1xuICAgIH1cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0Fycm93UmlnaHQnKSkge1xuICAgICAgbW92ZVZlY3Rvci54Kys7XG4gICAgfVxuXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYy5hZGQoXG4gICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgdmVjLm11bChtb3ZlVmVjdG9yLCBQbGF5ZXIuU1BFRUQgKiBkdClcbiAgICApO1xuXG4gICAgdGhpcy5wb3NpdGlvbi54ID0gY2xhbXAodGhpcy5wb3NpdGlvbi54LCAwLCAxMDI0KTtcbiAgICB0aGlzLnBvc2l0aW9uLnkgPSBjbGFtcCh0aGlzLnBvc2l0aW9uLnksIDAsIDEwMjQpO1xuXG4gICAgY29uc3QgbW92aW5nID0gIXZlYy5lcShtb3ZlVmVjdG9yLCB2ZWMoKSk7XG4gICAgaWYgKG1vdmluZykge1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoe1xuICAgICAgICBbJzEsIDAnXTogJ2UnLFxuICAgICAgICBbJzEsIDEnXTogJ3NlJyxcbiAgICAgICAgWycwLCAxJ106ICdzJyxcbiAgICAgICAgWyctMSwgMSddOiAnc3cnLFxuICAgICAgICBbJy0xLCAwJ106ICd3JyxcbiAgICAgICAgWyctMSwgLTEnXTogJ253JyxcbiAgICAgICAgWycwLCAtMSddOiAnbicsXG4gICAgICAgIFsnMSwgLTEnXTogJ25lJyxcbiAgICAgIH1bdmVjLnN0cihtb3ZlVmVjdG9yKV0gPz8gJ3MnKSBhcyBQbGF5ZXJEaXJlY3Rpb247XG4gICAgfVxuXG4gICAgdGhpcy5zcHJpdGUucG9zaXRpb24gPSB2ZWMuY3B5KHRoaXMucG9zaXRpb24pO1xuICAgIHRoaXMuc3ByaXRlLmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xuICAgIHRoaXMuc3ByaXRlLmFuaW1hdGlvbiA9IG1vdmluZyA/ICd3YWxrJyA6ICdpZGxlJztcbiAgICB0aGlzLnNwcml0ZS51cGRhdGUoZHQpO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgdGhpcy5zcHJpdGUuZHJhdyhjb250ZXh0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVjIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7IEFjdG9yIH0gZnJvbSAnLic7XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0JhciBpbXBsZW1lbnRzIEFjdG9yIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRUFTRV9BTU9VTlQgPSAxLjU7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09MT1VSID0gJ3doaXRlJztcblxuICBwdWJsaWMgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XG5cbiAgcHJpdmF0ZSBkaXNwbGF5UHJvZ3Jlc3M6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwb3NpdGlvbjogdmVjLFxuICAgIHB1YmxpYyBzaXplOiB2ZWNcbiAgKSB7fVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIHRoaXMuZGlzcGxheVByb2dyZXNzICs9IChcbiAgICAgIHRoaXMucHJvZ3Jlc3MgLSB0aGlzLmRpc3BsYXlQcm9ncmVzc1xuICAgICkgKiBQcm9ncmVzc0Jhci5FQVNFX0FNT1VOVCAqIGR0O1xuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxheVByb2dyZXNzIC0gdGhpcy5wcm9ncmVzcykgPD0gMC4wMDEpIHtcbiAgICAgIHRoaXMuZGlzcGxheVByb2dyZXNzID0gdGhpcy5wcm9ncmVzcztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBQcm9ncmVzc0Jhci5DT0xPVVI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBQcm9ncmVzc0Jhci5DT0xPVVI7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAyO1xuXG4gICAgY29uc3QgdG9wTGVmdCA9IHZlYy5zdWIoXG4gICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgdmVjLm11bCh0aGlzLnNpemUsIDEgLyAyKVxuICAgICk7XG5cbiAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICB0b3BMZWZ0LngsXG4gICAgICB0b3BMZWZ0LnksXG4gICAgICB0aGlzLnNpemUueCxcbiAgICAgIHRoaXMuc2l6ZS55XG4gICAgKTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KFxuICAgICAgdG9wTGVmdC54LFxuICAgICAgdG9wTGVmdC55LFxuICAgICAgTWF0aC5mbG9vcih0aGlzLmRpc3BsYXlQcm9ncmVzcyAqIHRoaXMuc2l6ZS54KSxcbiAgICAgIHRoaXMuc2l6ZS55XG4gICAgKTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL0FjdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vUGxheWVyJztcbmV4cG9ydCAqIGZyb20gJy4vUHJvZ3Jlc3NCYXInO1xuIiwiZXhwb3J0IGNvbnN0IERFQlVHID0gdHJ1ZTtcbmV4cG9ydCBjb25zdCBGUFNfTUlOID0gMSAvIDMwO1xuIiwiaW1wb3J0IHsgQ29udGVudFByb2Nlc3NvciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgeyBTaGFkZXJDYW52YXMgfSBmcm9tICdzaGFkZXItY2FudmFzJztcblxuZXhwb3J0IGNvbnN0IFNoYWRlclByb2Nlc3NvcjogQ29udGVudFByb2Nlc3NvciA9IGFzeW5jIChcbiAgY29udGVudCxcbiAgaXRlbVxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHNoYWRlckNhbnZhcyA9IG5ldyBTaGFkZXJDYW52YXMoKTtcbiAgc2hhZGVyQ2FudmFzLnNldFNoYWRlcihpdGVtLmNvbnRlbnQgYXMgc3RyaW5nKTtcblxuICAvLyBAdHMtaWdub3JlXG4gIGl0ZW0uY29udGVudCA9IHNoYWRlckNhbnZhcztcbn07XG4iLCJpbXBvcnQgeyB2ZWMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IEdhbWUgZnJvbSAnLi4vR2FtZSc7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgeyBUaWxlTWFwLCBUaWxlTWFwT3B0aW9ucyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwJztcbmltcG9ydCB7IFNwcml0ZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUnO1xuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vYWN0b3JzJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAxO1xuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNUQVJUSU5HX1BPU0lUSU9OOiB2ZWMgPSB2ZWMoNTEyLCA1MTIpO1xuXG4gIHByaXZhdGUgY2FtZXJhOiBDYW1lcmE7XG5cbiAgcHJpdmF0ZSBtYXA6IFRpbGVNYXA7XG5cbiAgcHJpdmF0ZSBwbGF5ZXI6IFBsYXllcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNpdGlvblRpbWU6IEdhbWVTY2VuZS5UUkFOU0lUSU9OX1RJTUUsXG4gICAgICBvblRyYW5zaXRpb25lZE91dDogKCkgPT4ge1xuICAgICAgICBEZWJ1Zy5yZW1vdmVDaGFydCgnQ2FtZXJhIFNjYWxlJyk7XG4gICAgICAgIERlYnVnLnJlbW92ZUNoYXJ0KCdXYXZlJyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGluaXRpYWxpc2UoKSB7XG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKFxuICAgICAgR2FtZVNjZW5lLlNUQVJUSU5HX1BPU0lUSU9OLFxuICAgICAge1xuICAgICAgICBtaW5TY2FsZTogMC41LFxuICAgICAgICBtYXhTY2FsZTogNSxcbiAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IDEwMjQsXG4gICAgICAgICAgYm90dG9tOiAxMDI0LFxuICAgICAgICB9LFxuICAgICAgICBtb3ZlRWFzZUFtb3VudDogMC45NSxcbiAgICAgICAgc2NhbGVFYXNlQW1vdW50OiAwLjk1LFxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jYW1lcmEuc2NhbGVJbW1lZGlhdGUgPSAzO1xuXG4gICAgdGhpcy5tYXAgPSBuZXcgVGlsZU1hcChcbiAgICAgIENvbnRlbnRNYW5hZ2VyLmdldDxUaWxlTWFwT3B0aW9ucz4oJ3RpbGUtbWFwLWRhdGEnKSFcbiAgICApO1xuXG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKFxuICAgICAgR2FtZVNjZW5lLlNUQVJUSU5HX1BPU0lUSU9OLFxuICAgICAgJ3MnLFxuICAgICAgQ29udGVudE1hbmFnZXIuZ2V0PFNwcml0ZU9wdGlvbnM+KCdjaGFyYWN0ZXItc3ByaXRlLWRhdGEnKSFcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlQcmVzc2VkKCdFc2NhcGUnKSkge1xuICAgICAgU2NlbmVNYW5hZ2VyLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChJbnB1dE1hbmFnZXIubW91c2VXaGVlbFVwKCkpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnNjYWxlICs9IDAuMTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5tb3VzZVdoZWVsRG93bigpKSB7XG4gICAgICB0aGlzLmNhbWVyYS5zY2FsZSAtPSAwLjE7XG4gICAgfVxuXG4gICAgRGVidWcuY2hhcnQoXG4gICAgICAnQ2FtZXJhIFNjYWxlJyxcbiAgICAgIHRoaXMuY2FtZXJhLnNjYWxlLFxuICAgICAge1xuICAgICAgICBtaW5WYWx1ZTogMC41LFxuICAgICAgICBtYXhWYWx1ZTogNSxcbiAgICAgICAgYmFyQ29sb3VyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgIGNvbG91cjogJyNmMDAnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgb2Zmc2V0OiAyLjUsXG4gICAgICAgICAgICBjb2xvdXI6ICcjZjUwJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9mZnNldDogNCxcbiAgICAgICAgICAgIGNvbG91cjogJyNmOTAnLFxuICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgRGVidWcuY2hhcnQoXG4gICAgICAnV2F2ZScsXG4gICAgICBNYXRoLnNpbihwZXJmb3JtYW5jZS5ub3coKSAvIDEwMDApICsgMSxcbiAgICAgIHtcbiAgICAgICAgbWluVmFsdWU6IDAsXG4gICAgICAgIG1heFZhbHVlOiAyLFxuICAgICAgICB2YWx1ZUJ1ZmZlclNpemU6IDE1MDAsXG4gICAgICAgIHZhbHVlQnVmZmVyU3RyaWRlOiAzMCxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgRGVidWcuYm9yZGVyKFxuICAgICAgJ3Rlc3QxJyxcbiAgICAgICcnLFxuICAgICAgdmVjKDIwMCksXG4gICAgICB7XG4gICAgICAgIHNwYWNlOiAnc2NyZWVuJyxcbiAgICAgICAgc2l6ZTogdmVjKDIwMCwgMjAwKSxcbiAgICAgICAgYm9yZGVyQ29sb3VyOiAnI2Y4MicsXG4gICAgICAgIGJvcmRlclN0eWxlOiAnZGFzaGVkJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDQsXG4gICAgICB9XG4gICAgKTtcblxuICAgIERlYnVnLmJvcmRlcihcbiAgICAgICd0ZXN0MicsXG4gICAgICAnJyxcbiAgICAgIHZlYygxMDApLFxuICAgICAge1xuICAgICAgICBzcGFjZTogJ3dvcmxkJyxcbiAgICAgICAgcmFkaXVzOiAyMDAsXG4gICAgICAgIGJvcmRlclNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgYm9yZGVyQ29sb3VyOiAnIzVmNScsXG4gICAgICAgIGJvcmRlclN0eWxlOiAnZG90dGVkJyxcbiAgICAgICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgRGVidWcubWFya2VyKFxuICAgICAgJ3BsYXllcicsXG4gICAgICB2ZWMuc3RyKHZlYy5tYXAodGhpcy5wbGF5ZXIucG9zaXRpb24sIE1hdGguZmxvb3IpKSxcbiAgICAgIHZlYy5hZGQodGhpcy5wbGF5ZXIucG9zaXRpb24sIHZlYygwLCAzMCkpLFxuICAgICAge1xuICAgICAgICBtYXJrZXJTdHlsZTogJ3gnLFxuICAgICAgICBtYXJrZXJDb2xvdXI6ICcjZmYwJyxcbiAgICAgICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICAgICAgc2hvd1ZhbHVlOiB0cnVlLFxuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLnBsYXllci51cGRhdGUoZHQpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uID0gdmVjLmNweSh0aGlzLnBsYXllci5wb3NpdGlvbik7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmUpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLnRyYW5zaXRpb25BbW91bnQ7XG4gICAgfVxuXG4gICAgLy8gQmFja2dyb3VuZFxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNjY2MnO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgR2FtZS5zY3JlZW4ueCwgR2FtZS5zY3JlZW4ueSk7XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNhbWVyYS5kcmF3KGNvbnRleHQsIEdhbWUuc2NyZWVuKTtcblxuICAgIC8vIE1hcFxuICAgIHRoaXMubWFwLmRyYXcoY29udGV4dCwgdGhpcy5jYW1lcmEpO1xuXG4gICAgLy8gUGxheWVyXG4gICAgdGhpcy5wbGF5ZXIuZHJhdyhjb250ZXh0KTtcblxuICAgIERlYnVnLmRyYXcoY29udGV4dCk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IEdhbWUgZnJvbSAnLi4vR2FtZSc7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IE1lbnVTY2VuZSBmcm9tICcuL01lbnVTY2VuZSc7XG5pbXBvcnQgQ29udGVudE1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCB7IFNoYWRlckNhbnZhcyB9IGZyb20gJ3NoYWRlci1jYW52YXMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS91dGlscyc7XG5pbXBvcnQgRGVidWcgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRyb1NjZW5lIGV4dGVuZHMgU2NlbmUge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBUUkFOU0lUSU9OX1RJTUU6IG51bWJlciA9IDI7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09PTERPV05fVElNRTogbnVtYmVyID0gODtcblxuICBwcml2YXRlIHNoYWRlcjogU2hhZGVyQ2FudmFzO1xuXG4gIHByaXZhdGUgbG9nbzogSFRNTEltYWdlRWxlbWVudDtcblxuICBwcml2YXRlIHRpbWU6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zaXRpb25UaW1lOiBJbnRyb1NjZW5lLlRSQU5TSVRJT05fVElNRSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXNlKCkge1xuICAgIGNvbnN0IHNoYWRlciA9IENvbnRlbnRNYW5hZ2VyLmdldDxTaGFkZXJDYW52YXM+KCdibHVyLXNoYWRlcicpO1xuICAgIGlmIChzaGFkZXIpIHtcbiAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ28gPSBDb250ZW50TWFuYWdlci5nZXQ8SFRNTEltYWdlRWxlbWVudD4oJ2Jhc2VtZW50LXVuaXZlcnNlJyk7XG4gICAgaWYgKGxvZ28pIHtcbiAgICAgIHRoaXMubG9nbyA9IGxvZ287XG5cbiAgICAgIHRoaXMuc2hhZGVyLnNldFNpemUodGhpcy5sb2dvLndpZHRoLCB0aGlzLmxvZ28uaGVpZ2h0KTtcbiAgICAgIHRoaXMuc2hhZGVyLnNldFRleHR1cmUoJ3VfbWFpblRleCcsIHRoaXMubG9nbyk7XG4gICAgICB0aGlzLnNoYWRlci5zZXRVbmlmb3JtKCd1X3Jlc29sdXRpb24nLCB0aGlzLnNoYWRlci5nZXRSZXNvbHV0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIGlmIChcbiAgICAgIHRoaXMudGltZSA+IEludHJvU2NlbmUuQ09PTERPV05fVElNRSB8fFxuICAgICAgSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoKSB8fFxuICAgICAgSW5wdXRNYW5hZ2VyLm1vdXNlUHJlc3NlZCgpXG4gICAgKSB7XG4gICAgICBTY2VuZU1hbmFnZXIucG9wKCk7XG4gICAgICBTY2VuZU1hbmFnZXIucHVzaChuZXcgTWVudVNjZW5lKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSAhPT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMudHJhbnNpdGlvbkFtb3VudDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaGFkZXIpIHtcbiAgICAgIHRoaXMuc2hhZGVyLnNldFVuaWZvcm0oJ3Vfc2lnbWEnLCAxIC0gdGhpcy50cmFuc2l0aW9uQW1vdW50KTtcbiAgICAgIHRoaXMuc2hhZGVyLnJlbmRlcigpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgIHRoaXMuc2hhZGVyLmRvbUVsZW1lbnQsXG4gICAgICAgIEdhbWUuc2NyZWVuLnggLyAyIC0gdGhpcy5sb2dvLndpZHRoIC8gMixcbiAgICAgICAgR2FtZS5zY3JlZW4ueSAvIDIgLSB0aGlzLmxvZ28uaGVpZ2h0IC8gMixcbiAgICAgICAgdGhpcy5sb2dvLndpZHRoLFxuICAgICAgICB0aGlzLmxvZ28uaGVpZ2h0XG4gICAgICApO1xuICAgIH1cblxuICAgIERlYnVnLmRyYXcoY29udGV4dCk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVjIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBHYW1lIGZyb20gJy4uL0dhbWUnO1xuaW1wb3J0IFNjZW5lTWFuYWdlciwge1xuICBTY2VuZSxcbiAgU2NlbmVUcmFuc2l0aW9uU3RhdGUsXG59IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3NjZW5lLW1hbmFnZXInO1xuaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIGNvbnRlbnQgZnJvbSAnLi4vLi4vY29udGVudC9jb250ZW50Lmpzb24nO1xuaW1wb3J0IEludHJvU2NlbmUgZnJvbSAnLi9JbnRyb1NjZW5lJztcbmltcG9ydCB7IFByb2dyZXNzQmFyIH0gZnJvbSAnLi4vYWN0b3JzJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRpbmdTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAwLjU7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09PTERPV05fVElNRTogbnVtYmVyID0gMi41O1xuXG4gIHByaXZhdGUgZmluaXNoZWRMb2FkaW5nQ29udGVudDogYm9vbGVhbjtcblxuICBwcml2YXRlIHByb2dyZXNzQmFyOiBQcm9ncmVzc0JhcjtcblxuICBwcml2YXRlIGNvb2xkb3duVGltZTogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNpdGlvblRpbWU6IExvYWRpbmdTY2VuZS5UUkFOU0lUSU9OX1RJTUUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmZpbmlzaGVkTG9hZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnByb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKFxuICAgICAgdmVjLm1hcCh2ZWMubXVsKEdhbWUuc2NyZWVuLCAxIC8gMiksIE1hdGguZmxvb3IpLFxuICAgICAgdmVjKDIwMCwgNDApXG4gICAgKTtcbiAgICB0aGlzLmNvb2xkb3duVGltZSA9IExvYWRpbmdTY2VuZS5DT09MRE9XTl9USU1FO1xuXG4gICAgQ29udGVudE1hbmFnZXIubG9hZChjb250ZW50KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nQ29udGVudCA9IHRydWU7XG4gICAgfSkuY2F0Y2goKGVycm9yOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0YW50cy5ERUJVRyAmJiBjb25zb2xlLmxvZyhgVW5hYmxlIHRvIGxvYWQgY29udGVudDogJHtlcnJvcn1gKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIucG9zaXRpb24gPSB2ZWMubWFwKHZlYy5tdWwoR2FtZS5zY3JlZW4sIDEgLyAyKSwgTWF0aC5mbG9vcik7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5wcm9ncmVzcyA9IENvbnRlbnRNYW5hZ2VyLnByb2dyZXNzO1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIudXBkYXRlKGR0KTtcblxuICAgIGlmICh0aGlzLmZpbmlzaGVkTG9hZGluZ0NvbnRlbnQpIHtcbiAgICAgIHRoaXMuY29vbGRvd25UaW1lIC09IGR0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvb2xkb3duVGltZSA8PSAwKSB7XG4gICAgICBTY2VuZU1hbmFnZXIucG9wKCk7XG4gICAgICBTY2VuZU1hbmFnZXIucHVzaChuZXcgSW50cm9TY2VuZSgpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSAhPT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMudHJhbnNpdGlvbkFtb3VudDtcbiAgICB9XG5cbiAgICB0aGlzLnByb2dyZXNzQmFyLmRyYXcoY29udGV4dCk7XG5cbiAgICBEZWJ1Zy5kcmF3KGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsImltcG9ydCBHYW1lIGZyb20gJy4uL0dhbWUnO1xuaW1wb3J0IFNjZW5lTWFuYWdlciwge1xuICBTY2VuZSxcbiAgU2NlbmVUcmFuc2l0aW9uU3RhdGUsXG59IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3NjZW5lLW1hbmFnZXInO1xuaW1wb3J0IHsgdmVjIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7IGxlcnAgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS91dGlscyc7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgR2FtZVNjZW5lIGZyb20gJy4vR2FtZVNjZW5lJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudVNjZW5lIGV4dGVuZHMgU2NlbmUge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBUUkFOU0lUSU9OX1RJTUU6IG51bWJlciA9IDE7XG5cbiAgcHJpdmF0ZSBiYWNrZ3JvdW5kOiBIVE1MSW1hZ2VFbGVtZW50O1xuXG4gIHByaXZhdGUgdGl0bGU6IEhUTUxJbWFnZUVsZW1lbnQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zaXRpb25UaW1lOiBNZW51U2NlbmUuVFJBTlNJVElPTl9USU1FLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGluaXRpYWxpc2UoKSB7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IENvbnRlbnRNYW5hZ2VyLmdldDxIVE1MSW1hZ2VFbGVtZW50PignbWVudS1iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGl0bGUgPSBDb250ZW50TWFuYWdlci5nZXQ8SFRNTEltYWdlRWxlbWVudD4oJ21lbnUtdGl0bGUnKTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIpIHtcbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoKSB8fCBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKCkpIHtcbiAgICAgIFNjZW5lTWFuYWdlci5wdXNoKG5ldyBHYW1lU2NlbmUoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblN0YXRlICE9PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy50cmFuc2l0aW9uQW1vdW50O1xuICAgIH1cblxuICAgIC8vIEJhY2tncm91bmRcbiAgICBjb25zdCBsYXJnZXN0U2NyZWVuRGltZW5zaW9uID0gTWF0aC5tYXgoR2FtZS5zY3JlZW4ueCwgR2FtZS5zY3JlZW4ueSk7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB0aGlzLmJhY2tncm91bmQud2lkdGggLyB0aGlzLmJhY2tncm91bmQuaGVpZ2h0O1xuICAgIGNvbnN0IGJhY2tncm91bmRTaXplID0gdmVjKFxuICAgICAgbGFyZ2VzdFNjcmVlbkRpbWVuc2lvbiAqIGFzcGVjdFJhdGlvLFxuICAgICAgbGFyZ2VzdFNjcmVlbkRpbWVuc2lvblxuICAgICk7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCxcbiAgICAgICAgR2FtZS5zY3JlZW4ueCAvIDIgLSBiYWNrZ3JvdW5kU2l6ZS54IC8gMixcbiAgICAgICAgR2FtZS5zY3JlZW4ueSAvIDIgLSBiYWNrZ3JvdW5kU2l6ZS55IC8gMixcbiAgICAgICAgbGFyZ2VzdFNjcmVlbkRpbWVuc2lvbiAqIGFzcGVjdFJhdGlvLFxuICAgICAgICBsYXJnZXN0U2NyZWVuRGltZW5zaW9uXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFRpdGxlXG4gICAgaWYgKHRoaXMudGl0bGUpIHtcbiAgICAgIGNvbnN0IHkgPSBsZXJwKFxuICAgICAgICAtdGhpcy50aXRsZS5oZWlnaHQsXG4gICAgICAgIEdhbWUuc2NyZWVuLnkgLyAyIC0gdGhpcy50aXRsZS5oZWlnaHQgLyAyLFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25BbW91bnRcbiAgICAgICk7XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0aGlzLnRpdGxlLFxuICAgICAgICBHYW1lLnNjcmVlbi54IC8gMiAtIHRoaXMudGl0bGUud2lkdGggLyAyLFxuICAgICAgICB5XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCBHYW1lIGZyb20gJy4vR2FtZSc7XG5cbndpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gIGNvbnN0IGdhbWUgPSBuZXcgR2FtZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FtZScpKTtcbiAgZ2FtZS5pbml0aWFsaXNlKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9