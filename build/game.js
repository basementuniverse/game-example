/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/camera/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/camera/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : a > max ? max : a;\n}\nclass Camera {\n    constructor(position, options) {\n        this.size = (0, vec_1.vec2)();\n        this._actualPosition = (0, vec_1.vec2)();\n        this.targetPosition = (0, vec_1.vec2)();\n        this._actualScale = 1;\n        this.targetScale = 1;\n        this._actualPosition = position;\n        this.targetPosition = position;\n        this.options = Object.assign({}, Camera.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n    }\n    get position() {\n        return this.targetPosition;\n    }\n    set position(value) {\n        this.targetPosition = value;\n    }\n    set positionImmediate(value) {\n        this._actualPosition = value;\n        this.targetPosition = value;\n    }\n    get actualPosition() {\n        return this._actualPosition;\n    }\n    get scale() {\n        return this.targetScale;\n    }\n    get actualScale() {\n        return this._actualScale;\n    }\n    set scale(value) {\n        this.targetScale = clamp(value, this.options.minScale, this.options.maxScale);\n    }\n    set scaleImmediate(value) {\n        this._actualScale = clamp(value, this.options.minScale, this.options.maxScale);\n        this.targetScale = this._actualScale;\n    }\n    /**\n     * Get screen bounds based on the current camera position and scale\n     */\n    get bounds() {\n        return {\n            top: this._actualPosition.y - this.size.y / 2 / this._actualScale,\n            bottom: this._actualPosition.y + this.size.y / 2 / this._actualScale,\n            left: this._actualPosition.x - this.size.x / 2 / this._actualScale,\n            right: this._actualPosition.x + this.size.x / 2 / this._actualScale,\n        };\n    }\n    /**\n     * Convert a screen position to a world position\n     */\n    screenToWorld(position) {\n        const bounds = this.bounds;\n        return vec_1.vec2.add({ x: bounds.left, y: bounds.top }, vec_1.vec2.mul(position, 1 / this.actualScale));\n    }\n    /**\n     * Convert a world position to a screen position\n     */\n    worldToScreen(position) {\n        const bounds = this.bounds;\n        return vec_1.vec2.mul(vec_1.vec2.sub(position, { x: bounds.left, y: bounds.top }), this.actualScale);\n    }\n    /**\n     * Update the camera\n     */\n    update(screen) {\n        this.size = (0, vec_1.vec2)(screen);\n        // Maybe clamp position to bounds\n        if (this.options.bounds) {\n            const screenScaled = vec_1.vec2.map(vec_1.vec2.mul(this.size, 1 / this._actualScale), Math.ceil);\n            // If the scaled screen size is larger than allowed bounds, we resize\n            // the bounds to prevent jittering\n            const actualBounds = {\n                ...this.options.bounds,\n            };\n            if (screenScaled.x > actualBounds.right - actualBounds.left) {\n                const boundsWidth = actualBounds.right - actualBounds.left;\n                const halfDiff = (screenScaled.x - boundsWidth) / 2;\n                actualBounds.left -= halfDiff;\n                actualBounds.right += halfDiff;\n            }\n            if (screenScaled.y > actualBounds.bottom - actualBounds.top) {\n                const boundsHeight = actualBounds.bottom - actualBounds.top;\n                const halfDiff = (screenScaled.y - boundsHeight) / 2;\n                actualBounds.top -= halfDiff;\n                actualBounds.bottom += halfDiff;\n            }\n            const halfScreenScaled = vec_1.vec2.map(vec_1.vec2.mul(screenScaled, 1 / 2), Math.ceil);\n            const minPosition = (0, vec_1.vec2)(actualBounds.left + halfScreenScaled.x, actualBounds.top + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec2)(actualBounds.right - halfScreenScaled.x, actualBounds.bottom - halfScreenScaled.y);\n            this.targetPosition.x = clamp(this.targetPosition.x, minPosition.x, maxPosition.x);\n            this.targetPosition.y = clamp(this.targetPosition.y, minPosition.y, maxPosition.y);\n        }\n        const d = vec_1.vec2.sub(this._actualPosition, this.targetPosition);\n        this._actualPosition = vec_1.vec2.add(this.position, vec_1.vec2.mul(d, this.options.moveEaseAmount));\n        const s = clamp(this.targetScale, this.options.minScale, this.options.maxScale);\n        this._actualScale =\n            s + (this._actualScale - s) * this.options.scaleEaseAmount;\n    }\n    /**\n     * Set the camera transforms on a canvas context\n     */\n    setTransforms(context) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.translate(this.size.x / 2 - this._actualPosition.x * this._actualScale, this.size.y / 2 - this._actualPosition.y * this._actualScale);\n        context.scale(this._actualScale, this._actualScale);\n    }\n    /**\n     * Update the camera and then set transforms on a canvas context\n     */\n    draw(context, screen) {\n        this.update(screen);\n        this.setTransforms(context);\n    }\n}\nexports[\"default\"] = Camera;\nCamera.DEFAULT_OPTIONS = {\n    allowScale: true,\n    minScale: 0.5,\n    maxScale: 4,\n    moveEaseAmount: 0.1,\n    scaleEaseAmount: 0.1,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_33452__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_33452__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_33452__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/content-manager/build/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@basementuniverse/content-manager/build/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content-loaders/audio.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/audio.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AudioLoader = void 0;\nconst AudioLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const audio = new Audio(url);\n        audio.addEventListener('loadeddata', () => {\n            resolve(audio);\n        });\n        audio.addEventListener('error', () => {\n            reject(`Error loading audio \"${url}\"`);\n        });\n    });\n};\nexports.AudioLoader = AudioLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/audio.loader.ts?");

/***/ }),

/***/ "./content-loaders/font.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/font.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FontLoader = void 0;\nconst FontLoader = async (url, family) => {\n    return new Promise((resolve, reject) => {\n        const font = new FontFace(family, `url(${url})`);\n        font\n            .load()\n            .then(font => {\n            document.fonts.add(font);\n            resolve(font);\n        })\n            .catch(() => {\n            reject(`Error loading font \"${url}\"`);\n        });\n    });\n};\nexports.FontLoader = FontLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/font.loader.ts?");

/***/ }),

/***/ "./content-loaders/image.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/image.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageLoader = void 0;\nconst ImageLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.src = url;\n        image.addEventListener('load', () => {\n            resolve(image);\n        });\n        image.addEventListener('error', () => {\n            reject(`Error loading image \"${url}\"`);\n        });\n    });\n};\nexports.ImageLoader = ImageLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/image.loader.ts?");

/***/ }),

/***/ "./content-loaders/index.ts":
/*!**********************************!*\
  !*** ./content-loaders/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./audio.loader */ \"./content-loaders/audio.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./font.loader */ \"./content-loaders/font.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./image.loader */ \"./content-loaders/image.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./json.loader */ \"./content-loaders/json.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./text.loader */ \"./content-loaders/text.loader.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/index.ts?");

/***/ }),

/***/ "./content-loaders/json.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/json.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONLoader = void 0;\nconst JSONLoader = async (urlOrData) => {\n    if (typeof urlOrData === 'string' && urlOrData.startsWith('url:')) {\n        const url = urlOrData.substring(4);\n        return new Promise((resolve, reject) => {\n            window\n                .fetch(url, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'application/json;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.json();\n            })\n                .then(json => {\n                resolve(json);\n            })\n                .catch(() => {\n                reject(`Error loading json \"${urlOrData}\"`);\n            });\n        });\n    }\n    return urlOrData;\n};\nexports.JSONLoader = JSONLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/json.loader.ts?");

/***/ }),

/***/ "./content-loaders/text.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/text.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextLoader = void 0;\nconst TextLoader = async (urlOrText) => {\n    if (urlOrText.startsWith('url:')) {\n        const url = urlOrText.substring(4);\n        return new Promise((resolve, reject) => {\n            window\n                .fetch(url, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'text/plain;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.text();\n            })\n                .then(data => {\n                resolve(data);\n            })\n                .catch(() => {\n                reject(`Error loading text \"${urlOrText}\"`);\n            });\n        });\n    }\n    return urlOrText.toString();\n};\nexports.TextLoader = TextLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/text.loader.ts?");

/***/ }),

/***/ "./content-processors/image-name.processor.ts":
/*!****************************************************!*\
  !*** ./content-processors/image-name.processor.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageNameProcessor = void 0;\nconst defaultOptions = {\n    imageNameFieldName: 'imageName',\n    imageFieldName: 'image',\n};\nconst ImageNameProcessor = async (content, item, options) => {\n    const actualOptions = Object.assign({}, defaultOptions, options !== null && options !== void 0 ? options : {});\n    if (typeof item.content === 'object' && item.content !== null) {\n        const processObject = (o) => {\n            var _a;\n            for (const key in o) {\n                if (key === actualOptions.imageNameFieldName) {\n                    const imageName = o[key];\n                    const imageItem = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n                    if (imageItem) {\n                        o[actualOptions.imageFieldName] = imageItem;\n                        delete o[key];\n                    }\n                }\n                else if (typeof o[key] === 'object' &&\n                    o[key] !== null) {\n                    processObject(o[key]);\n                }\n            }\n        };\n        processObject(item.content);\n    }\n};\nexports.ImageNameProcessor = ImageNameProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/image-name.processor.ts?");

/***/ }),

/***/ "./content-processors/index.ts":
/*!*************************************!*\
  !*** ./content-processors/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./image-name.processor */ \"./content-processors/image-name.processor.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/index.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentItemStatus = exports.ContentManagerStatus = exports.ContentItemType = void 0;\nconst content_loaders_1 = __webpack_require__(/*! ./content-loaders */ \"./content-loaders/index.ts\");\nconst content_processors_1 = __webpack_require__(/*! ./content-processors */ \"./content-processors/index.ts\");\nvar ContentItemType;\n(function (ContentItemType) {\n    ContentItemType[\"JSON\"] = \"json\";\n    ContentItemType[\"Font\"] = \"font\";\n    ContentItemType[\"Image\"] = \"image\";\n    ContentItemType[\"Audio\"] = \"audio\";\n    ContentItemType[\"Text\"] = \"text\";\n})(ContentItemType = exports.ContentItemType || (exports.ContentItemType = {}));\nvar ContentManagerStatus;\n(function (ContentManagerStatus) {\n    ContentManagerStatus[\"Idle\"] = \"idle\";\n    ContentManagerStatus[\"Loading\"] = \"loading\";\n    ContentManagerStatus[\"Processing\"] = \"processing\";\n    ContentManagerStatus[\"Ready\"] = \"ready\";\n})(ContentManagerStatus = exports.ContentManagerStatus || (exports.ContentManagerStatus = {}));\nvar ContentItemStatus;\n(function (ContentItemStatus) {\n    ContentItemStatus[\"Idle\"] = \"idle\";\n    ContentItemStatus[\"Loading\"] = \"loading\";\n    ContentItemStatus[\"Loaded\"] = \"loaded\";\n    ContentItemStatus[\"Processing\"] = \"processing\";\n    ContentItemStatus[\"Processed\"] = \"processed\";\n})(ContentItemStatus = exports.ContentItemStatus || (exports.ContentItemStatus = {}));\nconst defaultContentLoaders = {\n    [ContentItemType.JSON]: content_loaders_1.JSONLoader,\n    [ContentItemType.Font]: content_loaders_1.FontLoader,\n    [ContentItemType.Image]: content_loaders_1.ImageLoader,\n    [ContentItemType.Audio]: content_loaders_1.AudioLoader,\n    [ContentItemType.Text]: content_loaders_1.TextLoader,\n};\nconst defaultContentProcessors = {\n    imageName: content_processors_1.ImageNameProcessor,\n};\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : a > max ? max : a;\n}\nfunction randomBetween(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst MIN_SLEEP_TIME = 1000;\nconst MAX_SLEEP_TIME = 3000;\nclass ContentManager {\n    constructor(options) {\n        var _a, _b, _c;\n        this.currentContentList = [];\n        this.currentProgress = 0;\n        this.currentTotalProgress = 0;\n        this.content = {};\n        this.status = ContentManagerStatus.Idle;\n        this.options = Object.assign({}, ContentManager.defaultOptions, options !== null && options !== void 0 ? options : {}, {\n            loaders: {\n                ...ContentManager.defaultOptions.loaders,\n                ...((_a = options === null || options === void 0 ? void 0 : options.loaders) !== null && _a !== void 0 ? _a : {}),\n            },\n            processors: {\n                ...((_b = ContentManager.defaultOptions.processors) !== null && _b !== void 0 ? _b : {}),\n                ...((_c = options === null || options === void 0 ? void 0 : options.processors) !== null && _c !== void 0 ? _c : {}),\n            },\n        });\n    }\n    /**\n     * Initialise the content manager and provide configuration options\n     */\n    static initialise(options) {\n        if (ContentManager.instance !== undefined) {\n            throw new Error('Content manager already initialised');\n        }\n        ContentManager.instance = new ContentManager(options);\n    }\n    static dispose() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not initialised');\n        }\n        delete ContentManager.instance;\n    }\n    static getInstance() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not properly initialised');\n        }\n        return ContentManager.instance;\n    }\n    /**\n     * Current loading progress, represented as a unit scalar [0, 1]\n     */\n    static get progress() {\n        const instance = ContentManager.getInstance();\n        return instance.getProgress();\n    }\n    /**\n     * Current content manager status\n     */\n    static get status() {\n        const instance = ContentManager.getInstance();\n        return instance.status;\n    }\n    getProgress() {\n        if (!this.currentContentList.length || this.currentTotalProgress === 0) {\n            return 1;\n        }\n        return clamp(this.currentProgress / this.currentTotalProgress);\n    }\n    /**\n     * Load content items\n     *\n     * Existing content items will be retained, and any content items which\n     * already exist will be re-loaded\n     */\n    static async load(items) {\n        var _a, _b, _c, _d, _e;\n        if (!items || items.length === 0) {\n            return;\n        }\n        const instance = ContentManager.getInstance();\n        if (!instance.options.loaders ||\n            Object.keys(instance.options.loaders).length === 0) {\n            throw new Error('No content loaders defined');\n        }\n        instance.currentContentList = items;\n        // Calculate how many tasks we need to perform\n        const countTotalToLoad = items.length;\n        const countTotalToProcess = items.reduce((a, c) => { var _a; return a + ((_a = c.processors) !== null && _a !== void 0 ? _a : []).length; }, 0);\n        instance.currentProgress = 0;\n        instance.currentTotalProgress = countTotalToLoad + countTotalToProcess;\n        // Load items\n        instance.status = ContentManagerStatus.Loading;\n        for (const item of items) {\n            if (!(item.type in instance.options.loaders)) {\n                throw new Error(`No content loader defined for type \"${item.type}\"`);\n            }\n            if (instance.options.simulateSlowLoading) {\n                await sleep(randomBetween((_a = instance.options.slowLoadingTimeMin) !== null && _a !== void 0 ? _a : MIN_SLEEP_TIME, (_b = instance.options.slowLoadingTimeMax) !== null && _b !== void 0 ? _b : MAX_SLEEP_TIME));\n            }\n            const contentItem = {\n                name: item.name,\n                type: item.type,\n                content: null,\n                status: ContentItemStatus.Loading,\n            };\n            instance.content[item.name] = contentItem;\n            contentItem.content = await instance.options.loaders[item.type](...item.args);\n            contentItem.status = ContentItemStatus.Loaded;\n            instance.currentProgress++;\n        }\n        // Process items\n        instance.status = ContentManagerStatus.Processing;\n        for (const item of items) {\n            if (!item.processors || item.processors.length === 0) {\n                continue;\n            }\n            if (!instance.options.processors ||\n                Object.keys(instance.options.processors).length === 0) {\n                throw new Error('No content processors defined');\n            }\n            const contentItem = instance.content[item.name];\n            if (!contentItem) {\n                // We should never reach this point; the item will have been loaded\n                // and added to the instance's content dictionary... but just in case\n                throw new Error(`Cannot find item with name \"${item.name}\"`);\n            }\n            if (instance.options.simulateSlowProcessing) {\n                await sleep(randomBetween((_c = instance.options.slowProcessingTimeMin) !== null && _c !== void 0 ? _c : MIN_SLEEP_TIME, (_d = instance.options.slowProcessingTimeMax) !== null && _d !== void 0 ? _d : MAX_SLEEP_TIME));\n            }\n            contentItem.status = ContentItemStatus.Processing;\n            for (const processor of item.processors) {\n                if (!(processor.name in instance.options.processors)) {\n                    throw new Error(`No content processor defined with name \"${processor.name}\"`);\n                }\n                await instance.options.processors[processor.name](instance.content, contentItem, ...((_e = processor.args) !== null && _e !== void 0 ? _e : []));\n                instance.currentProgress++;\n            }\n            contentItem.status = ContentItemStatus.Processed;\n        }\n        instance.status = ContentManagerStatus.Ready;\n    }\n    /**\n     * Retrieve a content item by name\n     */\n    static get(name) {\n        const instance = ContentManager.getInstance();\n        if (!(name in instance.content)) {\n            if (instance.options.throwOnNotFound) {\n                throw new Error(`Content item \"${name}\" not found`);\n            }\n            return undefined;\n        }\n        return instance.content[name].content;\n    }\n}\nexports[\"default\"] = ContentManager;\nContentManager.defaultOptions = {\n    loaders: defaultContentLoaders,\n    processors: defaultContentProcessors,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_20022__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_20022__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_20022__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/debug/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@basementuniverse/debug/build/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass Debug {\n    constructor(options) {\n        if (options === null || options === void 0 ? void 0 : options.defaultValue) {\n            options.defaultValue = Object.assign({}, Debug.DEFAULT_OPTIONS.defaultValue, options.defaultValue);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultChart) {\n            options.defaultChart = Object.assign({}, Debug.DEFAULT_OPTIONS.defaultChart, options.defaultChart);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultMarker) {\n            options.defaultMarker = Object.assign({}, Debug.DEFAULT_OPTIONS.defaultMarker, options.defaultMarker);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultBorder) {\n            options.defaultBorder = Object.assign({}, Debug.DEFAULT_OPTIONS.defaultBorder, options.defaultBorder);\n        }\n        this.options = Object.assign({}, Debug.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        this.values = new Map();\n        this.charts = new Map();\n        this.markers = new Map();\n        this.borders = new Map();\n    }\n    /**\n     * Initialise the debug renderer for displaying values and markers\n     */\n    static initialise(options = {}) {\n        if (Debug.instance !== undefined) {\n            throw new Error('Debug has already been initialised');\n        }\n        Debug.instance = new Debug(options);\n    }\n    static getInstance() {\n        if (Debug.instance === undefined) {\n            throw new Error('Debug not properly initialised');\n        }\n        return Debug.instance;\n    }\n    /**\n     * Show a debug value\n     */\n    static value(label, value, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.values.set(label, Object.assign({}, instance.options.defaultValue, (_a = instance.values.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value }));\n    }\n    /**\n     * Show a debug chart\n     */\n    static chart(label, value, options) {\n        var _a, _b;\n        const instance = Debug.getInstance();\n        const currentChart = instance.charts.get(label);\n        instance.charts.set(label, Object.assign({}, instance.options.defaultChart, currentChart !== null && currentChart !== void 0 ? currentChart : {}, options !== null && options !== void 0 ? options : {}, {\n            label,\n            values: [...((_a = currentChart === null || currentChart === void 0 ? void 0 : currentChart.values) !== null && _a !== void 0 ? _a : []), value].slice(-((_b = options === null || options === void 0 ? void 0 : options.valueBufferSize) !== null && _b !== void 0 ? _b : instance.options.defaultChart.valueBufferSize)),\n        }));\n    }\n    /**\n     * Remove a debug chart\n     */\n    static removeChart(label) {\n        const instance = Debug.getInstance();\n        instance.charts.delete(label);\n    }\n    /**\n     * Show a marker in world or screen space\n     */\n    static marker(label, value, position, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.markers.set(label, Object.assign({}, instance.options.defaultMarker, (_a = instance.markers.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Show a border in world or screen space\n     */\n    static border(label, value, position, options) {\n        var _a;\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) === 'circle' && (options === null || options === void 0 ? void 0 : options.radius) === undefined) {\n            // Don't add the border if it's circular but we don't have a radius\n            return;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) !== 'circle' && (options === null || options === void 0 ? void 0 : options.size) === undefined) {\n            // Don't add the border if it's rectangular (default is rectangular) but\n            // we don't have a size\n            return;\n        }\n        const instance = Debug.getInstance();\n        instance.borders.set(label, Object.assign({}, instance.options.defaultBorder, (_a = instance.borders.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Render the debug values and markers onto a canvas\n     */\n    static draw(context, tags, clear = true) {\n        const instance = Debug.getInstance();\n        // Draw world-space markers & borders\n        context.save();\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'world') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'world') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Draw values, charts and screen-space markers & borders\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        let position;\n        let leftY = instance.options.margin;\n        let rightY = instance.options.margin;\n        const lineHeight = instance.options.lineHeight + instance.options.padding * 2;\n        instance.values.forEach(value => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (tags && !((_a = value.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (value.align) {\n                case 'left':\n                    position = (0, vec_1.vec2)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec2)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawLabel(context, Debug.prepareLabel((_b = value.label) !== null && _b !== void 0 ? _b : '', (_c = value.value) !== null && _c !== void 0 ? _c : '', value.showLabel, true), position, value.align, (_d = value.padding) !== null && _d !== void 0 ? _d : instance.options.padding, (_e = value.font) !== null && _e !== void 0 ? _e : instance.options.font, (_f = value.foregroundColour) !== null && _f !== void 0 ? _f : instance.options.foregroundColour, (_g = value.backgroundColour) !== null && _g !== void 0 ? _g : instance.options.backgroundColour);\n        });\n        instance.charts.forEach(chart => {\n            var _a, _b, _c, _d, _e, _f;\n            if (tags && !((_a = chart.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (chart.align) {\n                case 'left':\n                    position = (0, vec_1.vec2)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec2)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawChart(context, Debug.prepareLabel((_b = chart.label) !== null && _b !== void 0 ? _b : '', '', chart.showLabel, false), position, chart.align, (_c = chart.padding) !== null && _c !== void 0 ? _c : instance.options.padding, (_d = chart.font) !== null && _d !== void 0 ? _d : instance.options.font, (_e = chart.foregroundColour) !== null && _e !== void 0 ? _e : instance.options.foregroundColour, (_f = chart.backgroundColour) !== null && _f !== void 0 ? _f : instance.options.backgroundColour, chart.chartBackgroundColour, chart.values, chart.valueBufferSize, chart.valueBufferStride, chart.minValue, chart.maxValue, chart.barWidth, chart.barColours);\n        });\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'screen') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'screen') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Clear values, markers & borders ready for next frame\n        if (clear) {\n            instance.values.clear();\n            instance.markers.clear();\n            instance.borders.clear();\n        }\n    }\n    static clear(clearCharts = false) {\n        const instance = Debug.getInstance();\n        instance.values.clear();\n        instance.markers.clear();\n        if (clearCharts) {\n            instance.charts.clear();\n        }\n        instance.borders.clear();\n    }\n    static prepareLabel(label, value, showLabel, showValue) {\n        const actualLabel = showLabel && label ? label : '';\n        const actualValue = !!showValue && value !== '' ? value.toString() : '';\n        const separator = actualLabel && actualValue ? ': ' : '';\n        return `${actualLabel}${separator}${actualValue}`;\n    }\n    drawLabel(context, text, position, align, padding, font, foregroundColour, backgroundColour) {\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const backgroundSize = {\n            width: context.measureText(text).width + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right' ? position.x - backgroundSize.width : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw text\n        context.fillStyle = foregroundColour;\n        context.fillText(text, x, position.y);\n        context.restore();\n    }\n    drawChart(context, label, position, align, padding, font, foregroundColour, backgroundColour, chartBackgroundColour, values, valueBufferSize, valueBufferStride, minValue, maxValue, barWidth, barColours) {\n        var _a, _b;\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const chartSize = {\n            width: barWidth * Math.ceil(valueBufferSize / Math.max(valueBufferStride, 1)),\n            height: this.options.lineHeight + padding * 2,\n        };\n        const labelSize = {\n            width: context.measureText(label).width,\n            height: this.options.lineHeight,\n        };\n        const backgroundSize = {\n            width: labelSize.width + padding + chartSize.width + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right' ? position.x - backgroundSize.width : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw label\n        if (label) {\n            context.fillStyle = foregroundColour;\n            context.fillText(label, x, position.y);\n        }\n        // Draw chart\n        if (chartBackgroundColour) {\n            context.fillStyle = chartBackgroundColour;\n            context.fillRect(x + padding + labelSize.width + padding, position.y - padding, chartSize.width, chartSize.height);\n        }\n        const range = maxValue - minValue;\n        const barOffset = (0, vec_1.vec2)(x + padding + labelSize.width + padding, position.y - padding);\n        for (let i = 0; i < Math.ceil(values.length / Math.max(valueBufferStride, 1)); i++) {\n            let value;\n            if (valueBufferStride <= 1) {\n                value = values[i];\n            }\n            else {\n                value =\n                    values\n                        .slice(i * valueBufferStride, (i + 1) * valueBufferStride)\n                        .reduce((a, b) => a + b, 0) / valueBufferStride;\n            }\n            const barSize = (0, vec_1.vec2)(barWidth, Math.round((chartSize.height * (value - minValue)) / range));\n            const barPosition = vec_1.vec2.add(barOffset, (0, vec_1.vec2)((values.length < valueBufferSize\n                ? Math.ceil((valueBufferSize - values.length) / valueBufferStride) *\n                    barWidth\n                : 0) +\n                i * barWidth, chartSize.height - barSize.y));\n            const barColour = (_b = (barColours\n                ? (_a = [...barColours].reverse().find(c => values[i] >= c.offset)) === null || _a === void 0 ? void 0 : _a.colour\n                : undefined)) !== null && _b !== void 0 ? _b : foregroundColour;\n            context.fillStyle = barColour;\n            context.fillRect(barPosition.x, barPosition.y, barSize.x, barSize.y);\n        }\n        context.restore();\n    }\n    drawMarker(context, marker) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = marker.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec2)();\n        if (marker.showLabel || marker.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = marker.label) !== null && _b !== void 0 ? _b : '', (_c = marker.value) !== null && _c !== void 0 ? _c : '', marker.showLabel, marker.showValue), vec_1.vec2.add(position !== null && position !== void 0 ? position : (0, vec_1.vec2)(), marker.labelOffset), 'left', (_d = marker.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = marker.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = marker.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = marker.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (marker.showMarker) {\n            if (marker.markerImage) {\n                context.drawImage(marker.markerImage, position.x - marker.markerImage.width / 2, position.y - marker.markerImage.height / 2);\n            }\n            else {\n                context.lineWidth = marker.markerLineWidth;\n                context.strokeStyle = context.fillStyle = marker.markerColour;\n                switch (marker.markerStyle) {\n                    case 'x':\n                        this.drawCross(context, position, marker.markerSize);\n                        break;\n                    case '+':\n                        this.drawPlus(context, position, marker.markerSize);\n                        break;\n                    case '.':\n                        this.drawDot(context, position, marker.markerSize);\n                        break;\n                }\n            }\n        }\n        context.restore();\n    }\n    drawCross(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n    }\n    drawPlus(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.stroke();\n    }\n    drawDot(context, position, size) {\n        context.beginPath();\n        context.arc(position.x, position.y, size / 2, 0, Math.PI * 2);\n        context.fill();\n    }\n    drawBorder(context, border) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = border.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec2)();\n        if (border.showLabel || border.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = border.label) !== null && _b !== void 0 ? _b : '', (_c = border.value) !== null && _c !== void 0 ? _c : '', border.showLabel, border.showValue), vec_1.vec2.add(position !== null && position !== void 0 ? position : (0, vec_1.vec2)(), border.labelOffset), 'left', (_d = border.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = border.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = border.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = border.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (border.showBorder) {\n            context.lineWidth = border.borderWidth;\n            context.strokeStyle = context.fillStyle = border.borderColour;\n            switch (border.borderStyle) {\n                case 'solid':\n                    context.setLineDash([]);\n                    break;\n                case 'dashed':\n                    context.setLineDash([border.borderDashSize, border.borderDashSize]);\n                    break;\n                case 'dotted':\n                    context.setLineDash([border.borderWidth, border.borderWidth]);\n                    break;\n            }\n            switch (border.borderShape) {\n                case 'rectangle':\n                    if (border.size) {\n                        this.drawRectangle(context, position, border.size);\n                    }\n                    break;\n                case 'circle':\n                    if (border.radius) {\n                        this.drawCircle(context, position, border.radius);\n                    }\n                    break;\n            }\n        }\n        context.restore();\n    }\n    drawRectangle(context, position, size) {\n        context.beginPath();\n        context.rect(position.x, position.y, size.x, size.y);\n        context.stroke();\n    }\n    drawCircle(context, position, radius) {\n        context.beginPath();\n        context.arc(position.x, position.y, radius, 0, Math.PI * 2);\n        context.stroke();\n    }\n}\nexports[\"default\"] = Debug;\nDebug.DEFAULT_OPTIONS = {\n    margin: 10,\n    padding: 4,\n    font: '10pt Lucida Console, monospace',\n    lineHeight: 12,\n    lineMargin: 0,\n    foregroundColour: '#fff',\n    backgroundColour: '#333',\n    defaultValue: {\n        align: 'left',\n        showLabel: true,\n    },\n    defaultChart: {\n        values: [],\n        valueBufferSize: 60,\n        valueBufferStride: 1,\n        minValue: 0,\n        maxValue: 100,\n        barWidth: 2,\n        align: 'left',\n        showLabel: true,\n        chartBackgroundColour: '#222',\n    },\n    defaultMarker: {\n        showLabel: true,\n        showValue: true,\n        showMarker: true,\n        markerSize: 6,\n        markerLineWidth: 2,\n        markerStyle: 'x',\n        markerColour: '#ccc',\n        space: 'world',\n        labelOffset: (0, vec_1.vec2)(10),\n    },\n    defaultBorder: {\n        showLabel: true,\n        showValue: true,\n        showBorder: true,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderShape: 'rectangle',\n        borderColour: '#ccc',\n        borderDashSize: 5,\n        space: 'world',\n        labelOffset: (0, vec_1.vec2)(10),\n    },\n};\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_48715__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_48715__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_48715__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/image-font/build/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@basementuniverse/image-font/build/index.js ***!
  \******************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageFontContentProcessor = exports.ImageFont = exports.isImageFontConfigData = void 0;\nconst texture_atlas_1 = __webpack_require__(/*! @basementuniverse/texture-atlas */ \"./node_modules/@basementuniverse/texture-atlas/build/index.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\n// -----------------------------------------------------------------------------\n// TYPE GUARDS\n// -----------------------------------------------------------------------------\nfunction isImageFontConfigData(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    if (!('textureAtlasSize' in value) ||\n        typeof value.textureAtlasSize !== 'object' ||\n        value.textureAtlasSize === null) {\n        return false;\n    }\n    if (!('x' in value.textureAtlasSize) ||\n        typeof value.textureAtlasSize.x !== 'number') {\n        return false;\n    }\n    if (!('y' in value.textureAtlasSize) ||\n        typeof value.textureAtlasSize.y !== 'number') {\n        return false;\n    }\n    if ('offset' in value) {\n        if (typeof value.offset !== 'object' || value.offset === null) {\n            return false;\n        }\n        if (!('x' in value.offset) || typeof value.offset.x !== 'number') {\n            return false;\n        }\n        if (!('y' in value.offset) || typeof value.offset.y !== 'number') {\n            return false;\n        }\n    }\n    if ('scale' in value && typeof value.scale !== 'number') {\n        return false;\n    }\n    if ('defaultCharacterConfig' in value) {\n        if (typeof value.defaultCharacterConfig !== 'object' ||\n            value.defaultCharacterConfig === null) {\n            return false;\n        }\n        if (!isImageFontCharacterConfigData(value.defaultCharacterConfig, false)) {\n            return false;\n        }\n    }\n    if (!('characters' in value) ||\n        typeof value.characters !== 'object' ||\n        value.characters === null) {\n        return false;\n    }\n    for (const [char, config] of Object.entries(value.characters)) {\n        if (typeof char !== 'string' || char.length !== 1) {\n            return false; // Character keys must be single characters\n        }\n        if (!isImageFontCharacterConfigData(config)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isImageFontConfigData = isImageFontConfigData;\nfunction isImageFontCharacterConfigData(value, includeTextureAtlasPosition = true) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    if (includeTextureAtlasPosition) {\n        if (!('textureAtlasPosition' in value) ||\n            typeof value.textureAtlasPosition !== 'object' ||\n            value.textureAtlasPosition === null) {\n            return false;\n        }\n        if (!('x' in value.textureAtlasPosition) ||\n            typeof value.textureAtlasPosition.x !== 'number') {\n            return false;\n        }\n        if (!('y' in value.textureAtlasPosition) ||\n            typeof value.textureAtlasPosition.y !== 'number') {\n            return false;\n        }\n    }\n    if ('offset' in value) {\n        if (typeof value.offset !== 'object' || value.offset === null) {\n            return false;\n        }\n        if (!('x' in value.offset) || typeof value.offset.x !== 'number') {\n            return false;\n        }\n        if (!('y' in value.offset) || typeof value.offset.y !== 'number') {\n            return false;\n        }\n    }\n    if ('width' in value && typeof value.width !== 'number') {\n        return false;\n    }\n    if ('height' in value && typeof value.height !== 'number') {\n        return false;\n    }\n    return true;\n}\n// -----------------------------------------------------------------------------\n// IMAGE FONT CLASS\n// -----------------------------------------------------------------------------\nclass ImageFont {\n    constructor(textures, config) {\n        this.textures = textures;\n        this.config = {\n            ...ImageFont.DEFAULT_CONFIG,\n            ...config,\n            defaultCharacterConfig: {\n                ...ImageFont.DEFAULT_CONFIG.defaultCharacterConfig,\n                ...config.defaultCharacterConfig,\n            },\n            characters: {\n                ...ImageFont.DEFAULT_CONFIG.characters,\n                ...config.characters,\n            },\n        };\n    }\n    /**\n     * Calculate the width of a single character when rendered with this font\n     */\n    measureCharacterWidth(character, options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const characterConfig = this.config.characters[character];\n        const actualScale = ((_a = options === null || options === void 0 ? void 0 : options.scale) !== null && _a !== void 0 ? _a : 1) * ((_b = this.config.scale) !== null && _b !== void 0 ? _b : 1);\n        const texture = this.textures[character];\n        let width = 0;\n        if (options === null || options === void 0 ? void 0 : options.monospace) {\n            if ((options === null || options === void 0 ? void 0 : options.kerning) !== undefined) {\n                width = options.kerning;\n            }\n            else {\n                width =\n                    (_e = (_d = (_c = this.config.defaultCharacterConfig) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : texture === null || texture === void 0 ? void 0 : texture.width) !== null && _e !== void 0 ? _e : 0;\n            }\n        }\n        else {\n            width =\n                ((_j = (_h = (_f = characterConfig === null || characterConfig === void 0 ? void 0 : characterConfig.width) !== null && _f !== void 0 ? _f : (_g = this.config.defaultCharacterConfig) === null || _g === void 0 ? void 0 : _g.width) !== null && _h !== void 0 ? _h : texture === null || texture === void 0 ? void 0 : texture.width) !== null && _j !== void 0 ? _j : 0) * ((_k = options === null || options === void 0 ? void 0 : options.kerning) !== null && _k !== void 0 ? _k : 1);\n        }\n        return width * actualScale;\n    }\n    /**\n     * Calculate the height of a single character when rendered with this font\n     */\n    measureCharacterHeight(character, options) {\n        var _a, _b, _c, _d, _e;\n        const characterConfig = this.config.characters[character];\n        const actualScale = ((_a = options === null || options === void 0 ? void 0 : options.scale) !== null && _a !== void 0 ? _a : 1) * ((_b = this.config.scale) !== null && _b !== void 0 ? _b : 1);\n        return (((_e = (_c = characterConfig === null || characterConfig === void 0 ? void 0 : characterConfig.height) !== null && _c !== void 0 ? _c : (_d = this.config.defaultCharacterConfig) === null || _d === void 0 ? void 0 : _d.height) !== null && _e !== void 0 ? _e : 0) * actualScale);\n    }\n    /**\n     * Get the width of a string of text when rendered with this font\n     */\n    measureText(text, options) {\n        // When calculating the total width, ignore kerning for the last character\n        const lastCharacterWidth = this.measureCharacterWidth(text[text.length - 1], {\n            scale: options === null || options === void 0 ? void 0 : options.scale,\n        });\n        const width = text\n            .split('')\n            .slice(0, text.length - 1)\n            .reduce((width, character) => width + this.measureCharacterWidth(character, options), 0) + lastCharacterWidth;\n        const height = Math.max(...text\n            .split('')\n            .map(character => this.measureCharacterHeight(character, options)));\n        return (0, vec_1.vec2)(width, height);\n    }\n    /**\n     * Draw text on a canvas using this font\n     */\n    drawText(context, text, x, y, options) {\n        var _a, _b, _c, _d, _e, _f;\n        const size = this.measureText(text, options);\n        let currentX = x;\n        switch (options === null || options === void 0 ? void 0 : options.align) {\n            case 'center':\n                currentX -= size.x / 2;\n                break;\n            case 'right':\n                currentX -= size.x;\n                break;\n        }\n        const actualScale = ((_a = options === null || options === void 0 ? void 0 : options.scale) !== null && _a !== void 0 ? _a : 1) * ((_b = this.config.scale) !== null && _b !== void 0 ? _b : 1);\n        let actualY = y;\n        switch (options === null || options === void 0 ? void 0 : options.baseLine) {\n            case 'middle':\n                actualY = y - size.y / 2;\n                break;\n            case 'bottom':\n                actualY = y - size.y;\n                break;\n        }\n        for (const character of text) {\n            const characterWidth = this.measureCharacterWidth(character, options);\n            const texture = this.textures[character];\n            if (!texture) {\n                currentX += characterWidth;\n                continue;\n            }\n            const characterConfig = this.config.characters[character];\n            const offset = vec_1.vec2.add((_c = this.config.offset) !== null && _c !== void 0 ? _c : (0, vec_1.vec2)(), (_f = (_d = characterConfig === null || characterConfig === void 0 ? void 0 : characterConfig.offset) !== null && _d !== void 0 ? _d : (_e = this.config.defaultCharacterConfig) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : (0, vec_1.vec2)());\n            context.drawImage(texture, currentX - offset.x * actualScale, actualY - offset.y * actualScale, texture.width * actualScale, texture.height * actualScale);\n            currentX += characterWidth;\n        }\n    }\n}\nexports.ImageFont = ImageFont;\nImageFont.DEFAULT_CONFIG = {\n    offset: (0, vec_1.vec2)(),\n    scale: 1,\n    defaultCharacterConfig: {\n        offset: (0, vec_1.vec2)(),\n    },\n    characters: {},\n};\n// -----------------------------------------------------------------------------\n// CONTENT PROCESSOR\n// -----------------------------------------------------------------------------\n/**\n * Content Manager Processor for loading image fonts\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function imageFontContentProcessor(content, data, imageName) {\n    var _a;\n    if (!isImageFontConfigData(data.content)) {\n        throw new Error('Invalid image font config');\n    }\n    const image = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n    if (!image) {\n        throw new Error(`Image '${imageName}' not found`);\n    }\n    // Create the texture atlas\n    const atlas = (0, texture_atlas_1.textureAtlas)(image, {\n        relative: true,\n        width: data.content.textureAtlasSize.x,\n        height: data.content.textureAtlasSize.y,\n        regions: Object.fromEntries(Object.entries(data.content.characters).map(([char, config]) => [\n            char,\n            {\n                x: config.textureAtlasPosition.x,\n                y: config.textureAtlasPosition.y,\n            },\n        ])),\n    });\n    // Create the image font\n    const font = new ImageFont(atlas, data.content);\n    // Store the font in the content manager\n    content[data.name] = {\n        name: data.name,\n        type: 'json',\n        content: font,\n        status: 'processed',\n    };\n}\nexports.imageFontContentProcessor = imageFontContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/image-font/./index.ts?\n}");

/***/ }),

/***/ "./node_modules/@basementuniverse/texture-atlas/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/texture-atlas/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse // removed by dead control flow\n{ var i, a; }\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./index.ts\":\n/*!******************!*\\\n  !*** ./index.ts ***!\n  \\******************/\n/***/ ((__unused_webpack_module, exports) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nexports.textureAtlasContentProcessor = exports.textureAtlas = exports.isTextureAtlasRegion = exports.isTextureAtlasOptions = void 0;\\nfunction isTextureAtlasOptions(value) {\\n    if (!value || typeof value !== 'object') {\\n        return false;\\n    }\\n    if (!('relative' in value) || typeof value.relative !== 'boolean') {\\n        return false;\\n    }\\n    if (!('width' in value) || typeof value.width !== 'number') {\\n        return false;\\n    }\\n    if (!('height' in value) || typeof value.height !== 'number') {\\n        return false;\\n    }\\n    if (!('regions' in value) || typeof value.regions !== 'object') {\\n        return false;\\n    }\\n    for (const [key, region] of Object.entries(value.regions)) {\\n        if (typeof key !== 'string') {\\n            return false;\\n        }\\n        if (!isTextureAtlasRegion(region)) {\\n            return false;\\n        }\\n    }\\n    if (!('cellMargin' in value) || typeof value.cellMargin !== 'number') {\\n        return false;\\n    }\\n    return true;\\n}\\nexports.isTextureAtlasOptions = isTextureAtlasOptions;\\nfunction isTextureAtlasRegion(value) {\\n    if (!value || typeof value !== 'object') {\\n        return false;\\n    }\\n    if (!('x' in value) || typeof value.x !== 'number') {\\n        return false;\\n    }\\n    if (!('y' in value) || typeof value.y !== 'number') {\\n        return false;\\n    }\\n    if ('width' in value && typeof value.width !== 'number') {\\n        return false;\\n    }\\n    if ('height' in value && typeof value.height !== 'number') {\\n        return false;\\n    }\\n    if ('repeat' in value && typeof value.repeat !== 'number') {\\n        return false;\\n    }\\n    if ('repeatOffset' in value) {\\n        const repeatOffset = value.repeatOffset;\\n        if (!repeatOffset || typeof repeatOffset !== 'object') {\\n            return false;\\n        }\\n        if (!('x' in repeatOffset) || typeof repeatOffset.x !== 'number') {\\n            return false;\\n        }\\n        if (!('y' in repeatOffset) || typeof repeatOffset.y !== 'number') {\\n            return false;\\n        }\\n    }\\n    if ('repeatNameFormat' in value &&\\n        typeof value.repeatNameFormat !== 'string') {\\n        return false;\\n    }\\n    return true;\\n}\\nexports.isTextureAtlasRegion = isTextureAtlasRegion;\\nconst DEFAULT_REPEATING_REGION_NAME_FORMAT = '{name}-{n}';\\nconst DEFAULT_OPTIONS = {\\n    relative: true,\\n    width: 1,\\n    height: 1,\\n    regions: {\\n        default: {\\n            x: 0,\\n            y: 0,\\n        },\\n    },\\n    cellMargin: 0,\\n};\\n/**\\n * Takes an image and some texture atlas options and returns a dictionary\\n * of canvases indexed by region name\\n */\\nfunction textureAtlas(image, options) {\\n    var _a, _b, _c, _d;\\n    const actualOptions = Object.assign({}, DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\\n    if (actualOptions.width <= 0 || actualOptions.height <= 0) {\\n        throw new Error('Width and height must be greater than 0');\\n    }\\n    if (Object.keys(actualOptions.regions).length === 0) {\\n        throw new Error('No regions defined');\\n    }\\n    let cellWidth = 1;\\n    let cellHeight = 1;\\n    if (actualOptions.relative) {\\n        let imageWidth = image.width;\\n        let imageHeight = image.height;\\n        if (actualOptions.cellMargin > 0) {\\n            imageWidth -= actualOptions.cellMargin;\\n            imageHeight -= actualOptions.cellMargin;\\n        }\\n        cellWidth = Math.ceil(imageWidth / actualOptions.width);\\n        cellHeight = Math.ceil(imageHeight / actualOptions.height);\\n    }\\n    const map = {};\\n    for (const [name, region] of Object.entries(actualOptions.regions)) {\\n        let absoluteX = Math.floor(region.x * cellWidth);\\n        let absoluteY = Math.floor(region.y * cellHeight);\\n        let absoluteWidth = Math.ceil(region.width\\n            ? (actualOptions.relative\\n                ? region.width * cellWidth\\n                : region.width)\\n            : (actualOptions.relative\\n                ? cellWidth\\n                : image.width - absoluteX));\\n        let absoluteHeight = Math.ceil(region.height\\n            ? (actualOptions.relative\\n                ? region.height * cellHeight\\n                : region.height)\\n            : (actualOptions.relative\\n                ? cellHeight\\n                : image.height - absoluteY));\\n        if (actualOptions.relative && actualOptions.cellMargin > 0) {\\n            absoluteX += actualOptions.cellMargin;\\n            absoluteY += actualOptions.cellMargin;\\n            absoluteWidth -= actualOptions.cellMargin;\\n            absoluteHeight -= actualOptions.cellMargin;\\n        }\\n        if (region.repeat && region.repeat > 0) {\\n            for (let i = 0; i < region.repeat; i++) {\\n                const repeatName = getRepeatingRegionName(name, i + 1, region.repeatNameFormat);\\n                let repeatOffsetX = Math.floor((((_a = region.repeatOffset) === null || _a === void 0 ? void 0 : _a.x) !== undefined &&\\n                    ((_b = region.repeatOffset) === null || _b === void 0 ? void 0 : _b.x) !== null)\\n                    ? (actualOptions.relative\\n                        ? region.repeatOffset.x * cellWidth\\n                        : region.repeatOffset.x)\\n                    : cellWidth);\\n                let repeatOffsetY = Math.floor((((_c = region.repeatOffset) === null || _c === void 0 ? void 0 : _c.y) !== undefined &&\\n                    ((_d = region.repeatOffset) === null || _d === void 0 ? void 0 : _d.y) !== null)\\n                    ? (actualOptions.relative\\n                        ? region.repeatOffset.y * cellHeight\\n                        : region.repeatOffset.y)\\n                    : 0);\\n                map[repeatName] = chopRegion(image, absoluteX + repeatOffsetX * i, absoluteY + repeatOffsetY * i, absoluteWidth, absoluteHeight);\\n            }\\n        }\\n        else {\\n            map[name] = chopRegion(image, absoluteX, absoluteY, absoluteWidth, absoluteHeight);\\n        }\\n    }\\n    return map;\\n}\\nexports.textureAtlas = textureAtlas;\\n/**\\n * Chop a rectangular region from an image into a new canvas\\n */\\nfunction chopRegion(image, x, y, width, height) {\\n    const canvas = document.createElement('canvas');\\n    const context = canvas.getContext('2d');\\n    canvas.width = width;\\n    canvas.height = height;\\n    if (!context) {\\n        throw new Error('Failed to get 2D context');\\n    }\\n    context.drawImage(image, x, y, width, height, 0, 0, width, height);\\n    return canvas;\\n}\\n/**\\n * Get the name of a repeating region\\n */\\nfunction getRepeatingRegionName(regionName, repetitionIndex, regionNameFormat) {\\n    return (regionNameFormat !== null && regionNameFormat !== void 0 ? regionNameFormat : DEFAULT_REPEATING_REGION_NAME_FORMAT)\\n        .replace('{name}', regionName)\\n        .replace('{n}', repetitionIndex.toString());\\n}\\n/**\\n * Content Manager Processor wrapper which allows the textureAtlas function\\n * to be used as a processor in a Content Manager\\n *\\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\\n */\\nasync function textureAtlasContentProcessor(content, data, imageName) {\\n    var _a;\\n    if (!isTextureAtlasOptions(data.content)) {\\n        throw new Error('Invalid texture atlas options');\\n    }\\n    const image = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\\n    if (!image) {\\n        throw new Error(`Image '${imageName}' not found`);\\n    }\\n    const map = textureAtlas(image, data.content);\\n    for (const [name, canvas] of Object.entries(map)) {\\n        content[name] = {\\n            name,\\n            type: 'image',\\n            content: canvas,\\n            status: 4,\\n        };\\n    }\\n}\\nexports.textureAtlasContentProcessor = textureAtlasContentProcessor;\\n\\n\\n//# sourceURL=webpack://@basementuniverse/texture-atlas/./index.ts?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __nested_webpack_exports__ = {};\n/******/ \t__webpack_modules__[\"./index.ts\"](0, __nested_webpack_exports__);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://@basementuniverse/image-font/./node_modules/@basementuniverse/texture-atlas/build/index.js?\n}");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("{/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/image-font/./node_modules/@basementuniverse/vec/vec.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_49815__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_49815__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_49815__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/input-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/input-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MouseButton = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar MouseButton;\n(function (MouseButton) {\n    MouseButton[MouseButton[\"Left\"] = 0] = \"Left\";\n    MouseButton[MouseButton[\"Middle\"] = 1] = \"Middle\";\n    MouseButton[MouseButton[\"Right\"] = 2] = \"Right\";\n})(MouseButton = exports.MouseButton || (exports.MouseButton = {}));\nclass InputManager {\n    constructor(options) {\n        this.keyboardState = InputManager.initialKeyboardState();\n        this.previousKeyboardState = InputManager.initialKeyboardState();\n        this.mouseState = InputManager.initialMouseState();\n        this.previousMouseState = InputManager.initialMouseState();\n        this.options = Object.assign({}, InputManager.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        // Set up event handlers\n        if (this.options.mouse) {\n            this.options.element.addEventListener('mousedown', e => {\n                this.mouseState.buttons[e.button] = true;\n            });\n            this.options.element.addEventListener('mouseup', e => {\n                this.mouseState.buttons[e.button] =\n                    false;\n            });\n            this.options.element.addEventListener('touchstart', () => {\n                this.mouseState.buttons[0] = true;\n            });\n            this.options.element.addEventListener('touchend', () => {\n                this.mouseState.buttons[0] = false;\n            });\n            this.options.element.addEventListener('mousemove', e => {\n                this.mouseState.position.x = e.offsetX;\n                this.mouseState.position.y = e.offsetY;\n                this.mouseState.hoveredElement = e.target;\n            });\n            if (this.options.mouseWheel) {\n                window.addEventListener('wheel', e => {\n                    this.mouseState.wheel = e.deltaY > 0 ? 1 : -1;\n                });\n            }\n        }\n        if (this.options.keyboard) {\n            window.addEventListener('keydown', e => {\n                this.keyboardState[e.code] = true;\n            });\n            window.addEventListener('keyup', e => {\n                this.keyboardState[e.code] = false;\n            });\n        }\n        // Prevent the context menu from appearing on right-click\n        if (this.options.preventContextMenu) {\n            this.options.element.addEventListener('contextmenu', e => {\n                e.preventDefault();\n            });\n        }\n    }\n    /**\n     * Initialise the input manager for managing mouse and keyboard input\n     */\n    static initialise(options) {\n        if (InputManager.instance !== undefined) {\n            throw new Error('Input manager already initialised');\n        }\n        InputManager.instance = new InputManager(options);\n    }\n    static getInstance() {\n        if (InputManager.instance === undefined) {\n            throw new Error('Input manager not properly initialised');\n        }\n        return InputManager.instance;\n    }\n    static initialKeyboardState() {\n        return {};\n    }\n    static initialMouseState() {\n        return {\n            buttons: {\n                [MouseButton.Left]: false,\n                [MouseButton.Middle]: false,\n                [MouseButton.Right]: false,\n            },\n            position: (0, vec_1.vec2)(),\n            wheel: 0,\n            hoveredElement: null,\n        };\n    }\n    static copyKeyboardState(state) {\n        return Object.assign({}, state);\n    }\n    static copyMouseState(state) {\n        return {\n            buttons: Object.assign({}, state.buttons),\n            position: vec_1.vec2.cpy(state.position),\n            wheel: state.wheel,\n            hoveredElement: state.hoveredElement,\n        };\n    }\n    /**\n     * Update the state of the input devices\n     */\n    static update() {\n        const instance = InputManager.getInstance();\n        instance.previousKeyboardState = this.copyKeyboardState(instance.keyboardState);\n        instance.previousMouseState = this.copyMouseState(instance.mouseState);\n        instance.mouseState.wheel = 0;\n    }\n    /**\n     * Check if a key is currently pressed down\n     */\n    static keyDown(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key is down\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.keyboardState[code];\n    }\n    /**\n     * Check if a key has been pressed since the last frame\n     */\n    static keyPressed(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was pressed\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k] &&\n                    (!(k in instance.previousKeyboardState) ||\n                        !instance.previousKeyboardState[k])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.keyboardState[code] && !instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a key has been released since the last frame\n     */\n    static keyReleased(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was released\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (!instance.keyboardState[k] && !!instance.previousKeyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.keyboardState[code] && !!instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a mouse button is currently pressed down\n     */\n    static mouseDown(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button is down\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.mouseState.buttons[button];\n    }\n    /**\n     * Check if a mouse button has been pressed since the last frame\n     */\n    static mousePressed(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was pressed\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton] &&\n                    (!(b in instance.previousMouseState.buttons) ||\n                        !instance.previousMouseState.buttons[currentButton])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.mouseState.buttons[button] &&\n            !instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if a mouse button has been released since the last frame\n     */\n    static mouseReleased(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was released\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (!instance.mouseState.buttons[currentButton] &&\n                    !!instance.previousMouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.mouseState.buttons[button] &&\n            !!instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if the mousewheel is scrolling up\n     */\n    static mouseWheelUp() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel > 0;\n    }\n    /**\n     * Check if the mousewheel is scrolling down\n     */\n    static mouseWheelDown() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel < 0;\n    }\n    /**\n     * Get the current mouse position in screen-space\n     */\n    static get mousePosition() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.position;\n    }\n    /**\n     * Get the currently hovered element\n     */\n    static get hoveredElement() {\n        var _a;\n        const instance = InputManager.getInstance();\n        return (_a = instance.mouseState.hoveredElement) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports[\"default\"] = InputManager;\nInputManager.DEFAULT_OPTIONS = {\n    element: window,\n    mouse: true,\n    mouseWheel: true,\n    keyboard: true,\n    preventContextMenu: false,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_37359__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_37359__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_37359__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/scene-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/scene-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = exports.SceneTransitionState = void 0;\nvar SceneTransitionState;\n(function (SceneTransitionState) {\n    SceneTransitionState[\"In\"] = \"in\";\n    SceneTransitionState[\"Out\"] = \"out\";\n    SceneTransitionState[\"None\"] = \"none\";\n})(SceneTransitionState = exports.SceneTransitionState || (exports.SceneTransitionState = {}));\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass SceneManager {\n    constructor() {\n        this.scenes = [];\n    }\n    /**\n     * Initialise the scene manager for managing game scenes\n     */\n    static initialise() {\n        if (SceneManager.instance) {\n            throw new Error('SceneManager already initialised');\n        }\n        SceneManager.instance = new SceneManager();\n    }\n    static getInstance() {\n        if (!SceneManager.instance) {\n            throw new Error('SceneManager not properly initialised');\n        }\n        return SceneManager.instance;\n    }\n    /**\n     * Push a scene onto the scene stack and start transitioning in\n     */\n    static push(scene, ...args) {\n        const instance = SceneManager.getInstance();\n        instance.scenes.push(scene);\n        // Initialise the scene and start the transition\n        scene.initialise(...args);\n        scene.transitionIn();\n        return scene;\n    }\n    /**\n     * Remove a scene from the scene stack after transitioning out\n     */\n    static pop() {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            let last = instance.scenes.length - 1;\n            // Remove the top-most scene that isn't currently transitioning out\n            while (last > 0 &&\n                instance.scenes[last].transitionState === SceneTransitionState.Out) {\n                last--;\n            }\n            if (last >= 0) {\n                const scene = instance.scenes[last];\n                // Start transitioning out\n                scene.transitionOut();\n                return scene;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Remove all scene from the scene stack\n     */\n    static clear() {\n        const instance = SceneManager.getInstance();\n        instance.scenes.forEach(scene => {\n            if (scene.transitionState !== SceneTransitionState.Out) {\n                scene.transitionOut();\n            }\n        });\n    }\n    /**\n     * Update the scene manager and the current scene\n     */\n    static update(dt, ...args) {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            // Only update the top-most scene that isn't currently transitioning out\n            for (let i = instance.scenes.length; i--;) {\n                if (instance.scenes[i].transitionState !== SceneTransitionState.Out) {\n                    instance.scenes[i].update(dt, ...args);\n                    break;\n                }\n            }\n            // Update all scene transitions\n            instance.scenes.forEach(scene => {\n                scene.updateTransition(dt);\n            });\n            // Remove any disposed scenes\n            instance.scenes = instance.scenes.filter(scene => !scene.disposed);\n        }\n    }\n    /**\n     * Render scenes on the screen\n     */\n    static draw(context, ...args) {\n        const instance = SceneManager.getInstance();\n        // Figure out which scenes we need to draw\n        const drawList = [];\n        for (let i = instance.scenes.length; i--;) {\n            const scene = instance.scenes[i];\n            drawList.push(scene);\n            // If transitioning, this scene is assumed to be transparent\n            // (we might want to show the scene underneath if we're doing e.g. a fade)\n            if (!scene.transparent &&\n                scene.transitionState === SceneTransitionState.None) {\n                break;\n            }\n        }\n        // Draw the scenes in bottom -> top order\n        drawList.reverse().forEach(scene => {\n            scene.draw(context, ...args);\n        });\n    }\n    /**\n     * Let all scenes know that a resize event has occurred\n     */\n    static resize(width, height) {\n        var _a;\n        const instance = SceneManager.getInstance();\n        for (const scene of instance.scenes) {\n            (_a = scene.resize) === null || _a === void 0 ? void 0 : _a.call(scene, width, height);\n        }\n    }\n}\nexports[\"default\"] = SceneManager;\nclass Scene {\n    constructor(options) {\n        this.defaultOptions = {\n            transitionTime: 2,\n            transparent: true,\n        };\n        this.transitionState = SceneTransitionState.None;\n        this.transitionAmount = 0;\n        this.transitionTime = 0;\n        this.transparent = false;\n        this.disposed = false;\n        const actualOptions = Object.assign({}, this.defaultOptions, options);\n        this.transitionTime = actualOptions.transitionTime;\n        this.transparent = actualOptions.transparent;\n        this.onTransitionedIn = actualOptions.onTransitionedIn;\n        this.onTransitionedOut = actualOptions.onTransitionedOut;\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    transitionIn() {\n        this.transitionState = SceneTransitionState.In;\n    }\n    transitionOut() {\n        this.transitionState = SceneTransitionState.Out;\n    }\n    updateTransition(dt) {\n        var _a, _b;\n        const amount = dt / this.transitionTime;\n        // Transitioning in\n        if (this.transitionState === SceneTransitionState.In) {\n            if (this.transitionAmount < 1) {\n                this.transitionAmount = clamp(this.transitionAmount + amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                (_a = this.onTransitionedIn) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        }\n        // Transitioning out\n        if (this.transitionState === SceneTransitionState.Out) {\n            if (this.transitionAmount > 0) {\n                this.transitionAmount = clamp(this.transitionAmount - amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                this.dispose();\n                (_b = this.onTransitionedOut) === null || _b === void 0 ? void 0 : _b.call(this);\n            }\n        }\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://@basementuniverse/scene-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.ts"](0, __webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/sprite/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/sprite/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spriteOptionsContentProcessor = exports.Sprite = exports.isSpriteOptionsData = exports.SpriteAnimationRepeatMode = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar SpriteAnimationRepeatMode;\n(function (SpriteAnimationRepeatMode) {\n    /**\n     * Loop this animation indefinitely\n     */\n    SpriteAnimationRepeatMode[\"Repeat\"] = \"repeat\";\n    /**\n     * Play once and then stop on the last frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndStop\"] = \"play-once-and-stop\";\n    /**\n     * Play once and then reset back to the first frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndReset\"] = \"play-once-and-reset\";\n})(SpriteAnimationRepeatMode = exports.SpriteAnimationRepeatMode || (exports.SpriteAnimationRepeatMode = {}));\n// -----------------------------------------------------------------------------\n// TYPE GUARDS\n// -----------------------------------------------------------------------------\nfunction isVec2(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        'x' in value &&\n        'y' in value &&\n        typeof value.x === 'number' &&\n        typeof value.y === 'number');\n}\nfunction isSpriteAnimationOptionsData(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('name' in value) || typeof value.name !== 'string') {\n        return false;\n    }\n    if ('frameCount' in value && typeof value.frameCount !== 'number') {\n        return false;\n    }\n    if ('frameRate' in value && typeof value.frameRate !== 'number') {\n        return false;\n    }\n    if ('mode' in value &&\n        !Object.values(SpriteAnimationRepeatMode).includes(value.mode)) {\n        return false;\n    }\n    if ('imageNames' in value) {\n        if (!Array.isArray(value.imageNames)) {\n            return false;\n        }\n        if (!value.imageNames.every((imageName) => typeof imageName === 'string')) {\n            return false;\n        }\n    }\n    if ('attachmentPointKeyframes' in value &&\n        typeof value.attachmentPointKeyframes === 'object' &&\n        value.attachmentPointKeyframes !== null) {\n        for (const [attachmentPointName, keyframes] of Object.entries(value.attachmentPointKeyframes)) {\n            if (typeof attachmentPointName !== 'string') {\n                return false;\n            }\n            if (!Array.isArray(keyframes)) {\n                return false;\n            }\n            if (!keyframes.every(isSpriteAttachmentPointKeyframe)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction isSpriteAttachmentPointOptions(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('name' in value) || typeof value.name !== 'string') {\n        return false;\n    }\n    if (!('offset' in value) || !isVec2(value.offset)) {\n        return false;\n    }\n    return true;\n}\nfunction isSpriteAttachmentPointKeyframe(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('frame' in value) || typeof value.frame !== 'number') {\n        return false;\n    }\n    if (!('offset' in value) || !isVec2(value.offset)) {\n        return false;\n    }\n    return true;\n}\nfunction isSpriteOptionsData(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if ('position' in value && !isVec2(value.position)) {\n        return false;\n    }\n    if ('size' in value && !isVec2(value.size)) {\n        return false;\n    }\n    if ('origin' in value && !isVec2(value.origin)) {\n        return false;\n    }\n    if ('scale' in value && typeof value.scale !== 'number') {\n        return false;\n    }\n    if ('rotation' in value && typeof value.rotation !== 'number') {\n        return false;\n    }\n    if ('directions' in value && !Array.isArray(value.directions)) {\n        return false;\n    }\n    if ('defaultDirection' in value &&\n        typeof value.defaultDirection !== 'string') {\n        return false;\n    }\n    if ('imageName' in value && typeof value.imageName !== 'string') {\n        return false;\n    }\n    if ('animations' in value) {\n        if (typeof value.animations !== 'object' || value.animations === null) {\n            return false;\n        }\n        for (const [animationName, animationDirections] of Object.entries(value.animations)) {\n            if (typeof animationName !== 'string') {\n                return false;\n            }\n            if (typeof animationDirections !== 'object' ||\n                animationDirections === null) {\n                return false;\n            }\n            for (const [directionName, animationOptions] of Object.entries(animationDirections)) {\n                if (typeof directionName !== 'string') {\n                    return false;\n                }\n                if (!isSpriteAnimationOptionsData(animationOptions)) {\n                    return false;\n                }\n            }\n        }\n    }\n    if ('defaultAnimation' in value &&\n        typeof value.defaultAnimation !== 'string') {\n        return false;\n    }\n    if ('attachmentPoints' in value) {\n        if (!Array.isArray(value.attachmentPoints)) {\n            return false;\n        }\n        if (!value.attachmentPoints.every(isSpriteAttachmentPointOptions)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSpriteOptionsData = isSpriteOptionsData;\n// -----------------------------------------------------------------------------\n// SPRITE CLASS\n// -----------------------------------------------------------------------------\nclass Sprite {\n    constructor(options) {\n        var _a, _b;\n        this.position = (0, vec_1.vec2)();\n        this.size = (0, vec_1.vec2)();\n        this.origin = (0, vec_1.vec2)();\n        this.scale = 1;\n        this.rotation = 0;\n        this.currentAnimationOptions = null;\n        this.currentAnimationState = null;\n        this.currentImage = null;\n        this.currentAttachmentPoints = null;\n        const actualOptions = Object.assign({}, Sprite.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        for (const animation of Object.keys(actualOptions.animations)) {\n            for (const direction of Object.keys(actualOptions.animations[animation])) {\n                actualOptions.animations[animation][direction] = Object.assign({}, Sprite.DEFAULT_ANIMATION_OPTIONS, actualOptions.animations[animation][direction]);\n            }\n        }\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showSpriteTransforms: !!actualOptions.debug,\n                showSpriteBoundingBox: !!actualOptions.debug,\n                showAttachmentPoints: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        if (this.options.position) {\n            this.position = vec_1.vec2.cpy(this.options.position);\n        }\n        if (this.options.size) {\n            this.size = vec_1.vec2.cpy(this.options.size);\n        }\n        else {\n            // Default to the size of the base image if one exists\n            if (this.options.image) {\n                this.size = (0, vec_1.vec2)(this.options.image.width, this.options.image.height);\n            }\n            else {\n                // Fall back to the size of the image in the first frame of the first\n                // available direction of the default animation if one exists\n                const defaultAnimationDirections = Object.values(this.options.animations[this.options.defaultAnimation])[0];\n                if (defaultAnimationDirections &&\n                    ((_b = (_a = defaultAnimationDirections.images) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n                    this.size = (0, vec_1.vec2)(defaultAnimationDirections.images[0].width, defaultAnimationDirections.images[0].height);\n                }\n            }\n            // Otherwise leave the size as (0, 0)\n        }\n        if (this.options.origin) {\n            this.origin = vec_1.vec2.cpy(this.options.origin);\n        }\n        else {\n            // Default to the center of the sprite based on size\n            this.origin = vec_1.vec2.mul(this.size, 0.5);\n        }\n        if (this.options.scale) {\n            this.scale = this.options.scale;\n        }\n        if (this.options.rotation) {\n            this.rotation = this.options.rotation;\n        }\n        // Check and initialise direction\n        this._direction = this.options.defaultDirection;\n        if (this.options.directions.length === 0 ||\n            !this.options.directions.includes(this._direction)) {\n            throw new Error(`Invalid direction \"${this._direction}\"`);\n        }\n        // Check and initialise animation\n        this._animation = this.options.defaultAnimation;\n        const animations = Object.keys(this.options.animations);\n        if (animations.length === 0 || !animations.includes(this._animation)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        // Make sure attachment point keyframes are defined in ascending\n        // frame order in all animations\n        for (const animation of Object.keys(this.options.animations)) {\n            for (const direction of Object.keys(this.options.animations[animation])) {\n                if (this.options.animations[animation][direction].attachmentPointKeyframes) {\n                    for (const attachmentPoint of Object.keys(this.options.animations[animation][direction]\n                        .attachmentPointKeyframes)) {\n                        this.options.animations[animation][direction].attachmentPointKeyframes[attachmentPoint].sort((a, b) => a.frame - b.frame);\n                    }\n                }\n            }\n        }\n    }\n    get direction() {\n        return this._direction;\n    }\n    set direction(value) {\n        if (this.options.directions.includes(value)) {\n            this._direction = value;\n        }\n    }\n    get animation() {\n        return this._animation;\n    }\n    set animation(value) {\n        var _a, _b, _c, _d;\n        if (Object.keys(this.options.animations).includes(value)) {\n            const previous = this._animation;\n            this._animation = value;\n            // When switching animations, we might be part-way through and the\n            // new animation might have fewer frames, in which case we should clamp\n            // the current frame number\n            const currentFrameCount = (_b = (_a = this.options.animations[value][this.direction]) === null || _a === void 0 ? void 0 : _a.frameCount) !== null && _b !== void 0 ? _b : 1;\n            const previousFrameCount = (_d = (_c = this.options.animations[previous][this.direction]) === null || _c === void 0 ? void 0 : _c.frameCount) !== null && _d !== void 0 ? _d : 1;\n            if (currentFrameCount < previousFrameCount &&\n                this.currentAnimationState &&\n                this.currentAnimationState.currentFrame >= currentFrameCount) {\n                this.currentAnimationState.currentFrame = currentFrameCount - 1;\n            }\n        }\n    }\n    playAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = true;\n        }\n    }\n    pauseAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = false;\n        }\n    }\n    resetAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.currentFrame = 0;\n            this.currentAnimationState.currentFrameTime = 0;\n        }\n    }\n    getAttachmentPoint(name) {\n        var _a, _b;\n        return (_b = (_a = this.currentAttachmentPoints) === null || _a === void 0 ? void 0 : _a[name]) !== null && _b !== void 0 ? _b : null;\n    }\n    update(dt) {\n        this.currentAnimationOptions = this.updateAnimationOptions();\n        this.currentAnimationState = this.updateAnimationState(dt);\n        this.currentImage = this.updateImage();\n        this.currentAttachmentPoints = this.updateAttachmentPoints();\n    }\n    updateAnimationOptions() {\n        if (!(this._animation in this.options.animations)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        const directions = Object.keys(this.options.animations[this._animation]);\n        if (directions.length === 0) {\n            throw new Error(`No directions available for animation \"${this._animation}\"`);\n        }\n        if (this._direction in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation][this._direction];\n        }\n        if ('*' in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation]['*'];\n        }\n        return this.options.animations[this._animation][directions[0]];\n    }\n    updateAnimationState(dt) {\n        var _a, _b, _c;\n        if (!this.currentAnimationOptions || !this.currentAnimationState) {\n            return {\n                playing: true,\n                currentFrame: 0,\n                currentFrameTime: 0,\n            };\n        }\n        if (this.currentAnimationState.playing) {\n            const frameTime = 1 / ((_a = this.currentAnimationOptions.frameRate) !== null && _a !== void 0 ? _a : 1);\n            this.currentAnimationState.currentFrameTime += dt;\n            if (this.currentAnimationState.currentFrameTime > frameTime) {\n                const frameCount = (_b = this.currentAnimationOptions.frameCount) !== null && _b !== void 0 ? _b : 1;\n                this.currentAnimationState.currentFrame++;\n                this.currentAnimationState.currentFrameTime = 0;\n                if (this.currentAnimationState.currentFrame >= frameCount) {\n                    const mode = (_c = this.currentAnimationOptions.mode) !== null && _c !== void 0 ? _c : SpriteAnimationRepeatMode.Repeat;\n                    switch (mode) {\n                        case SpriteAnimationRepeatMode.PlayOnceAndReset:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                        case SpriteAnimationRepeatMode.PlayOnceAndStop:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = frameCount - 1;\n                            break;\n                        case SpriteAnimationRepeatMode.Repeat:\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                    }\n                }\n            }\n        }\n        return this.currentAnimationState;\n    }\n    updateImage() {\n        var _a, _b, _c;\n        if (!this.currentAnimationOptions || !this.currentAnimationState) {\n            return null;\n        }\n        if (!this.currentAnimationOptions.images ||\n            this.currentAnimationOptions.images.length === 0) {\n            return (_a = this.options.image) !== null && _a !== void 0 ? _a : null;\n        }\n        return ((_c = (_b = this.currentAnimationOptions.images[this.currentAnimationState.currentFrame]) !== null && _b !== void 0 ? _b : this.options.image) !== null && _c !== void 0 ? _c : null);\n    }\n    updateAttachmentPoints() {\n        if (!this.options.attachmentPoints ||\n            this.options.attachmentPoints.length === 0) {\n            return null;\n        }\n        if (!this.currentAttachmentPoints) {\n            this.currentAttachmentPoints = Object.fromEntries(this.options.attachmentPoints.map(attachmentPoint => [\n                attachmentPoint.name,\n                attachmentPoint.offset,\n            ]));\n        }\n        if (this.currentAnimationOptions &&\n            this.currentAnimationOptions.attachmentPointKeyframes &&\n            this.currentAnimationState) {\n            for (const name of Object.keys(this.currentAttachmentPoints)) {\n                if (name in this.currentAnimationOptions.attachmentPointKeyframes &&\n                    this.currentAnimationOptions.attachmentPointKeyframes[name].length > 0) {\n                    const previousKeyframe = this.findPreviousKeyframe(this.currentAnimationOptions.attachmentPointKeyframes[name], this.currentAnimationState.currentFrame);\n                    this.currentAttachmentPoints[name] = previousKeyframe.offset;\n                }\n            }\n        }\n        return this.currentAttachmentPoints;\n    }\n    findPreviousKeyframe(keyframes, currentFrame) {\n        const found = [...keyframes]\n            .reverse()\n            .find(keyframe => keyframe.frame <= currentFrame);\n        if (!found) {\n            return keyframes[keyframes.length - 1];\n        }\n        return found;\n    }\n    draw(context) {\n        var _a, _b, _c, _d;\n        context.save();\n        context.translate(this.position.x, this.position.y);\n        context.scale(this.scale, this.scale);\n        context.rotate(this.rotation);\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this);\n        if (this.currentImage) {\n            context.drawImage(this.currentImage, -this.origin.x, -this.origin.y, this.currentImage.width, this.currentImage.height);\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this);\n        if (this.options.debug.showSpriteBoundingBox) {\n            context.strokeStyle = Sprite.DEBUG_BOUNDING_BOX_COLOUR;\n            context.lineWidth = Sprite.DEBUG_BOUNDING_BOX_LINE_WIDTH;\n            context.strokeRect(-this.origin.x, -this.origin.y, this.size.x, this.size.y);\n        }\n        if (this.options.debug.showSpriteTransforms) {\n            this.drawTransformsMarker(context, (0, vec_1.vec2)(), Sprite.DEBUG_TRANSFORMS_COLOUR_X, Sprite.DEBUG_TRANSFORMS_COLOUR_Y, Sprite.DEBUG_TRANSFORMS_LINE_WIDTH, Sprite.DEBUG_TRANSFORMS_SIZE);\n        }\n        if (this.options.debug.showAttachmentPoints &&\n            this.currentAttachmentPoints) {\n            for (const attachmentPoint of Object.values(this.currentAttachmentPoints)) {\n                this.drawCross(context, attachmentPoint, Sprite.DEBUG_ATTACHMENT_POINT_COLOUR, Sprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH, Sprite.DEBUG_ATTACHMENT_POINT_SIZE);\n            }\n        }\n        context.restore();\n    }\n    drawTransformsMarker(context, position, xColour, yColour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = xColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x + size, position.y);\n        context.stroke();\n        context.strokeStyle = yColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x, position.y + size);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.Sprite = Sprite;\nSprite.DEFAULT_OPTIONS = {\n    directions: ['default'],\n    defaultDirection: 'default',\n    animations: {\n        default: {\n            '*': {\n                name: 'default',\n                frameCount: 1,\n                frameRate: 1,\n                mode: SpriteAnimationRepeatMode.PlayOnceAndStop,\n            },\n        },\n    },\n    defaultAnimation: 'default',\n};\nSprite.DEFAULT_ANIMATION_OPTIONS = {\n    name: 'default',\n    frameCount: 1,\n    frameRate: 1,\n    mode: SpriteAnimationRepeatMode.Repeat,\n};\nSprite.DEBUG_BOUNDING_BOX_COLOUR = 'green';\nSprite.DEBUG_BOUNDING_BOX_LINE_WIDTH = 2;\nSprite.DEBUG_TRANSFORMS_COLOUR_X = 'red';\nSprite.DEBUG_TRANSFORMS_COLOUR_Y = 'orange';\nSprite.DEBUG_TRANSFORMS_LINE_WIDTH = 1;\nSprite.DEBUG_TRANSFORMS_SIZE = 10;\nSprite.DEBUG_ATTACHMENT_POINT_COLOUR = 'blue';\nSprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH = 2;\nSprite.DEBUG_ATTACHMENT_POINT_SIZE = 5;\n// -----------------------------------------------------------------------------\n// CONTENT PROCESSOR\n// -----------------------------------------------------------------------------\n/**\n * Content Manager Processor wrapper which converts SpriteOptionsData into\n * SpriteOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function spriteOptionsContentProcessor(content, data) {\n    if (!isSpriteOptionsData(data.content)) {\n        throw new Error('Invalid sprite config');\n    }\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.imageName) {\n        result.image = getImageFromContent(result.imageName);\n        delete result.imageName;\n    }\n    if (result.animations) {\n        for (const [animationName, animation] of Object.entries(result.animations)) {\n            for (const [directionName, direction] of Object.entries(animation)) {\n                if (direction.imageNames) {\n                    result.animations[animationName][directionName].images =\n                        direction.imageNames.map(getImageFromContent);\n                    delete result.animations[animationName][directionName].imageNames;\n                }\n            }\n        }\n    }\n    data.content = result;\n}\nexports.spriteOptionsContentProcessor = spriteOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_50741__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_50741__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_50741__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/texture-atlas/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/texture-atlas/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// -----------------------------------------------------------------------------\n// TYPES\n// -----------------------------------------------------------------------------\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textureAtlasContentProcessor = exports.textureAtlas = exports.isTextureAtlasRegion = exports.isTextureAtlasOptions = void 0;\n// -----------------------------------------------------------------------------\n// TYPE GUARDS\n// -----------------------------------------------------------------------------\nfunction isTextureAtlasOptions(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('relative' in value) || typeof value.relative !== 'boolean') {\n        return false;\n    }\n    if (!('width' in value) || typeof value.width !== 'number') {\n        return false;\n    }\n    if (!('height' in value) || typeof value.height !== 'number') {\n        return false;\n    }\n    if (!('regions' in value) || typeof value.regions !== 'object') {\n        return false;\n    }\n    for (const [key, region] of Object.entries(value.regions)) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isTextureAtlasRegion(region)) {\n            return false;\n        }\n    }\n    if ('cellMargin' in value && typeof value.cellMargin !== 'number') {\n        return false;\n    }\n    return true;\n}\nexports.isTextureAtlasOptions = isTextureAtlasOptions;\nfunction isTextureAtlasRegion(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('x' in value) || typeof value.x !== 'number') {\n        return false;\n    }\n    if (!('y' in value) || typeof value.y !== 'number') {\n        return false;\n    }\n    if ('width' in value && typeof value.width !== 'number') {\n        return false;\n    }\n    if ('height' in value && typeof value.height !== 'number') {\n        return false;\n    }\n    if ('repeat' in value && typeof value.repeat !== 'number') {\n        return false;\n    }\n    if ('repeatOffset' in value) {\n        const repeatOffset = value.repeatOffset;\n        if (!repeatOffset || typeof repeatOffset !== 'object') {\n            return false;\n        }\n        if (!('x' in repeatOffset) || typeof repeatOffset.x !== 'number') {\n            return false;\n        }\n        if (!('y' in repeatOffset) || typeof repeatOffset.y !== 'number') {\n            return false;\n        }\n    }\n    if ('repeatNameFormat' in value &&\n        typeof value.repeatNameFormat !== 'string') {\n        return false;\n    }\n    return true;\n}\nexports.isTextureAtlasRegion = isTextureAtlasRegion;\n// -----------------------------------------------------------------------------\n// DEFAULTS\n// -----------------------------------------------------------------------------\nconst DEFAULT_REPEATING_REGION_NAME_FORMAT = '{name}-{n}';\nconst DEFAULT_OPTIONS = {\n    relative: true,\n    width: 1,\n    height: 1,\n    regions: {\n        default: {\n            x: 0,\n            y: 0,\n        },\n    },\n    cellMargin: 0,\n};\n// -----------------------------------------------------------------------------\n// FUNCTIONS\n// -----------------------------------------------------------------------------\n/**\n * Takes an image and some texture atlas options and returns a dictionary\n * of canvases indexed by region name\n */\nfunction textureAtlas(image, options) {\n    var _a, _b, _c, _d, _e, _f;\n    const actualOptions = Object.assign({}, DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n    if (actualOptions.width <= 0 || actualOptions.height <= 0) {\n        throw new Error('Width and height must be greater than 0');\n    }\n    if (Object.keys(actualOptions.regions).length === 0) {\n        throw new Error('No regions defined');\n    }\n    let cellWidth = 1;\n    let cellHeight = 1;\n    if (actualOptions.relative) {\n        let imageWidth = image.width;\n        let imageHeight = image.height;\n        const cellMargin = (_a = actualOptions.cellMargin) !== null && _a !== void 0 ? _a : 0;\n        if (cellMargin > 0) {\n            imageWidth -= cellMargin;\n            imageHeight -= cellMargin;\n        }\n        cellWidth = Math.ceil(imageWidth / actualOptions.width);\n        cellHeight = Math.ceil(imageHeight / actualOptions.height);\n    }\n    const map = {};\n    for (const [name, region] of Object.entries(actualOptions.regions)) {\n        let absoluteX = Math.floor(region.x * cellWidth);\n        let absoluteY = Math.floor(region.y * cellHeight);\n        let absoluteWidth = Math.ceil(region.width\n            ? actualOptions.relative\n                ? region.width * cellWidth\n                : region.width\n            : actualOptions.relative\n                ? cellWidth\n                : image.width - absoluteX);\n        let absoluteHeight = Math.ceil(region.height\n            ? actualOptions.relative\n                ? region.height * cellHeight\n                : region.height\n            : actualOptions.relative\n                ? cellHeight\n                : image.height - absoluteY);\n        const cellMargin = (_b = actualOptions.cellMargin) !== null && _b !== void 0 ? _b : 0;\n        if (actualOptions.relative && cellMargin > 0) {\n            absoluteX += cellMargin;\n            absoluteY += cellMargin;\n            absoluteWidth -= cellMargin;\n            absoluteHeight -= cellMargin;\n        }\n        if (region.repeat && region.repeat > 0) {\n            for (let i = 0; i < region.repeat; i++) {\n                const repeatName = getRepeatingRegionName(name, i + 1, region.repeatNameFormat);\n                let repeatOffsetX = Math.floor(((_c = region.repeatOffset) === null || _c === void 0 ? void 0 : _c.x) !== undefined &&\n                    ((_d = region.repeatOffset) === null || _d === void 0 ? void 0 : _d.x) !== null\n                    ? actualOptions.relative\n                        ? region.repeatOffset.x * cellWidth\n                        : region.repeatOffset.x\n                    : cellWidth);\n                let repeatOffsetY = Math.floor(((_e = region.repeatOffset) === null || _e === void 0 ? void 0 : _e.y) !== undefined &&\n                    ((_f = region.repeatOffset) === null || _f === void 0 ? void 0 : _f.y) !== null\n                    ? actualOptions.relative\n                        ? region.repeatOffset.y * cellHeight\n                        : region.repeatOffset.y\n                    : 0);\n                map[repeatName] = chopRegion(image, absoluteX + repeatOffsetX * i, absoluteY + repeatOffsetY * i, absoluteWidth, absoluteHeight);\n            }\n        }\n        else {\n            map[name] = chopRegion(image, absoluteX, absoluteY, absoluteWidth, absoluteHeight);\n        }\n    }\n    return map;\n}\nexports.textureAtlas = textureAtlas;\n/**\n * Chop a rectangular region from an image into a new canvas\n */\nfunction chopRegion(image, x, y, width, height) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    canvas.width = width;\n    canvas.height = height;\n    if (!context) {\n        throw new Error('Failed to get 2D context');\n    }\n    context.drawImage(image, x, y, width, height, 0, 0, width, height);\n    return canvas;\n}\n/**\n * Get the name of a repeating region\n */\nfunction getRepeatingRegionName(regionName, repetitionIndex, regionNameFormat) {\n    return (regionNameFormat !== null && regionNameFormat !== void 0 ? regionNameFormat : DEFAULT_REPEATING_REGION_NAME_FORMAT)\n        .replace('{name}', regionName)\n        .replace('{n}', repetitionIndex.toString());\n}\n// -----------------------------------------------------------------------------\n// CONTENT PROCESSOR\n// -----------------------------------------------------------------------------\n/**\n * Content Manager Processor wrapper which allows the textureAtlas function\n * to be used as a processor in a Content Manager\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function textureAtlasContentProcessor(content, data, imageName) {\n    var _a;\n    if (!isTextureAtlasOptions(data.content)) {\n        throw new Error('Invalid texture atlas options');\n    }\n    const image = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n    if (!image) {\n        throw new Error(`Image '${imageName}' not found`);\n    }\n    const map = textureAtlas(image, data.content);\n    for (const [name, canvas] of Object.entries(map)) {\n        content[`${data.name}_${name}`] = {\n            name,\n            type: 'image',\n            content: canvas,\n            status: 'processed',\n        };\n    }\n}\nexports.textureAtlasContentProcessor = textureAtlasContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/texture-atlas/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.ts"](0, __webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/tile-map/build/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@basementuniverse/tile-map/build/index.js ***!
  \****************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./node_modules/fast-rle/decode.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-rle/decode.js ***!
  \*****************************************/
/***/ ((module) => {

eval("const decode = nums => {\n  const decoded = [];\n  for (let i = 0; i < nums.length; i += 2) {\n    const run_length = nums[i];\n    const value = nums[i + 1];\n    for (let ii = 0; ii < run_length; ii++) {\n      decoded.push(value);\n    }\n  }\n  return decoded;\n};\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/fast-rle/decode.js?");

/***/ }),

/***/ "./node_modules/lru_map/dist/lru.js":
/*!******************************************!*\
  !*** ./node_modules/lru_map/dist/lru.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("!function(g,c){ true?c(exports):0}(this,function(g){const c=Symbol(\"newer\"),e=Symbol(\"older\");class n{constructor(a,b){typeof a!==\"number\"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size))}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error(\"overflow\")}this.newest=b,this.size=this._keymap.size}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear()}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!==\"object\"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c]}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a=\"\",b=this.oldest;b;)a+=String(b.key)+\":\"+b.value,b=b[c],b&&(a+=\" < \");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0}function i(a){this.entry=a}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}}});\n//# sourceMappingURL=lru.js.map\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/lru_map/dist/lru.js?");

/***/ }),

/***/ "./bitmap-decompose.ts":
/*!*****************************!*\
  !*** ./bitmap-decompose.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bitmapToRectangles = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction bitmapToRectangles(bitmap) {\n    const rectangles = [];\n    // Step 1 - create 1-unit tall rectangles for each row\n    for (const [y, row] of bitmap.entries()) {\n        let currentRectangle = null;\n        for (let x = 0; x < row.length; x++) {\n            if (row[x]) {\n                if (!currentRectangle) {\n                    currentRectangle = {\n                        position: (0, vec_1.vec2)(x, y),\n                        size: (0, vec_1.vec2)(1, 1),\n                    };\n                }\n                else {\n                    currentRectangle.size.x++;\n                }\n            }\n            else {\n                if (currentRectangle) {\n                    rectangles.push(currentRectangle);\n                    currentRectangle = null;\n                }\n            }\n        }\n    }\n    // Step 2 - extend each rectangle downwards if possible\n    let pair;\n    while ((pair = findRectangleToExtend(rectangles))) {\n        const [a, b] = pair;\n        rectangles.splice(indexOf(b, rectangles), 1, ...chopRectangle(b, a));\n        a.size.y += b.size.y;\n    }\n    return rectangles;\n}\nexports.bitmapToRectangles = bitmapToRectangles;\n/**\n * Get the index of rectangle a in a list of rectangles\n */\nfunction indexOf(a, rectangles) {\n    return rectangles.findIndex(b => vec_1.vec2.eq(a.position, b.position) && vec_1.vec2.eq(a.size, b.size));\n}\n/**\n * Find a pair of rectangles where the first one can be extended into the\n * second one\n *\n * If no such pair exists, return null\n */\nfunction findRectangleToExtend(rectangles) {\n    for (const a of rectangles) {\n        const b = findRectangleToExtendInto(a, rectangles);\n        if (b) {\n            return [a, b];\n        }\n    }\n    return null;\n}\n/**\n * Find a rectangle which rectangle a can extend into, or null if none can be\n * found\n *\n * A rectangle can extend into another one if the other one is exactly below\n * and their x-axis projections overlap\n */\nfunction findRectangleToExtendInto(a, rectangles) {\n    var _a;\n    return ((_a = rectangles.find(other => \n    // The other rectangle is exactly below the current one\n    other.position.y === a.position.y + a.size.y &&\n        // The other rectangle starts before (or at) the start of the current one\n        other.position.x <= a.position.x &&\n        // The other rectangle ends after (or at) the end of the current one\n        other.position.x + other.size.x >= a.position.x + a.size.x)) !== null && _a !== void 0 ? _a : null);\n}\n/**\n * Subtract rectangle b from rectangle a, ignoring height (i.e. only in the\n * x-axis) and return 0, 1 or 2 resulting rectangles\n */\nfunction chopRectangle(a, b) {\n    const result = [];\n    if (b.position.x > a.position.x) {\n        result.push({\n            position: (0, vec_1.vec2)(a.position.x, a.position.y),\n            size: (0, vec_1.vec2)(b.position.x - a.position.x, a.size.y),\n        });\n    }\n    if (b.position.x + b.size.x < a.position.x + a.size.x) {\n        result.push({\n            position: (0, vec_1.vec2)(b.position.x + b.size.x, a.position.y),\n            size: (0, vec_1.vec2)(a.position.x + a.size.x - (b.position.x + b.size.x), a.size.y),\n        });\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./bitmap-decompose.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tileMapOptionsContentProcessor = exports.TileMap = exports.cameraBoundsSize = exports.cameraBoundsToTileMapBounds = exports.TileAlignment = void 0;\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nconst decode_1 = __importDefault(__webpack_require__(/*! fast-rle/decode */ \"./node_modules/fast-rle/decode.js\"));\nconst lru_map_1 = __webpack_require__(/*! lru_map */ \"./node_modules/lru_map/dist/lru.js\");\nconst bitmap_decompose_1 = __webpack_require__(/*! ./bitmap-decompose */ \"./bitmap-decompose.ts\");\nvar TileAlignment;\n(function (TileAlignment) {\n    TileAlignment[\"TopLeft\"] = \"top-left\";\n    TileAlignment[\"Top\"] = \"top\";\n    TileAlignment[\"TopRight\"] = \"top-right\";\n    TileAlignment[\"Left\"] = \"left\";\n    TileAlignment[\"Center\"] = \"center\";\n    TileAlignment[\"Right\"] = \"right\";\n    TileAlignment[\"BottomLeft\"] = \"bottom-left\";\n    TileAlignment[\"Bottom\"] = \"bottom\";\n    TileAlignment[\"BottomRight\"] = \"bottom-right\";\n})(TileAlignment = exports.TileAlignment || (exports.TileAlignment = {}));\nfunction pointInRectangle(point, topLeft, bottomRight) {\n    return (point.x >= topLeft.x &&\n        point.y >= topLeft.y &&\n        point.x < bottomRight.x &&\n        point.y < bottomRight.y);\n}\nfunction cameraBoundsToTileMapBounds(bounds) {\n    return {\n        topLeft: (0, vec_1.vec2)(bounds.left, bounds.top),\n        bottomRight: (0, vec_1.vec2)(bounds.right, bounds.bottom),\n    };\n}\nexports.cameraBoundsToTileMapBounds = cameraBoundsToTileMapBounds;\nfunction cameraBoundsSize(bounds) {\n    const convertedBounds = cameraBoundsToTileMapBounds(bounds);\n    return vec_1.vec2.sub(convertedBounds.bottomRight, convertedBounds.topLeft);\n}\nexports.cameraBoundsSize = cameraBoundsSize;\nclass TileMap {\n    constructor(options) {\n        const actualOptions = Object.assign({}, TileMap.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        for (const [i, layer] of actualOptions.layers.entries()) {\n            actualOptions.layers[i] = Object.assign({}, TileMap.DEFAULT_LAYER_OPTIONS, layer);\n        }\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showOrigin: !!actualOptions.debug,\n                showChunkBorders: !!actualOptions.debug,\n                showChunkLabels: !!actualOptions.debug,\n                showTileBorders: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        this.chunkBuffer = new lru_map_1.LRUMap(this.options.chunkBufferMaxSize);\n    }\n    /**\n     * Get a (roughly minimal) set of rectangles which cover the tiles in a\n     * given layer\n     *\n     * @param layerName The name of the layer to get rectangles for\n     * @param fieldName We will check the truthyness of this field in the\n     * tile definition\n     * @param tileBounds Optional bounds to check within, relative to bounds\n     * defined in options if any exist, otherwise relative to (0, 0)\n     */\n    getLayerRectangles(layerName, fieldName, tileBounds) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const layer = this.options.layers.find(l => l.name === layerName);\n        if (!layer) {\n            return [];\n        }\n        const topLeft = (_a = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.topLeft) !== null && _a !== void 0 ? _a : (0, vec_1.vec2)(0);\n        const bottomRight = (_b = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.bottomRight) !== null && _b !== void 0 ? _b : (0, vec_1.vec2)(Math.max(...((_d = (_c = layer.data) === null || _c === void 0 ? void 0 : _c.map(row => row.length)) !== null && _d !== void 0 ? _d : [0])), (_f = (_e = layer.data) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0);\n        if (bottomRight.x <= topLeft.x || bottomRight.y <= topLeft.y) {\n            return [];\n        }\n        const bitmap = [];\n        for (let y = topLeft.y; y < bottomRight.y; y++) {\n            const row = [];\n            for (let x = topLeft.x; x < bottomRight.x; x++) {\n                const tileData = (_h = (_g = layer.data) === null || _g === void 0 ? void 0 : _g[y]) === null || _h === void 0 ? void 0 : _h[x];\n                if (tileData === undefined || tileData === -1) {\n                    row.push(false);\n                    continue;\n                }\n                const tile = (_j = layer.tiles) === null || _j === void 0 ? void 0 : _j[tileData];\n                if (!tile) {\n                    row.push(false);\n                    continue;\n                }\n                if (fieldName && !tile[fieldName]) {\n                    row.push(false);\n                    continue;\n                }\n                row.push(true);\n            }\n            bitmap.push(row);\n        }\n        return (0, bitmap_decompose_1.bitmapToRectangles)(bitmap);\n    }\n    /**\n     * Get the tile at a given position and in the specified layer\n     *\n     * If no layer is specified, return a dictionary of layer names to tile\n     * definitions (i.e. return all layers)\n     *\n     * If no tile exists at this position, return null\n     */\n    getTileAtPosition(position, layerName) {\n        if (layerName) {\n            return this.getTileAtPositionInLayer(position, layerName);\n        }\n        const result = {};\n        for (const layer of this.options.layers) {\n            result[layer.name] = this.getTileAtPositionInLayer(position, layer.name);\n        }\n        return result;\n    }\n    getTileAtPositionInLayer(position, layerName) {\n        var _a, _b, _c;\n        const tilePosition = vec_1.vec2.map(vec_1.vec2.mul(position, 1 / this.options.tileSize), Math.floor);\n        const layer = this.options.layers.find(l => l.name === layerName);\n        if (!layer) {\n            return null;\n        }\n        const tileData = (_b = (_a = layer.data) === null || _a === void 0 ? void 0 : _a[tilePosition.y]) === null || _b === void 0 ? void 0 : _b[tilePosition.x];\n        if (tileData === undefined || tileData === -1) {\n            return null;\n        }\n        if (layer.tiles) {\n            return (_c = layer.tiles[tileData]) !== null && _c !== void 0 ? _c : null;\n        }\n        return null;\n    }\n    hashVector(v) {\n        return vec_1.vec2.str(v);\n    }\n    draw(context, a, b, c) {\n        if (b && c) {\n            this.performDraw(context, a, b, c);\n        }\n        else {\n            const screen = cameraBoundsSize(a.bounds);\n            this.performDraw(context, screen, a.actualPosition, a.actualScale, false);\n        }\n    }\n    performDraw(context, screen, position, scale, doTransforms = true) {\n        var _a, _b, _c, _d;\n        const absoluteChunkSize = this.options.tileSize * this.options.chunkSize;\n        const chunkBorder = (0, vec_1.vec2)(this.options.chunkBorder);\n        // Maybe clamp scale\n        let actualScale = scale;\n        if (this.options.minScale && actualScale < this.options.minScale) {\n            actualScale = this.options.minScale;\n        }\n        if (this.options.maxScale && actualScale > this.options.maxScale) {\n            actualScale = this.options.maxScale;\n        }\n        // Maybe clamp position to bounds\n        let actualPosition = (0, vec_1.vec2)(position);\n        if (this.options.bounds && this.options.clampPositionToBounds) {\n            const tileSizeScaled = this.options.tileSize / actualScale;\n            const halfScreenScaled = vec_1.vec2.map(vec_1.vec2.mul(screen, 1 / (actualScale * 2)), Math.ceil);\n            const minPosition = (0, vec_1.vec2)(this.options.bounds.topLeft.x * tileSizeScaled + halfScreenScaled.x, this.options.bounds.topLeft.y * tileSizeScaled + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec2)(this.options.bounds.bottomRight.x * tileSizeScaled - halfScreenScaled.x, this.options.bounds.bottomRight.y * tileSizeScaled - halfScreenScaled.y);\n            actualPosition = (0, vec_1.vec2)((0, utils_1.clamp)(actualPosition.x, minPosition.x, maxPosition.x), (0, utils_1.clamp)(actualPosition.y, minPosition.y, maxPosition.y));\n        }\n        const screenSizeInChunks = vec_1.vec2.map(vec_1.vec2.mul(screen, 1 / (absoluteChunkSize * actualScale)), Math.ceil);\n        const screenCenterChunk = vec_1.vec2.map(vec_1.vec2.mul(actualPosition, 1 / absoluteChunkSize), Math.floor);\n        const topLeftChunk = vec_1.vec2.sub(vec_1.vec2.sub(screenCenterChunk, vec_1.vec2.map(vec_1.vec2.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        const bottomRightChunk = vec_1.vec2.add(vec_1.vec2.add(screenCenterChunk, vec_1.vec2.map(vec_1.vec2.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        context.save();\n        if (doTransforms) {\n            context.scale(actualScale, actualScale);\n            context.translate(-actualPosition.x + screen.x / (actualScale * 2), -actualPosition.y + screen.y / (actualScale * 2));\n        }\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this, screen, actualPosition, actualScale);\n        // Render chunks\n        for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                const chunkPosition = (0, vec_1.vec2)(x, y);\n                const chunkAbsolutePosition = vec_1.vec2.mul(chunkPosition, absoluteChunkSize);\n                // Check if we have this chunk in the cache\n                const chunkHash = this.hashVector(chunkPosition);\n                if (!this.chunkBuffer.has(chunkHash)) {\n                    this.chunkBuffer.set(chunkHash, this.generateChunk(chunkPosition, absoluteChunkSize));\n                }\n                const chunk = this.chunkBuffer.get(chunkHash);\n                if (chunk) {\n                    context.drawImage(chunk.image, chunkAbsolutePosition.x, chunkAbsolutePosition.y);\n                }\n            }\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this, screen, actualPosition, actualScale);\n        // Render debug helpers\n        if (this.options.debug.showTileBorders) {\n            const topLeftTile = vec_1.vec2.mul(vec_1.vec2.sub(screenCenterChunk, vec_1.vec2.add(vec_1.vec2.map(vec_1.vec2.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec2)(1))), this.options.chunkSize);\n            const bottomRightTile = vec_1.vec2.mul(vec_1.vec2.add(screenCenterChunk, vec_1.vec2.add(vec_1.vec2.map(vec_1.vec2.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec2)(1))), this.options.chunkSize);\n            for (let y = topLeftTile.y; y < bottomRightTile.y; y++) {\n                this.drawLine(context, (0, vec_1.vec2)(actualPosition.x - screen.x / (actualScale * 2), y * this.options.tileSize), (0, vec_1.vec2)(actualPosition.x + screen.x / (actualScale * 2), y * this.options.tileSize), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftTile.x; x < bottomRightTile.x; x++) {\n                this.drawLine(context, (0, vec_1.vec2)(x * this.options.tileSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec2)(x * this.options.tileSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkBorders) {\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                this.drawLine(context, (0, vec_1.vec2)(actualPosition.x - screen.x / (actualScale * 2), y * absoluteChunkSize), (0, vec_1.vec2)(actualPosition.x + screen.x / (actualScale * 2), y * absoluteChunkSize), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                this.drawLine(context, (0, vec_1.vec2)(x * absoluteChunkSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec2)(x * absoluteChunkSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkLabels) {\n            context.save();\n            context.fillStyle = TileMap.DEBUG_CHUNK_LABEL_COLOUR;\n            context.font = TileMap.DEBUG_CHUNK_LABEL_FONT;\n            context.textBaseline = 'middle';\n            context.textAlign = 'center';\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                    context.fillText(`${x}, ${y}`, x * absoluteChunkSize + absoluteChunkSize / 2, y * absoluteChunkSize + absoluteChunkSize / 2);\n                }\n            }\n            context.restore();\n        }\n        if (this.options.debug.showOrigin &&\n            pointInRectangle((0, vec_1.vec2)(0, 0), topLeftChunk, bottomRightChunk)) {\n            this.drawCross(context, (0, vec_1.vec2)(0, 0), TileMap.DEBUG_ORIGIN_COLOUR, TileMap.DEBUG_ORIGIN_LINE_WIDTH, TileMap.DEBUG_ORIGIN_SIZE);\n        }\n        context.restore();\n    }\n    generateChunk(chunkPosition, absoluteChunkSize) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const chunkCanvas = document.createElement('canvas');\n        const chunkContext = chunkCanvas.getContext('2d');\n        chunkCanvas.width = absoluteChunkSize;\n        chunkCanvas.height = absoluteChunkSize;\n        let chunk = {\n            chunkPosition,\n            image: chunkCanvas,\n        };\n        const topLeftTile = vec_1.vec2.mul(chunkPosition, this.options.chunkSize);\n        const bottomRightTile = vec_1.vec2.add(topLeftTile, (0, vec_1.vec2)(this.options.chunkSize - 1));\n        const boundsTopLeft = (_b = (_a = this.options.bounds) === null || _a === void 0 ? void 0 : _a.topLeft) !== null && _b !== void 0 ? _b : (0, vec_1.vec2)(0);\n        if (this.options.preGenerateChunk) {\n            const result = this.options.preGenerateChunk(chunkContext, this, {\n                topLeft: topLeftTile,\n                bottomRight: bottomRightTile,\n            }, chunkPosition);\n            if (Array.isArray(result)) {\n                if (!result[1]) {\n                    return chunk;\n                }\n            }\n        }\n        // Default generation, render tiles from tilemap data\n        for (const layer of this.options.layers) {\n            chunkContext.save();\n            chunkContext.globalAlpha = (_c = layer.opacity) !== null && _c !== void 0 ? _c : 1;\n            const alignment = (_d = layer.alignment) !== null && _d !== void 0 ? _d : TileAlignment.Center;\n            for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {\n                for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {\n                    const tilePosition = (0, vec_1.vec2)(x, y);\n                    (_e = layer.preRenderTile) === null || _e === void 0 ? void 0 : _e.call(layer, chunkContext, this, layer, chunkPosition, tilePosition);\n                    const tileDataPosition = vec_1.vec2.sub(tilePosition, boundsTopLeft);\n                    if (tileDataPosition.x < 0 || tileDataPosition.y < 0) {\n                        continue;\n                    }\n                    const tileData = (_g = (_f = layer.data) === null || _f === void 0 ? void 0 : _f[tileDataPosition.y]) === null || _g === void 0 ? void 0 : _g[tileDataPosition.x];\n                    if (tileData === undefined || tileData === -1) {\n                        continue;\n                    }\n                    const tileImage = (_j = (_h = layer.tiles) === null || _h === void 0 ? void 0 : _h[tileData]) === null || _j === void 0 ? void 0 : _j.image;\n                    if (!tileImage) {\n                        continue;\n                    }\n                    const tileAbsolutePosition = vec_1.vec2.sub(vec_1.vec2.mul(tilePosition, this.options.tileSize), vec_1.vec2.mul(chunkPosition, absoluteChunkSize));\n                    // Tile clipping\n                    if (layer.clip) {\n                        chunkContext.save();\n                        chunkContext.beginPath();\n                        chunkContext.rect(tileAbsolutePosition.x, tileAbsolutePosition.y, this.options.tileSize, this.options.tileSize);\n                        chunkContext.clip();\n                    }\n                    // Tile alignment\n                    let tileImageAbsolutePosition;\n                    switch (alignment) {\n                        case TileAlignment.TopLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition);\n                            break;\n                        case TileAlignment.Top:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize / 2 -\n                                tileImage.width / 2, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.TopRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize -\n                                tileImage.width, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.Left:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x, tileAbsolutePosition.y +\n                                this.options.tileSize / 2 -\n                                tileImage.height / 2);\n                            break;\n                        case TileAlignment.Center:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize / 2 -\n                                tileImage.width / 2, tileAbsolutePosition.y +\n                                this.options.tileSize / 2 -\n                                tileImage.height / 2);\n                            break;\n                        case TileAlignment.Right:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize -\n                                tileImage.width, tileAbsolutePosition.y +\n                                this.options.tileSize / 2 -\n                                tileImage.height / 2);\n                            break;\n                        case TileAlignment.BottomLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x, tileAbsolutePosition.y +\n                                this.options.tileSize -\n                                tileImage.height);\n                            break;\n                        case TileAlignment.Bottom:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize / 2 -\n                                tileImage.width / 2, tileAbsolutePosition.y +\n                                this.options.tileSize -\n                                tileImage.height);\n                            break;\n                        case TileAlignment.BottomRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec2)(tileAbsolutePosition.x +\n                                this.options.tileSize -\n                                tileImage.width, tileAbsolutePosition.y +\n                                this.options.tileSize -\n                                tileImage.height);\n                            break;\n                    }\n                    chunkContext.drawImage(tileImage, tileImageAbsolutePosition.x, tileImageAbsolutePosition.y);\n                    if (layer.clip) {\n                        chunkContext.restore();\n                    }\n                    (_k = layer.postRenderTile) === null || _k === void 0 ? void 0 : _k.call(layer, chunkCanvas, chunkContext, this, layer, chunkPosition, tilePosition);\n                }\n            }\n            chunkContext.restore();\n        }\n        (_m = (_l = this.options).postGenerateChunk) === null || _m === void 0 ? void 0 : _m.call(_l, chunkCanvas, chunkContext, this, {\n            topLeft: topLeftTile,\n            bottomRight: bottomRightTile,\n        }, chunkPosition);\n        return chunk;\n    }\n    drawLine(context, start, end, colour, lineWidth) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(start.x, start.y);\n        context.lineTo(end.x, end.y);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.TileMap = TileMap;\nTileMap.DEFAULT_OPTIONS = {\n    clampPositionToBounds: true,\n    tileSize: 16,\n    layers: [\n        {\n            name: 'default',\n        },\n    ],\n    chunkSize: 8,\n    chunkBorder: 1,\n    chunkBufferMaxSize: 64,\n};\nTileMap.DEFAULT_LAYER_OPTIONS = {\n    name: 'default',\n};\nTileMap.DEBUG_ORIGIN_COLOUR = 'cyan';\nTileMap.DEBUG_ORIGIN_LINE_WIDTH = 2;\nTileMap.DEBUG_ORIGIN_SIZE = 10;\nTileMap.DEBUG_CHUNK_BORDER_COLOUR = 'yellow';\nTileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH = 2;\nTileMap.DEBUG_CHUNK_LABEL_COLOUR = 'white';\nTileMap.DEBUG_CHUNK_LABEL_FONT = '12px monospace';\nTileMap.DEBUG_TILE_BORDER_COLOUR = 'orange';\nTileMap.DEBUG_TILE_BORDER_LINE_WIDTH = 1;\n/**\n * Content Manager Processor wrapper which converts TileMapOptionsData into\n * TileMapOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function tileMapOptionsContentProcessor(content, data, options) {\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.layers) {\n        for (const [i, layer] of result.layers.entries()) {\n            // Replace imageName with image in the tile definitions array\n            if (layer.tiles) {\n                for (const [j, tile] of layer.tiles.entries()) {\n                    result.layers[i].tiles[j].image = getImageFromContent(tile.imageName);\n                    delete result.layers[i].tiles[j].imageName;\n                }\n            }\n            // Decompress layer data\n            if ((options === null || options === void 0 ? void 0 : options.decompressData) && layer.data && layer.width) {\n                result.layers[i].data = (0, utils_1.chunk)((0, decode_1.default)(layer.data), layer.width);\n                delete result.layers[i].width;\n            }\n        }\n    }\n    // @ts-ignore\n    data.content = result;\n}\nexports.tileMapOptionsContentProcessor = tileMapOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_75178__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_75178__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_75178__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Memoize a function
 * @param {Function} f The function to memoize
 * @returns {Function} A memoized version of the function
 */
const memoize = f => {
  var cache = {};
  return function(...args) {
    return cache[args] ?? (cache[args] = f.apply(this, args));
  };
};

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all permutations of r elements from an array
 *
 * @example
 * ```js
 * permutations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 1],
 *   [2, 3],
 *   [3, 1],
 *   [3, 2]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each permutation
 * @return {Array<Array<*>>} An array of permutation arrays
 */
const permutations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),
    ],
    []
  );
}

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {...Array<*>} a The arrays to zip
 * @return {Array<Array<*>>}
 */
const zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a The array to access
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Return the index for a given position in an unrolled 2d array
 * @param {number} x The x position
 * @param {number} y The y position
 * @param {number} w The width of the 2d array
 * @returns {number} The index in the unrolled array
 */
const ind = (x, y, w) => x + y * w;

/**
 * Return the position for a given index in an unrolled 2d array
 * @param {number} i The index
 * @param {number} w The width of the 2d array
 * @returns {Array<number>} The position as a 2-tuple
 */
const pos = (i, w) => [i % w, Math.floor(i / w)];

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    memoize,
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    permutations,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    ind,
    pos,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

const _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));
const _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));
const _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);
const _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;
const _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;

/**
 * A 2d vector
 * @typedef {Object} vec2
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new 2d vector
 * @param {number|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec2} A new 2d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec2(3, 2); // (3, 2)
 * let b = vec2(4);    // (4, 4)
 * let c = vec2(a);    // (3, 2)
 * let d = vec2();     // (0, 0)
 */
const vec2 = (x, y) => {
  if (!x && !y) {
    return { x: 0, y: 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0 };
  }
  return { x: x, y: y ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec2} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec2.components = a => [a.x, a.y];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec2} A new vector
 */
vec2.fromComponents = components => vec2(...components.slice(0, 2));

/**
 * Return a unit vector (1, 0)
 * @return {vec2} A unit vector (1, 0)
 */
vec2.ux = () => vec2(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec2} A unit vector (0, 1)
 */
vec2.uy = () => vec2(0, 1);

/**
 * Add vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a + b
 */
vec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });

/**
 * Subtract vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a - b
 */
vec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });

/**
 * Scale a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a * b
 */
vec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });

/**
 * Scale a vector by a scalar, alias for vec2.mul
 * @param {vec2} a Vector a
 * @param {number} b Scalar b
 * @return {vec2} a * b
 */
vec2.scale = (a, b) => vec2.mul(a, b);

/**
 * Divide a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a / b
 */
vec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });

/**
 * Get the length of a vector
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec2} a The vector to normalise
 * @return {vec2} ^a
 */
vec2.nor = a => {
  let len = vec2.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec2();
};

/**
 * Get a dot product of vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a ∙ b
 */
vec2.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec2} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec2} A rotated vector
 */
vec2.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
};

/**
 * Fast method to rotate a vector by -90, 90 or 180 degrees
 * @param {vec2} a The vector to rotate
 * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees
 * @return {vec2} A rotated vector
 */
vec2.rotf = (a, r) => {
  switch (r) {
    case 1: return vec2(a.y, -a.x);
    case -1: return vec2(-a.y, a.x);
    case 2: case -2: return vec2(-a.x, -a.y);
    default: return a;
  }
};

/**
 * Scalar cross product of two vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a × b
 */
vec2.cross = (a, b) => {
  return a.x * b.y - a.y * b.x;
};

/**
 * Check if two vectors are equal
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec2.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec2} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec2.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec2} a The vector to copy
 * @return {vec2} A copy of vector a
 */
vec2.cpy = a => vec2(a);

/**
 * A function to call on each component of a 2d vector
 * @callback vec2MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec2} a Vector a
 * @param {vec2MapCallback} f The function to call on each component of the vector
 * @return {vec2} Vector a mapped through f
 */
vec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec2} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x` or `y`
 * - `u` or `v` (aliases for `x` and `y`, respectively)
 * - `X`, `Y`, `U`, `V` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec2} a The vector to swizzle
 * @param {string} [s='..'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec2(3, -2);
 * vec2.swiz(a, 'x');    // [3]
 * vec2.swiz(a, 'yx');   // [-2, 3]
 * vec2.swiz(a, 'xY');   // [3, 2]
 * vec2.swiz(a, 'Yy');   // [2, -2]
 * vec2.swiz(a, 'x.x');  // [3, -2, 3]
 * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]
 */
vec2.swiz = (a, s = '..') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': result.push(a.x); break;
      case 'y': case 'v': result.push(a.y); break;
      case 'X': case 'U': result.push(-a.x); break;
      case 'Y': case 'V': result.push(-a.y); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 2d vector
 * @typedef {Object} polarCoordinates2d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec2} a The vector to convert
 * @return {polarCoordinates2d} The magnitude and angle of the vector
 */
vec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The angle of the vector
 * @return {vec2} A vector with the given angle and magnitude
 */
vec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));

/**
 * A 3d vector
 * @typedef {Object} vec3
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 * @property {number} z The z component of the vector
 */

/**
 * Create a new 3d vector
 * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector, or the z component if x is a vec2
 * @param {number} [z] The z component of the vector
 * @return {vec3} A new 3d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec3(3, 2, 1);       // (3, 2, 1)
 * let b = vec3(4, 5);          // (4, 5, 0)
 * let c = vec3(6);             // (6, 6, 6)
 * let d = vec3(a);             // (3, 2, 1)
 * let e = vec3();              // (0, 0, 0)
 * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)
 * let g = vec3(vec2(4, 5));    // (4, 5, 0)
 */
const vec3 = (x, y, z) => {
  if (!x && !y && !z) {
    return { x: 0, y: 0, z: 0 };
  }
  if (_vec_is_vec3(x)) {
    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0, z: y || 0 };
  }
  return { x: x, y: y ?? x, z: z ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec3} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec3.components = a => [a.x, a.y, a.z];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec3} A new vector
 */
vec3.fromComponents = components => vec3(...components.slice(0, 3));

/**
 * Return a unit vector (1, 0, 0)
 * @return {vec3} A unit vector (1, 0, 0)
 */
vec3.ux = () => vec3(1, 0, 0);

/**
 * Return a unit vector (0, 1, 0)
 * @return {vec3} A unit vector (0, 1, 0)
 */
vec3.uy = () => vec3(0, 1, 0);

/**
 * Return a unit vector (0, 0, 1)
 * @return {vec3} A unit vector (0, 0, 1)
 */
vec3.uz = () => vec3(0, 0, 1);

/**
 * Add vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a + b
 */
vec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });

/**
 * Subtract vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a - b
 */
vec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });

/**
 * Scale a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a * b
 */
vec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });

/**
 * Scale a vector by a scalar, alias for vec3.mul
 * @param {vec3} a Vector a
 * @param {number} b Scalar b
 * @return {vec3} a * b
 */
vec3.scale = (a, b) => vec3.mul(a, b);

/**
 * Divide a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a / b
 */
vec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });

/**
 * Get the length of a vector
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);

/**
 * Normalise a vector
 * @param {vec3} a The vector to normalise
 * @return {vec3} ^a
 */
vec3.nor = a => {
  let len = vec3.len(a);
  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();
};

/**
 * Get a dot product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {number} a ∙ b
 */
vec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

/**
 * Rotate a vector using a rotation matrix
 * @param {vec3} a The vector to rotate
 * @param {mat} m The rotation matrix
 * @return {vec3} A rotated vector
 */
vec3.rot = (a, m) => vec3(
  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)
);

/**
 * Rotate a vector by r radians around the x axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotx = (a, r) => vec3(
  a.x,
  a.y * Math.cos(r) - a.z * Math.sin(r),
  a.y * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the y axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.roty = (a, r) => vec3(
  a.x * Math.cos(r) + a.z * Math.sin(r),
  a.y,
  -a.x * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the z axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotz = (a, r) => vec3(
  a.x * Math.cos(r) - a.y * Math.sin(r),
  a.x * Math.sin(r) + a.y * Math.cos(r),
  a.z
);

/**
 * Rotate a vector using a quaternion
 * @param {vec3} a The vector to rotate
 * @param {Array<number>} q The quaternion to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rotq = (v, q) => {
  if (q.length !== 4) {
    return vec3();
  }

  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
  if (d === 0) {
    return vec3();
  }

  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];
  const u = vec3(...uq.slice(0, 3));
  const s = uq[3];
  return vec3.add(
    vec3.add(
      vec3.mul(u, 2 * vec3.dot(u, v)),
      vec3.mul(v, s * s - vec3.dot(u, u))
    ),
    vec3.mul(vec3.cross(u, v), 2 * s)
  );
};

/**
 * Rotate a vector using Euler angles
 * @param {vec3} a The vector to rotate
 * @param {vec3} e The Euler angles to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);

/**
 * Get the cross product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {vec3} a × b
 */
vec3.cross = (a, b) => vec3(
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
);

/**
 * Check if two vectors are equal
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;

/**
 * Get the angle of a vector from the x axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radx = a => Math.atan2(a.z, a.y);

/**
 * Get the angle of a vector from the y axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.rady = a => Math.atan2(a.x, a.y);

/**
 * Get the angle of a vector from the z axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radz = a => Math.atan2(a.y, a.z);

/**
 * Copy a vector
 * @param {vec3} a The vector to copy
 * @return {vec3} A copy of vector a
 */
vec3.cpy = a => vec3(a);

/**
 * A function to call on each component of a 3d vector
 * @callback vec3MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y' | 'z'} label The component label (x, y or z)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec3} a Vector a
 * @param {vec3MapCallback} f The function to call on each component of the vector
 * @return {vec3} Vector a mapped through f
 */
vec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });

/**
 * Convert a vector into a string
 * @param {vec3} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x`, `y` or `z`
 * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)
 * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)
 * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec3} a The vector to swizzle
 * @param {string} [s='...'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec3(3, -2, 1);
 * vec3.swiz(a, 'x');     // [3]
 * vec3.swiz(a, 'zyx');   // [1, -2, 3]
 * vec3.swiz(a, 'xYZ');   // [3, 2, -1]
 * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]
 * vec3.swiz(a, 'x.x');   // [3, -2, 3]
 * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]
 */
vec3.swiz = (a, s = '...') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': case 'r': result.push(a.x); break;
      case 'y': case 'v': case 'g': result.push(a.y); break;
      case 'z': case 'w': case 'b': result.push(a.z); break;
      case 'X': case 'U': case 'R': result.push(-a.x); break;
      case 'Y': case 'V': case 'G': result.push(-a.y); break;
      case 'Z': case 'W': case 'B': result.push(-a.z); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 3d vector
 * @typedef {Object} polarCoordinates3d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The tilt angle of the vector
 * @property {number} phi The pan angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec3} a The vector to convert
 * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector
 */
vec3.polar = a => {
  let r = vec3.len(a),
    theta = Math.acos(a.y / r),
    phi = Math.atan2(a.z, a.x);
  return { r, theta, phi };
};

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The tilt of the vector
 * @param {number} phi The pan of the vector
 * @return {vec3} A vector with the given angle and magnitude
 */
vec3.fromPolar = (r, theta, phi) => {
  const sinTheta = Math.sin(theta);
  return vec3(
    r * sinTheta * Math.cos(phi),
    r * Math.cos(theta),
    r * sinTheta * Math.sin(phi)
  );
};

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|false} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Multiply a matrix by a vector
 * @param {mat} a Matrix a
 * @param {vec2|vec3|number[]} b Vector b
 * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied
 */
mat.mulv = (a, b) => {
  let n, bb, rt;
  if (_vec_is_vec3(b)) {
    bb = vec3.components(b);
    n = 3;
    rt = vec3.fromComponents;
  } else if (_vec_is_vec2(b)) {
    bb = vec2.components(b);
    n = 2;
    rt = vec2.fromComponents;
  } else {
    bb = b;
    n = b.length ?? 0;
    rt = v => v;
  }
  if (a.n !== n) { return false; }
  const result = [];
  for (let i = 1; i <= a.m; i++) {
    result.push(_vec_dot(mat.row(a, i), bb));
  }
  return rt(result);
}

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|false} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|false} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|false} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec2, vec3, mat };
}


/***/ }),

/***/ "./node_modules/shader-canvas/dist/shader-canvas.js":
/*!**********************************************************!*\
  !*** ./node_modules/shader-canvas/dist/shader-canvas.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderCanvas": () => (/* binding */ ShaderCanvas)
/* harmony export */ });
const defaultVertexShader = `
  #ifdef GL_ES
  precision mediump float;
  #endif
  attribute vec2 position;
  void main() {
    gl_Position = vec4(position, 0.0, 1.0);
  }
`;
const defaultFragmentShader = `
  #ifdef GL_ES
  precision mediump float;
  #endif
  void main() {
    gl_FragColor = vec4(0.0);
  }
`;
class ShaderCanvas {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.textures = {};
        this.domElement = document.createElement("canvas");
        const gl = this.domElement.getContext("webgl");
        if (!gl) {
            throw new Error("failed to get webgl context");
        }
        this.gl = gl;
        const vs = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (!vs) {
            throw new Error("failed to create vertex shader");
        }
        this.vertexShader = vs;
        const vsErrs = compileShader(this.gl, this.vertexShader, defaultVertexShader);
        if (vsErrs) {
            throw new Error("failed to compile vertex shader");
        }
        const fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        if (!fs) {
            throw new Error("failed to create fragment shader");
        }
        this.fragmentShader = fs;
        const fsErrs = compileShader(this.gl, this.fragmentShader, defaultFragmentShader);
        if (fsErrs) {
            throw new Error("failed to compile vertex shader");
        }
        this.shaderProgram = createShaderProgram(this.gl, this.vertexShader, this.fragmentShader);
        bindPositionAttribute(this.gl, this.shaderProgram);
        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
        this.gl.useProgram(this.shaderProgram);
        this.setSize(400, 400);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        const dpr = window.devicePixelRatio;
        this.domElement.width = width * dpr;
        this.domElement.height = height * dpr;
        this.domElement.style.width = width + "px";
        this.domElement.style.height = height + "px";
        this.gl.viewport(0, 0, this.domElement.width, this.domElement.height);
    }
    // getResolution is a convenience method for getting a vec2 representing the
    // size in physical pixels of the canvas.
    // Typical usage is:
    //   shaderCanvas.setUniform("u_resolution", shaderCanvas.getResolution());
    getResolution() {
        return [
            this.domElement.width,
            this.domElement.height,
        ];
    }
    setShader(source) {
        const gl = this.gl;
        const errs = compileShader(gl, this.fragmentShader, source);
        if (errs) {
            return errs;
        }
        gl.linkProgram(this.shaderProgram);
        if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(this.shaderProgram));
            throw new Error("failed to link program");
        }
    }
    testUniform(name) {
        const location = this.gl.getUniformLocation(this.shaderProgram, name);
        return location !== null;
    }
    setUniform(name, value) {
        // TODO: validate name?
        // TODO OPTIMIZE: cache uniform location
        const location = this.gl.getUniformLocation(this.shaderProgram, name);
        if (location === null) {
            throw new Error(`uniform location for ${name} not found`);
        }
        if (typeof value === "number") {
            this.gl.uniform1f(location, value);
            return;
        }
        switch (value.length) {
            case 2:
                this.gl.uniform2fv(location, value);
                break;
            case 3:
                this.gl.uniform3fv(location, value);
                break;
            case 4:
                this.gl.uniform4fv(location, value);
                break;
        }
    }
    // TODO: accept options, like format, filter, wrap, etc.
    setTexture(name, image) {
        // TODO: validate name?
        const gl = this.gl;
        let t = this.textures[name];
        if (!t) {
            const glTexture = gl.createTexture();
            if (!glTexture) {
                throw new Error(`unable to create glTexture`);
            }
            t = {
                glTexture,
                unit: lowestUnused(Object.keys(this.textures).map((k) => this.textures[k].unit)),
            };
            this.textures[name] = t;
        }
        gl.activeTexture(gl.TEXTURE0 + t.unit);
        gl.bindTexture(gl.TEXTURE_2D, t.glTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        const location = gl.getUniformLocation(this.shaderProgram, name);
        if (location === null) {
            throw new Error(`uniform location for texture ${name} not found`);
        }
        gl.uniform1i(location, t.unit);
    }
    render() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
}
function compileShader(gl, shader, source) {
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        return;
    }
    const info = gl.getShaderInfoLog(shader);
    if (!info) {
        throw new Error("failed to compile, but found no error log");
    }
    console.error(info);
    return parseErrorMessages(info);
}
function createShaderProgram(gl, vs, fs) {
    const program = gl.createProgram();
    if (program === null) {
        throw new Error("failed to create shader program");
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        console.error(info);
        throw new Error("failed to link program");
    }
    return program;
}
function bindPositionAttribute(gl, program) {
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const positions = new Float32Array([
        -1.0, -1.0,
        -1.0, 1.0,
        1.0, -1.0,
        1.0, 1.0,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    const positionLocation = gl.getAttribLocation(program, "position");
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);
}
function parseErrorMessages(msg) {
    const errorRegex = /^ERROR: \d+:(\d+).*$/mg;
    const messages = [];
    let match = errorRegex.exec(msg);
    while (match) {
        messages.push({
            text: match[0],
            lineNumber: parseInt(match[1], 10),
        });
        // Look for another error:
        match = errorRegex.exec(msg);
    }
    return messages;
}
// This is a flavor of Shlemiel the painter's algorithm.
// http://wiki.c2.com/?ShlemielThePainter
//
// TODO: figure out how to run tests, but I've spot checked these:
//   [] => 0
//   [0, 1, 2, 3, 4] => 5
//   [0, 1, 3, 4] => 2
//   [1, 3, 4] => 0
//   [4] => 0
//   [4, 3, 2, 1, 0] => 5
//   [4, 2, 1, 0] => 3
//   [4, 2, 1, 10] => 0
//   [2, 0, 3, 4] => 1
function lowestUnused(xs) {
    let unused = 0;
    for (let i = 0; i < xs.length; i++) {
        if (xs[i] === unused) {
            unused++;
            i = -1; // go back to the beginning
        }
    }
    return unused;
}


/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const LoadingScene_1 = __webpack_require__(/*! ./scenes/LoadingScene */ "./src/scenes/LoadingScene.ts");
const config = __webpack_require__(/*! ./config.json */ "./src/config.json");
const constants = __webpack_require__(/*! ./constants */ "./src/constants.ts");
const shader_content_processor_1 = __webpack_require__(/*! ./content-processors/shader.content-processor */ "./src/content-processors/shader.content-processor.ts");
const texture_atlas_1 = __webpack_require__(/*! @basementuniverse/texture-atlas */ "./node_modules/@basementuniverse/texture-atlas/build/index.js");
const tile_map_1 = __webpack_require__(/*! @basementuniverse/tile-map */ "./node_modules/@basementuniverse/tile-map/build/index.js");
const sprite_1 = __webpack_require__(/*! @basementuniverse/sprite */ "./node_modules/@basementuniverse/sprite/build/index.js");
const image_font_1 = __webpack_require__(/*! @basementuniverse/image-font */ "./node_modules/@basementuniverse/image-font/build/index.js");
class Game {
    constructor(container) {
        this.frameRate = 0;
        this.frameCount = 0;
        if (container === null) {
            throw new Error('A valid container element must be specified.');
        }
        if (container.tagName.toLowerCase() !== 'canvas') {
            throw new Error('Container element must be a canvas.');
        }
        this.canvas = container;
        const context = this.canvas.getContext('2d');
        if (context !== null) {
            this.context = context;
        }
        else {
            throw new Error("Couldn't get a 2d context.");
        }
        window.addEventListener('resize', this.resize.bind(this), false);
        this.resize();
    }
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    initialise() {
        content_manager_1.default.initialise({
            simulateSlowLoading: constants.DEBUG,
            slowLoadingTimeMin: 100,
            slowLoadingTimeMax: 500,
            processors: {
                shader: shader_content_processor_1.ShaderProcessor,
                textureAtlas: texture_atlas_1.textureAtlasContentProcessor,
                tileMap: tile_map_1.tileMapOptionsContentProcessor,
                sprite: sprite_1.spriteOptionsContentProcessor,
                imageFont: image_font_1.imageFontContentProcessor,
            },
            throwOnNotFound: true,
        });
        debug_1.default.initialise({
            lineMargin: 5,
        });
        input_manager_1.default.initialise();
        scene_manager_1.default.initialise();
        this.lastFrameTime = this.lastFrameCountTime = performance.now();
        this.loop();
        scene_manager_1.default.push(new LoadingScene_1.default());
    }
    loop() {
        const now = performance.now();
        const elapsedTime = Math.min(now - this.lastFrameTime, constants.FPS_MIN);
        if (now - this.lastFrameCountTime >= 1000) {
            this.lastFrameCountTime = now;
            this.frameRate = this.frameCount;
            this.frameCount = 0;
        }
        this.frameCount++;
        this.lastFrameTime = now;
        if (config.showFPS) {
            debug_1.default.value('FPS', this.frameRate, { align: 'right' });
            debug_1.default.chart('FPS', this.frameRate, { minValue: 0, maxValue: 70 });
        }
        this.update(elapsedTime);
        this.draw();
        window.requestAnimationFrame(this.loop.bind(this));
    }
    update(dt) {
        Game.screen = (0, vec_1.vec2)(this.canvas.width, this.canvas.height);
        debug_1.default.value('status', content_manager_1.default.status);
        debug_1.default.value('progress', content_manager_1.default.progress);
        scene_manager_1.default.update(dt);
        input_manager_1.default.update();
    }
    draw() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        scene_manager_1.default.draw(this.context);
    }
}
exports["default"] = Game;


/***/ }),

/***/ "./src/actors/Actor.ts":
/*!*****************************!*\
  !*** ./src/actors/Actor.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/actors/Player.ts":
/*!******************************!*\
  !*** ./src/actors/Player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Player = void 0;
const sprite_1 = __webpack_require__(/*! @basementuniverse/sprite */ "./node_modules/@basementuniverse/sprite/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
class Player {
    constructor(position, direction, spriteData) {
        this.position = position;
        this.direction = direction;
        this.sprite = new sprite_1.Sprite({
            ...spriteData,
            position,
            defaultDirection: direction,
        });
    }
    update(dt) {
        var _a;
        const moveVector = (0, vec_1.vec2)();
        if (input_manager_1.default.keyDown('ArrowUp')) {
            moveVector.y--;
        }
        if (input_manager_1.default.keyDown('ArrowDown')) {
            moveVector.y++;
        }
        if (input_manager_1.default.keyDown('ArrowLeft')) {
            moveVector.x--;
        }
        if (input_manager_1.default.keyDown('ArrowRight')) {
            moveVector.x++;
        }
        this.position = vec_1.vec2.add(this.position, vec_1.vec2.mul(moveVector, Player.SPEED * dt));
        this.position.x = (0, utils_1.clamp)(this.position.x, 0, 1024);
        this.position.y = (0, utils_1.clamp)(this.position.y, 0, 1024);
        const moving = !vec_1.vec2.eq(moveVector, (0, vec_1.vec2)());
        if (moving) {
            this.direction = ((_a = Player.DIRECTION_MAP[vec_1.vec2.str(moveVector)]) !== null && _a !== void 0 ? _a : 's');
        }
        this.sprite.position = vec_1.vec2.cpy(this.position);
        this.sprite.direction = this.direction;
        this.sprite.animation = moving ? 'walk' : 'idle';
        this.sprite.update(dt);
    }
    draw(context) {
        this.sprite.draw(context);
    }
}
exports.Player = Player;
Player.SPEED = 40;
Player.DIRECTION_MAP = {
    ['1, 0']: 'e',
    ['1, 1']: 'se',
    ['0, 1']: 's',
    ['-1, 1']: 'sw',
    ['-1, 0']: 'w',
    ['-1, -1']: 'nw',
    ['0, -1']: 'n',
    ['1, -1']: 'ne',
};


/***/ }),

/***/ "./src/actors/ProgressBar.ts":
/*!***********************************!*\
  !*** ./src/actors/ProgressBar.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressBar = void 0;
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
class ProgressBar {
    constructor(position, size) {
        this.position = position;
        this.size = size;
        this.progress = 0;
        this.displayProgress = 0;
    }
    update(dt) {
        this.displayProgress += (this.progress - this.displayProgress) * ProgressBar.EASE_AMOUNT * dt;
        if (Math.abs(this.displayProgress - this.progress) <= 0.001) {
            this.displayProgress = this.progress;
        }
    }
    draw(context) {
        context.save();
        context.strokeStyle = ProgressBar.COLOUR;
        context.fillStyle = ProgressBar.COLOUR;
        context.lineWidth = 2;
        const topLeft = vec_1.vec2.sub(this.position, vec_1.vec2.mul(this.size, 1 / 2));
        context.strokeRect(topLeft.x, topLeft.y, this.size.x, this.size.y);
        context.fillRect(topLeft.x, topLeft.y, Math.floor(this.displayProgress * this.size.x), this.size.y);
        context.restore();
    }
}
exports.ProgressBar = ProgressBar;
ProgressBar.EASE_AMOUNT = 1.5;
ProgressBar.COLOUR = 'white';


/***/ }),

/***/ "./src/actors/index.ts":
/*!*****************************!*\
  !*** ./src/actors/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Actor */ "./src/actors/Actor.ts"), exports);
__exportStar(__webpack_require__(/*! ./Player */ "./src/actors/Player.ts"), exports);
__exportStar(__webpack_require__(/*! ./ProgressBar */ "./src/actors/ProgressBar.ts"), exports);


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FPS_MIN = exports.DEBUG = void 0;
exports.DEBUG = true;
exports.FPS_MIN = 1 / 30;


/***/ }),

/***/ "./src/content-processors/shader.content-processor.ts":
/*!************************************************************!*\
  !*** ./src/content-processors/shader.content-processor.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShaderProcessor = void 0;
const shader_canvas_1 = __webpack_require__(/*! shader-canvas */ "./node_modules/shader-canvas/dist/shader-canvas.js");
const ShaderProcessor = async (content, item) => {
    const shaderCanvas = new shader_canvas_1.ShaderCanvas();
    shaderCanvas.setShader(item.content);
    item.content = shaderCanvas;
};
exports.ShaderProcessor = ShaderProcessor;


/***/ }),

/***/ "./src/scenes/GameScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/GameScene.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const camera_1 = __webpack_require__(/*! @basementuniverse/camera */ "./node_modules/@basementuniverse/camera/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const tile_map_1 = __webpack_require__(/*! @basementuniverse/tile-map */ "./node_modules/@basementuniverse/tile-map/build/index.js");
const actors_1 = __webpack_require__(/*! ../actors */ "./src/actors/index.ts");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class GameScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: GameScene.TRANSITION_TIME,
            onTransitionedOut: () => {
                debug_1.default.removeChart('Camera Scale');
                debug_1.default.removeChart('Wave');
            },
        });
    }
    initialise() {
        this.camera = new camera_1.default(GameScene.STARTING_POSITION, {
            minScale: 0.5,
            maxScale: 5,
            bounds: {
                top: 0,
                left: 0,
                right: 1024,
                bottom: 1024,
            },
            moveEaseAmount: 0.95,
            scaleEaseAmount: 0.95,
        });
        this.camera.scaleImmediate = 3;
        this.map = new tile_map_1.TileMap(content_manager_1.default.get('tile-map'));
        this.player = new actors_1.Player(GameScene.STARTING_POSITION, 's', content_manager_1.default.get('character-sprite'));
    }
    update(dt) {
        if (input_manager_1.default.keyPressed('Escape')) {
            scene_manager_1.default.pop();
        }
        if (input_manager_1.default.mouseWheelUp()) {
            this.camera.scale += 0.1;
        }
        if (input_manager_1.default.mouseWheelDown()) {
            this.camera.scale -= 0.1;
        }
        debug_1.default.chart('Camera Scale', this.camera.scale, {
            minValue: 0.5,
            maxValue: 5,
            barColours: [
                {
                    offset: 1,
                    colour: '#f00',
                },
                {
                    offset: 2.5,
                    colour: '#f50',
                },
                {
                    offset: 4,
                    colour: '#f90',
                },
            ]
        });
        debug_1.default.chart('Wave', Math.sin(performance.now() / 1000) + 1, {
            minValue: 0,
            maxValue: 2,
            valueBufferSize: 1500,
            valueBufferStride: 30,
        });
        debug_1.default.border('test1', '', (0, vec_1.vec2)(200), {
            space: 'screen',
            size: (0, vec_1.vec2)(200, 200),
            borderColour: '#f82',
            borderStyle: 'dashed',
            borderWidth: 4,
        });
        debug_1.default.border('test2', '', (0, vec_1.vec2)(100), {
            space: 'world',
            radius: 200,
            borderShape: 'circle',
            borderColour: '#5f5',
            borderStyle: 'dotted',
            showLabel: false,
        });
        debug_1.default.marker('player', vec_1.vec2.str(vec_1.vec2.map(this.player.position, Math.floor)), vec_1.vec2.add(this.player.position, (0, vec_1.vec2)(0, 30)), {
            markerStyle: 'x',
            markerColour: '#ff0',
            showLabel: false,
            showValue: true,
        });
        this.player.update(dt);
        this.camera.position = vec_1.vec2.cpy(this.player.position);
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        context.fillStyle = '#ccc';
        context.fillRect(0, 0, Game_1.default.screen.x, Game_1.default.screen.y);
        context.save();
        this.camera.draw(context, Game_1.default.screen);
        this.map.draw(context, this.camera);
        this.player.draw(context);
        debug_1.default.draw(context);
        context.restore();
        context.restore();
    }
}
exports["default"] = GameScene;
GameScene.TRANSITION_TIME = 1;
GameScene.STARTING_POSITION = (0, vec_1.vec2)(512, 512);


/***/ }),

/***/ "./src/scenes/IntroScene.ts":
/*!**********************************!*\
  !*** ./src/scenes/IntroScene.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const MenuScene_1 = __webpack_require__(/*! ./MenuScene */ "./src/scenes/MenuScene.ts");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class IntroScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: IntroScene.TRANSITION_TIME,
        });
        this.time = 0;
    }
    initialise() {
        const shader = content_manager_1.default.get('blur-shader');
        if (shader) {
            this.shader = shader;
        }
        const logo = content_manager_1.default.get('basement-universe');
        if (logo) {
            this.logo = logo;
            this.shader.setSize(this.logo.width, this.logo.height);
            this.shader.setTexture('u_mainTex', this.logo);
            this.shader.setUniform('u_resolution', this.shader.getResolution());
        }
    }
    update(dt) {
        this.time += dt;
        if (this.time > IntroScene.COOLDOWN_TIME ||
            input_manager_1.default.keyPressed() ||
            input_manager_1.default.mousePressed()) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new MenuScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        if (this.shader) {
            this.shader.setUniform('u_sigma', 1 - this.transitionAmount);
            this.shader.render();
            context.drawImage(this.shader.domElement, Game_1.default.screen.x / 2 - this.logo.width / 2, Game_1.default.screen.y / 2 - this.logo.height / 2, this.logo.width, this.logo.height);
        }
        debug_1.default.draw(context);
        context.restore();
    }
}
exports["default"] = IntroScene;
IntroScene.TRANSITION_TIME = 2;
IntroScene.COOLDOWN_TIME = 8;


/***/ }),

/***/ "./src/scenes/LoadingScene.ts":
/*!************************************!*\
  !*** ./src/scenes/LoadingScene.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const constants = __webpack_require__(/*! ../constants */ "./src/constants.ts");
const content = __webpack_require__(/*! ../../content/content.json */ "./content/content.json");
const IntroScene_1 = __webpack_require__(/*! ./IntroScene */ "./src/scenes/IntroScene.ts");
const actors_1 = __webpack_require__(/*! ../actors */ "./src/actors/index.ts");
const debug_1 = __webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js");
class LoadingScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: LoadingScene.TRANSITION_TIME,
        });
        this.cooldownTime = 0;
    }
    initialise() {
        this.finishedLoadingContent = false;
        this.progressBar = new actors_1.ProgressBar(vec_1.vec2.map(vec_1.vec2.mul(Game_1.default.screen, 1 / 2), Math.floor), (0, vec_1.vec2)(200, 40));
        this.cooldownTime = LoadingScene.COOLDOWN_TIME;
        content_manager_1.default.load(content).then(() => {
            this.finishedLoadingContent = true;
        }).catch((error) => {
            constants.DEBUG && console.log(`Unable to load content: ${error}`);
        });
    }
    update(dt) {
        this.progressBar.position = vec_1.vec2.map(vec_1.vec2.mul(Game_1.default.screen, 1 / 2), Math.floor);
        this.progressBar.progress = content_manager_1.default.progress;
        this.progressBar.update(dt);
        if (this.finishedLoadingContent) {
            this.cooldownTime -= dt;
        }
        if (this.cooldownTime <= 0) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new IntroScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        this.progressBar.draw(context);
        debug_1.default.draw(context);
        context.restore();
    }
}
exports["default"] = LoadingScene;
LoadingScene.TRANSITION_TIME = 0.5;
LoadingScene.COOLDOWN_TIME = 2.5;


/***/ }),

/***/ "./src/scenes/MenuScene.ts":
/*!*********************************!*\
  !*** ./src/scenes/MenuScene.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ../Game */ "./src/Game.ts");
const scene_manager_1 = __webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const input_manager_1 = __webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js");
const content_manager_1 = __webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js");
const GameScene_1 = __webpack_require__(/*! ./GameScene */ "./src/scenes/GameScene.ts");
class MenuScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: MenuScene.TRANSITION_TIME,
        });
    }
    initialise() {
        const background = content_manager_1.default.get('menu-background');
        if (background) {
            this.background = background;
        }
        const title = content_manager_1.default.get('menu-title');
        if (title) {
            this.title = title;
        }
        const menuFont = content_manager_1.default.get('menu-font');
        if (menuFont) {
            this.menuFont = menuFont;
        }
    }
    update(dt) {
        if (input_manager_1.default.keyPressed() || input_manager_1.default.mousePressed()) {
            scene_manager_1.default.push(new GameScene_1.default());
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        const largestScreenDimension = Math.max(Game_1.default.screen.x, Game_1.default.screen.y);
        const aspectRatio = this.background.width / this.background.height;
        const backgroundSize = (0, vec_1.vec2)(largestScreenDimension * aspectRatio, largestScreenDimension);
        if (this.background) {
            context.drawImage(this.background, Game_1.default.screen.x / 2 - backgroundSize.x / 2, Game_1.default.screen.y / 2 - backgroundSize.y / 2, largestScreenDimension * aspectRatio, largestScreenDimension);
        }
        if (this.title) {
            const y = (0, utils_1.lerp)(-300, Game_1.default.screen.y / 2 - 200, this.transitionAmount);
            context.drawImage(this.title, Game_1.default.screen.x / 2 - this.title.width / 2, y);
        }
        if (this.menuFont) {
            const text = 'PRESS ANY KEY TO START...';
            const y = (0, utils_1.lerp)(Game_1.default.screen.y + 100, Game_1.default.screen.y / 2 + 100, this.transitionAmount);
            this.menuFont.drawText(context, text, Game_1.default.screen.x / 2, y, {
                align: 'center',
                scale: 0.7,
            });
        }
        context.restore();
    }
}
exports["default"] = MenuScene;
MenuScene.TRANSITION_TIME = 1;


/***/ }),

/***/ "./content/content.json":
/*!******************************!*\
  !*** ./content/content.json ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"name":"basement-universe","type":"image","args":["./content/basement-universe.png"]},{"name":"bleep","type":"audio","args":["./content/bleep.wav"]},{"name":"blur-shader","type":"text","args":["url:content/blur.glsl"],"processors":[{"name":"shader"}]},{"name":"menu-background","type":"image","args":["./content/menu-background.png"]},{"name":"menu-title","type":"image","args":["./content/menu-title.png"]},{"name":"menu-font-spritesheet","type":"image","args":["./content/image-font.png"]},{"name":"menu-font","type":"json","args":["url:content/image-font-data.json"],"processors":[{"name":"imageFont","args":["menu-font-spritesheet"]}]},{"name":"character-spritesheet","type":"image","args":["./content/character-spritesheet.png"]},{"name":"character-texture-atlas","type":"json","args":["url:content/character-texture-atlas.json"],"processors":[{"name":"textureAtlas","args":["character-spritesheet"]}]},{"name":"character-sprite","type":"json","args":["url:content/character-sprite.json"],"processors":[{"name":"sprite"}]},{"name":"terrain-tilesheet","type":"image","args":["./content/terrain-tilesheet.png"]},{"name":"terrain-texture-atlas","type":"json","args":["url:content/terrain-texture-atlas.json"],"processors":[{"name":"textureAtlas","args":["terrain-tilesheet"]}]},{"name":"tile-map","type":"json","args":["url:content/tile-map.json"],"processors":[{"name":"tileMap","args":[{"decompressData":true}]}]}]');

/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"title":"Example Game","showFPS":true}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __webpack_require__(/*! ./Game */ "./src/Game.ts");
window.onload = () => {
    const game = new Game_1.default(document.querySelector('#game'));
    game.initialise();
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDTkEsa0VBQTBCO0FBRTFCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO0lBQ25CLE1BQU0sSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN2RCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDcEIsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYS9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zy9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvaW1hZ2UtZm9udC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS90ZXh0dXJlLWF0bGFzL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS90aWxlLW1hcC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL3NoYWRlci1jYW52YXMvZGlzdC9zaGFkZXItY2FudmFzLmpzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9HYW1lLnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9hY3RvcnMvQWN0b3IudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2FjdG9ycy9QbGF5ZXIudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2FjdG9ycy9Qcm9ncmVzc0Jhci50cyIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvLi9zcmMvYWN0b3JzL2luZGV4LnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL2NvbnRlbnQtcHJvY2Vzc29ycy9zaGFkZXIuY29udGVudC1wcm9jZXNzb3IudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL3NjZW5lcy9HYW1lU2NlbmUudHMiLCJ3ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZ2FtZS1leGFtcGxlLy4vc3JjL3NjZW5lcy9JbnRyb1NjZW5lLnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9zY2VuZXMvTG9hZGluZ1NjZW5lLnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9zY2VuZXMvTWVudVNjZW5lLnRzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9nYW1lLWV4YW1wbGUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2dhbWUtZXhhbXBsZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5jb25zdCBfdmVjX2NodW5rID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XFxuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XFxuY29uc3QgX3ZlY19pc192ZWMzID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGEgJiYgJ3onIGluIGE7XFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIDIpOyAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMyKCk7ICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcXG4gIGlmICgheCAmJiAheSkge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzIuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzIoLi4uY29tcG9uZW50cy5zbGljZSgwLCAyKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcXG4gKi9cXG52ZWMyLnV4ID0gKCkgPT4gdmVjMigxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqL1xcbnZlYzIudXkgPSAoKSA9PiB2ZWMyKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICsgYlxcbiAqL1xcbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcXG4gKi9cXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMyLm11bFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcXG4gKi9cXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXFxuICovXFxudmVjMi5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuIH0gOiB2ZWMyKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMi5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn07XFxuXFxuLyoqXFxuICogRmFzdCBtZXRob2QgdG8gcm90YXRlIGEgdmVjdG9yIGJ5IC05MCwgOTAgb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcXG4gIHN3aXRjaCAocikge1xcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XFxuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XFxuICAgIGNhc2UgMjogY2FzZSAtMjogcmV0dXJuIHZlYzIoLWEueCwgLWEueSk7XFxuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2NhbGFyIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgw5cgYlxcbiAqL1xcbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xcbiAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMi5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMyTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzIubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCBvciBgeWBcXG4gKiAtIGB1YCBvciBgdmAgKGFsaWFzZXMgZm9yIGB4YCBhbmQgYHlgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAtMik7XFxuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxcbiAqIHZlYzIuc3dpeihhLCAneXgnKTsgICAvLyBbLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxcbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXFxuICogdmVjMi5zd2l6KGEsICd4LngnKTsgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxcbiAqL1xcbnZlYzIuc3dpeiA9IChhLCBzID0gJy4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczJkfSBUaGUgbWFnbml0dWRlIGFuZCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XFxuXFxuLyoqXFxuICogQSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDNkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXFxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAyLCAxKTsgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxcbiAqIGxldCBkID0gdmVjMyhhKTsgICAgICAgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxcbiAqIGxldCBnID0gdmVjMyh2ZWMyKDQsIDUpKTsgICAgLy8gKDQsIDUsIDApXFxuICovXFxuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XFxuICBpZiAoIXggJiYgIXkgJiYgIXopIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMyh4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHgsIHo6IHogPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzMuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzMoLi4uY29tcG9uZW50cy5zbGljZSgwLCAzKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKi9cXG52ZWMzLnV4ID0gKCkgPT4gdmVjMygxLCAwLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqL1xcbnZlYzMudXkgPSAoKSA9PiB2ZWMzKDAsIDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICovXFxudmVjMy51eiA9ICgpID0+IHZlYzMoMCwgMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKyBiXFxuICovXFxudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxcbiAqL1xcbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSwgejogYS56ICogKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzMubXVsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxcbiAqL1xcbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSkgKyBNYXRoLmFicyhhLnopO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXFxuICovXFxudmVjMy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuLCB6OiBhLnogLyBsZW4gfSA6IHZlYzMoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMzLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLno7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcm90YXRpb24gbWF0cml4XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDEpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCxcXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpICsgYS56ICogTWF0aC5zaW4ociksXFxuICBhLnksXFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSAtIGEueSAqIE1hdGguc2luKHIpLFxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcXG4gIGEuelxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcXVhdGVybmlvblxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcXG4gIGlmIChxLmxlbmd0aCAhPT0gNCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XFxuICBpZiAoZCA9PT0gMCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgdXEgPSBbcVswXSAvIGQsIHFbMV0gLyBkLCBxWzJdIC8gZCwgcVszXSAvIGRdO1xcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xcbiAgY29uc3QgcyA9IHVxWzNdO1xcbiAgcmV0dXJuIHZlYzMuYWRkKFxcbiAgICB2ZWMzLmFkZChcXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxcbiAgICAgIHZlYzMubXVsKHYsIHMgKiBzIC0gdmVjMy5kb3QodSwgdSkpXFxuICAgICksXFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge3ZlYzN9IGUgVGhlIEV1bGVyIGFuZ2xlcyB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RhID0gKGEsIGUpID0+IHZlYzMucm90eih2ZWMzLnJvdHkodmVjMy5yb3R4KGEsIGUueCksIGUueSksIGUueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIMOXIGJcXG4gKi9cXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXFxuICBhLnkgKiBiLnogLSBhLnogKiBiLnksXFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcXG4pO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHggPSBhID0+IE1hdGguYXRhbjIoYS56LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzMuY3B5ID0gYSA9PiB2ZWMzKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDNkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knIHwgJ3onfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4LCB5IG9yIHopXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fSR7c30ke2Euen1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgLCBgeWAgb3IgYHpgXFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBaYCwgYFVgLCBgVmAsIGBXYCwgYFJgLCBgR2AsIGBCYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAtMiwgMSk7XFxuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3hZWicpOyAgIC8vIFszLCAyLCAtMV1cXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3kwMXp4Jyk7IC8vIFstMiwgMCwgMSwgMSwgM11cXG4gKi9cXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiBjYXNlICdyJzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiBjYXNlICdSJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnBvbGFyID0gYSA9PiB7XFxuICBsZXQgciA9IHZlYzMubGVuKGEpLFxcbiAgICB0aGV0YSA9IE1hdGguYWNvcyhhLnkgLyByKSxcXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XFxuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzMuZnJvbVBvbGFyID0gKHIsIHRoZXRhLCBwaGkpID0+IHtcXG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguY29zKHBoaSksXFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XFxuXFxuLyoqXFxuICogQWRkIG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcXG4gKi9cXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcXG4gKi9cXG5tYXQuc3ViID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgLSBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XFxuICBsZXQgbiwgYmIsIHJ0O1xcbiAgaWYgKF92ZWNfaXNfdmVjMyhiKSkge1xcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDM7XFxuICAgIHJ0ID0gdmVjMy5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XFxuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMjtcXG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgYmIgPSBiO1xcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcXG4gICAgcnQgPSB2ID0+IHY7XFxuICB9XFxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xcbiAgfVxcbiAgcmV0dXJuIHJ0KHJlc3VsdCk7XFxufVxcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubm9yID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggZnJvbSB3aGljaCB0byBnZXQgdGhlIGFkanVnYXRlXFxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxcbiAqL1xcbm1hdC5hZGogPSBhID0+IHtcXG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcXG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBfdmVjX2NodW5rKGEuZW50cmllcywgYS5uKS5tYXAociA9PiByLmpvaW4obXMpKS5qb2luKG5zKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYzIsIHZlYzMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNsYW1wKGEsIG1pbiA9IDAsIG1heCA9IDEpIHtcXG4gICAgcmV0dXJuIGEgPCBtaW4gPyBtaW4gOiBhID4gbWF4ID8gbWF4IDogYTtcXG59XFxuY2xhc3MgQ2FtZXJhIHtcXG4gICAgY29uc3RydWN0b3IocG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuc2l6ZSA9ICgwLCB2ZWNfMS52ZWMyKSgpO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFNjYWxlID0gMTtcXG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAxO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIENhbWVyYS5ERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgfVxcbiAgICBnZXQgcG9zaXRpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQb3NpdGlvbjtcXG4gICAgfVxcbiAgICBzZXQgcG9zaXRpb24odmFsdWUpIHtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBzZXQgcG9zaXRpb25JbW1lZGlhdGUodmFsdWUpIHtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFBvc2l0aW9uID0gdmFsdWU7XFxuICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdmFsdWU7XFxuICAgIH1cXG4gICAgZ2V0IGFjdHVhbFBvc2l0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbFBvc2l0aW9uO1xcbiAgICB9XFxuICAgIGdldCBzY2FsZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldFNjYWxlO1xcbiAgICB9XFxuICAgIGdldCBhY3R1YWxTY2FsZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWxTY2FsZTtcXG4gICAgfVxcbiAgICBzZXQgc2NhbGUodmFsdWUpIHtcXG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBjbGFtcCh2YWx1ZSwgdGhpcy5vcHRpb25zLm1pblNjYWxlLCB0aGlzLm9wdGlvbnMubWF4U2NhbGUpO1xcbiAgICB9XFxuICAgIHNldCBzY2FsZUltbWVkaWF0ZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy5fYWN0dWFsU2NhbGUgPSBjbGFtcCh2YWx1ZSwgdGhpcy5vcHRpb25zLm1pblNjYWxlLCB0aGlzLm9wdGlvbnMubWF4U2NhbGUpO1xcbiAgICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IHRoaXMuX2FjdHVhbFNjYWxlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgc2NyZWVuIGJvdW5kcyBiYXNlZCBvbiB0aGUgY3VycmVudCBjYW1lcmEgcG9zaXRpb24gYW5kIHNjYWxlXFxuICAgICAqL1xcbiAgICBnZXQgYm91bmRzKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB0b3A6IHRoaXMuX2FjdHVhbFBvc2l0aW9uLnkgLSB0aGlzLnNpemUueSAvIDIgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICBib3R0b206IHRoaXMuX2FjdHVhbFBvc2l0aW9uLnkgKyB0aGlzLnNpemUueSAvIDIgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLl9hY3R1YWxQb3NpdGlvbi54IC0gdGhpcy5zaXplLnggLyAyIC8gdGhpcy5fYWN0dWFsU2NhbGUsXFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuX2FjdHVhbFBvc2l0aW9uLnggKyB0aGlzLnNpemUueCAvIDIgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnQgYSBzY3JlZW4gcG9zaXRpb24gdG8gYSB3b3JsZCBwb3NpdGlvblxcbiAgICAgKi9cXG4gICAgc2NyZWVuVG9Xb3JsZChwb3NpdGlvbikge1xcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5ib3VuZHM7XFxuICAgICAgICByZXR1cm4gdmVjXzEudmVjMi5hZGQoeyB4OiBib3VuZHMubGVmdCwgeTogYm91bmRzLnRvcCB9LCB2ZWNfMS52ZWMyLm11bChwb3NpdGlvbiwgMSAvIHRoaXMuYWN0dWFsU2NhbGUpKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ29udmVydCBhIHdvcmxkIHBvc2l0aW9uIHRvIGEgc2NyZWVuIHBvc2l0aW9uXFxuICAgICAqL1xcbiAgICB3b3JsZFRvU2NyZWVuKHBvc2l0aW9uKSB7XFxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmJvdW5kcztcXG4gICAgICAgIHJldHVybiB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLnN1Yihwb3NpdGlvbiwgeyB4OiBib3VuZHMubGVmdCwgeTogYm91bmRzLnRvcCB9KSwgdGhpcy5hY3R1YWxTY2FsZSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgY2FtZXJhXFxuICAgICAqL1xcbiAgICB1cGRhdGUoc2NyZWVuKSB7XFxuICAgICAgICB0aGlzLnNpemUgPSAoMCwgdmVjXzEudmVjMikoc2NyZWVuKTtcXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHBvc2l0aW9uIHRvIGJvdW5kc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMpIHtcXG4gICAgICAgICAgICBjb25zdCBzY3JlZW5TY2FsZWQgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bCh0aGlzLnNpemUsIDEgLyB0aGlzLl9hY3R1YWxTY2FsZSksIE1hdGguY2VpbCk7XFxuICAgICAgICAgICAgLy8gSWYgdGhlIHNjYWxlZCBzY3JlZW4gc2l6ZSBpcyBsYXJnZXIgdGhhbiBhbGxvd2VkIGJvdW5kcywgd2UgcmVzaXplXFxuICAgICAgICAgICAgLy8gdGhlIGJvdW5kcyB0byBwcmV2ZW50IGppdHRlcmluZ1xcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbEJvdW5kcyA9IHtcXG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmJvdW5kcyxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGlmIChzY3JlZW5TY2FsZWQueCA+IGFjdHVhbEJvdW5kcy5yaWdodCAtIGFjdHVhbEJvdW5kcy5sZWZ0KSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gYWN0dWFsQm91bmRzLnJpZ2h0IC0gYWN0dWFsQm91bmRzLmxlZnQ7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZEaWZmID0gKHNjcmVlblNjYWxlZC54IC0gYm91bmRzV2lkdGgpIC8gMjtcXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRzLmxlZnQgLT0gaGFsZkRpZmY7XFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kcy5yaWdodCArPSBoYWxmRGlmZjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHNjcmVlblNjYWxlZC55ID4gYWN0dWFsQm91bmRzLmJvdHRvbSAtIGFjdHVhbEJvdW5kcy50b3ApIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzSGVpZ2h0ID0gYWN0dWFsQm91bmRzLmJvdHRvbSAtIGFjdHVhbEJvdW5kcy50b3A7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZEaWZmID0gKHNjcmVlblNjYWxlZC55IC0gYm91bmRzSGVpZ2h0KSAvIDI7XFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kcy50b3AgLT0gaGFsZkRpZmY7XFxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kcy5ib3R0b20gKz0gaGFsZkRpZmY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGhhbGZTY3JlZW5TY2FsZWQgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChzY3JlZW5TY2FsZWQsIDEgLyAyKSwgTWF0aC5jZWlsKTtcXG4gICAgICAgICAgICBjb25zdCBtaW5Qb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKShhY3R1YWxCb3VuZHMubGVmdCArIGhhbGZTY3JlZW5TY2FsZWQueCwgYWN0dWFsQm91bmRzLnRvcCArIGhhbGZTY3JlZW5TY2FsZWQueSk7XFxuICAgICAgICAgICAgY29uc3QgbWF4UG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoYWN0dWFsQm91bmRzLnJpZ2h0IC0gaGFsZlNjcmVlblNjYWxlZC54LCBhY3R1YWxCb3VuZHMuYm90dG9tIC0gaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnggPSBjbGFtcCh0aGlzLnRhcmdldFBvc2l0aW9uLngsIG1pblBvc2l0aW9uLngsIG1heFBvc2l0aW9uLngpO1xcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24ueSA9IGNsYW1wKHRoaXMudGFyZ2V0UG9zaXRpb24ueSwgbWluUG9zaXRpb24ueSwgbWF4UG9zaXRpb24ueSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBkID0gdmVjXzEudmVjMi5zdWIodGhpcy5fYWN0dWFsUG9zaXRpb24sIHRoaXMudGFyZ2V0UG9zaXRpb24pO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSB2ZWNfMS52ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCB2ZWNfMS52ZWMyLm11bChkLCB0aGlzLm9wdGlvbnMubW92ZUVhc2VBbW91bnQpKTtcXG4gICAgICAgIGNvbnN0IHMgPSBjbGFtcCh0aGlzLnRhcmdldFNjYWxlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxTY2FsZSA9XFxuICAgICAgICAgICAgcyArICh0aGlzLl9hY3R1YWxTY2FsZSAtIHMpICogdGhpcy5vcHRpb25zLnNjYWxlRWFzZUFtb3VudDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdHJhbnNmb3JtcyBvbiBhIGNhbnZhcyBjb250ZXh0XFxuICAgICAqL1xcbiAgICBzZXRUcmFuc2Zvcm1zKGNvbnRleHQpIHtcXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUodGhpcy5zaXplLnggLyAyIC0gdGhpcy5fYWN0dWFsUG9zaXRpb24ueCAqIHRoaXMuX2FjdHVhbFNjYWxlLCB0aGlzLnNpemUueSAvIDIgLSB0aGlzLl9hY3R1YWxQb3NpdGlvbi55ICogdGhpcy5fYWN0dWFsU2NhbGUpO1xcbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLl9hY3R1YWxTY2FsZSwgdGhpcy5fYWN0dWFsU2NhbGUpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIGNhbWVyYSBhbmQgdGhlbiBzZXQgdHJhbnNmb3JtcyBvbiBhIGNhbnZhcyBjb250ZXh0XFxuICAgICAqL1xcbiAgICBkcmF3KGNvbnRleHQsIHNjcmVlbikge1xcbiAgICAgICAgdGhpcy51cGRhdGUoc2NyZWVuKTtcXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3Jtcyhjb250ZXh0KTtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBDYW1lcmE7XFxuQ2FtZXJhLkRFRkFVTFRfT1BUSU9OUyA9IHtcXG4gICAgYWxsb3dTY2FsZTogdHJ1ZSxcXG4gICAgbWluU2NhbGU6IDAuNSxcXG4gICAgbWF4U2NhbGU6IDQsXFxuICAgIG1vdmVFYXNlQW1vdW50OiAwLjEsXFxuICAgIHNjYWxlRWFzZUFtb3VudDogMC4xLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2NvbnRlbnQtbG9hZGVycy9hdWRpby5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2F1ZGlvLmxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5BdWRpb0xvYWRlciA9IHZvaWQgMDtcXG5jb25zdCBBdWRpb0xvYWRlciA9IGFzeW5jICh1cmwpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKHVybCk7XFxuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgKCkgPT4ge1xcbiAgICAgICAgICAgIHJlc29sdmUoYXVkaW8pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcXG4gICAgICAgICAgICByZWplY3QoYEVycm9yIGxvYWRpbmcgYXVkaW8gXFxcIiR7dXJsfVxcXCJgKTtcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59O1xcbmV4cG9ydHMuQXVkaW9Mb2FkZXIgPSBBdWRpb0xvYWRlcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LWxvYWRlcnMvYXVkaW8ubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvZm9udC5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LWxvYWRlcnMvZm9udC5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Gb250TG9hZGVyID0gdm9pZCAwO1xcbmNvbnN0IEZvbnRMb2FkZXIgPSBhc3luYyAodXJsLCBmYW1pbHkpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2UoZmFtaWx5LCBgdXJsKCR7dXJsfSlgKTtcXG4gICAgICAgIGZvbnRcXG4gICAgICAgICAgICAubG9hZCgpXFxuICAgICAgICAgICAgLnRoZW4oZm9udCA9PiB7XFxuICAgICAgICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnQpO1xcbiAgICAgICAgICAgIHJlc29sdmUoZm9udCk7XFxuICAgICAgICB9KVxcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGZvbnQgXFxcIiR7dXJsfVxcXCJgKTtcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59O1xcbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvaW1hZ2UubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy9pbWFnZS5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuSW1hZ2VMb2FkZXIgPSB2b2lkIDA7XFxuY29uc3QgSW1hZ2VMb2FkZXIgPSBhc3luYyAodXJsKSA9PiB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xcbiAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcXG4gICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XFxuICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGltYWdlIFxcXCIke3VybH1cXFwiYCk7XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufTtcXG5leHBvcnRzLkltYWdlTG9hZGVyID0gSW1hZ2VMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2ltYWdlLmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcXG4gICAgaWYgKCFkZXNjIHx8IChcXFwiZ2V0XFxcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XFxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIG9bazJdID0gbVtrXTtcXG59KSk7XFxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXVkaW8ubG9hZGVyICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9hdWRpby5sb2FkZXIudHNcXFwiKSwgZXhwb3J0cyk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9udC5sb2FkZXIgKi8gXFxcIi4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlLmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvaW1hZ2UubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2pzb24ubG9hZGVyICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9qc29uLmxvYWRlci50c1xcXCIpLCBleHBvcnRzKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90ZXh0LmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvdGV4dC5sb2FkZXIudHNcXFwiKSwgZXhwb3J0cyk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5KU09OTG9hZGVyID0gdm9pZCAwO1xcbmNvbnN0IEpTT05Mb2FkZXIgPSBhc3luYyAodXJsT3JEYXRhKSA9PiB7XFxuICAgIGlmICh0eXBlb2YgdXJsT3JEYXRhID09PSAnc3RyaW5nJyAmJiB1cmxPckRhdGEuc3RhcnRzV2l0aCgndXJsOicpKSB7XFxuICAgICAgICBjb25zdCB1cmwgPSB1cmxPckRhdGEuc3Vic3RyaW5nKDQpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICAgICAgICB3aW5kb3dcXG4gICAgICAgICAgICAgICAgLmZldGNoKHVybCwge1xcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xcbiAgICAgICAgICAgICAgICByZXNvbHZlKGpzb24pO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJlamVjdChgRXJyb3IgbG9hZGluZyBqc29uIFxcXCIke3VybE9yRGF0YX1cXFwiYCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gdXJsT3JEYXRhO1xcbn07XFxuZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2NvbnRlbnQtbG9hZGVycy90ZXh0LmxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy90ZXh0LmxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlRleHRMb2FkZXIgPSB2b2lkIDA7XFxuY29uc3QgVGV4dExvYWRlciA9IGFzeW5jICh1cmxPclRleHQpID0+IHtcXG4gICAgaWYgKHVybE9yVGV4dC5zdGFydHNXaXRoKCd1cmw6JykpIHtcXG4gICAgICAgIGNvbnN0IHVybCA9IHVybE9yVGV4dC5zdWJzdHJpbmcoNCk7XFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgICAgICAgIHdpbmRvd1xcbiAgICAgICAgICAgICAgICAuZmV0Y2godXJsLCB7XFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIHRleHQgXFxcIiR7dXJsT3JUZXh0fVxcXCJgKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiB1cmxPclRleHQudG9TdHJpbmcoKTtcXG59O1xcbmV4cG9ydHMuVGV4dExvYWRlciA9IFRleHRMb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL3RleHQubG9hZGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5JbWFnZU5hbWVQcm9jZXNzb3IgPSB2b2lkIDA7XFxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGltYWdlTmFtZUZpZWxkTmFtZTogJ2ltYWdlTmFtZScsXFxuICAgIGltYWdlRmllbGROYW1lOiAnaW1hZ2UnLFxcbn07XFxuY29uc3QgSW1hZ2VOYW1lUHJvY2Vzc29yID0gYXN5bmMgKGNvbnRlbnQsIGl0ZW0sIG9wdGlvbnMpID0+IHtcXG4gICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgIGlmICh0eXBlb2YgaXRlbS5jb250ZW50ID09PSAnb2JqZWN0JyAmJiBpdGVtLmNvbnRlbnQgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnN0IHByb2Nlc3NPYmplY3QgPSAobykgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XFxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IGFjdHVhbE9wdGlvbnMuaW1hZ2VOYW1lRmllbGROYW1lKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZU5hbWUgPSBvW2tleV07XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUl0ZW0gPSAoX2EgPSBjb250ZW50W2ltYWdlTmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlSXRlbSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9bYWN0dWFsT3B0aW9ucy5pbWFnZUZpZWxkTmFtZV0gPSBpbWFnZUl0ZW07XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ba2V5XTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb1trZXldID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgICAgICAgICAgICAgb1trZXldICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzT2JqZWN0KG9ba2V5XSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgcHJvY2Vzc09iamVjdChpdGVtLmNvbnRlbnQpO1xcbiAgICB9XFxufTtcXG5leHBvcnRzLkltYWdlTmFtZVByb2Nlc3NvciA9IEltYWdlTmFtZVByb2Nlc3NvcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LXByb2Nlc3NvcnMvaW1hZ2UtbmFtZS5wcm9jZXNzb3IudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2NvbnRlbnQtcHJvY2Vzc29ycy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtcHJvY2Vzc29ycy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XFxuICAgIGlmICghZGVzYyB8fCAoXFxcImdldFxcXCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XFxuICAgIH1cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcbiAgICBvW2syXSA9IG1ba107XFxufSkpO1xcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcXFwiZGVmYXVsdFxcXCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ltYWdlLW5hbWUucHJvY2Vzc29yICovIFxcXCIuL2NvbnRlbnQtcHJvY2Vzc29ycy9pbWFnZS1uYW1lLnByb2Nlc3Nvci50c1xcXCIpLCBleHBvcnRzKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LXByb2Nlc3NvcnMvaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuQ29udGVudEl0ZW1TdGF0dXMgPSBleHBvcnRzLkNvbnRlbnRNYW5hZ2VyU3RhdHVzID0gZXhwb3J0cy5Db250ZW50SXRlbVR5cGUgPSB2b2lkIDA7XFxuY29uc3QgY29udGVudF9sb2FkZXJzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRlbnQtbG9hZGVycyAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvaW5kZXgudHNcXFwiKTtcXG5jb25zdCBjb250ZW50X3Byb2Nlc3NvcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGVudC1wcm9jZXNzb3JzICovIFxcXCIuL2NvbnRlbnQtcHJvY2Vzc29ycy9pbmRleC50c1xcXCIpO1xcbnZhciBDb250ZW50SXRlbVR5cGU7XFxuKGZ1bmN0aW9uIChDb250ZW50SXRlbVR5cGUpIHtcXG4gICAgQ29udGVudEl0ZW1UeXBlW1xcXCJKU09OXFxcIl0gPSBcXFwianNvblxcXCI7XFxuICAgIENvbnRlbnRJdGVtVHlwZVtcXFwiRm9udFxcXCJdID0gXFxcImZvbnRcXFwiO1xcbiAgICBDb250ZW50SXRlbVR5cGVbXFxcIkltYWdlXFxcIl0gPSBcXFwiaW1hZ2VcXFwiO1xcbiAgICBDb250ZW50SXRlbVR5cGVbXFxcIkF1ZGlvXFxcIl0gPSBcXFwiYXVkaW9cXFwiO1xcbiAgICBDb250ZW50SXRlbVR5cGVbXFxcIlRleHRcXFwiXSA9IFxcXCJ0ZXh0XFxcIjtcXG59KShDb250ZW50SXRlbVR5cGUgPSBleHBvcnRzLkNvbnRlbnRJdGVtVHlwZSB8fCAoZXhwb3J0cy5Db250ZW50SXRlbVR5cGUgPSB7fSkpO1xcbnZhciBDb250ZW50TWFuYWdlclN0YXR1cztcXG4oZnVuY3Rpb24gKENvbnRlbnRNYW5hZ2VyU3RhdHVzKSB7XFxuICAgIENvbnRlbnRNYW5hZ2VyU3RhdHVzW1xcXCJJZGxlXFxcIl0gPSBcXFwiaWRsZVxcXCI7XFxuICAgIENvbnRlbnRNYW5hZ2VyU3RhdHVzW1xcXCJMb2FkaW5nXFxcIl0gPSBcXFwibG9hZGluZ1xcXCI7XFxuICAgIENvbnRlbnRNYW5hZ2VyU3RhdHVzW1xcXCJQcm9jZXNzaW5nXFxcIl0gPSBcXFwicHJvY2Vzc2luZ1xcXCI7XFxuICAgIENvbnRlbnRNYW5hZ2VyU3RhdHVzW1xcXCJSZWFkeVxcXCJdID0gXFxcInJlYWR5XFxcIjtcXG59KShDb250ZW50TWFuYWdlclN0YXR1cyA9IGV4cG9ydHMuQ29udGVudE1hbmFnZXJTdGF0dXMgfHwgKGV4cG9ydHMuQ29udGVudE1hbmFnZXJTdGF0dXMgPSB7fSkpO1xcbnZhciBDb250ZW50SXRlbVN0YXR1cztcXG4oZnVuY3Rpb24gKENvbnRlbnRJdGVtU3RhdHVzKSB7XFxuICAgIENvbnRlbnRJdGVtU3RhdHVzW1xcXCJJZGxlXFxcIl0gPSBcXFwiaWRsZVxcXCI7XFxuICAgIENvbnRlbnRJdGVtU3RhdHVzW1xcXCJMb2FkaW5nXFxcIl0gPSBcXFwibG9hZGluZ1xcXCI7XFxuICAgIENvbnRlbnRJdGVtU3RhdHVzW1xcXCJMb2FkZWRcXFwiXSA9IFxcXCJsb2FkZWRcXFwiO1xcbiAgICBDb250ZW50SXRlbVN0YXR1c1tcXFwiUHJvY2Vzc2luZ1xcXCJdID0gXFxcInByb2Nlc3NpbmdcXFwiO1xcbiAgICBDb250ZW50SXRlbVN0YXR1c1tcXFwiUHJvY2Vzc2VkXFxcIl0gPSBcXFwicHJvY2Vzc2VkXFxcIjtcXG59KShDb250ZW50SXRlbVN0YXR1cyA9IGV4cG9ydHMuQ29udGVudEl0ZW1TdGF0dXMgfHwgKGV4cG9ydHMuQ29udGVudEl0ZW1TdGF0dXMgPSB7fSkpO1xcbmNvbnN0IGRlZmF1bHRDb250ZW50TG9hZGVycyA9IHtcXG4gICAgW0NvbnRlbnRJdGVtVHlwZS5KU09OXTogY29udGVudF9sb2FkZXJzXzEuSlNPTkxvYWRlcixcXG4gICAgW0NvbnRlbnRJdGVtVHlwZS5Gb250XTogY29udGVudF9sb2FkZXJzXzEuRm9udExvYWRlcixcXG4gICAgW0NvbnRlbnRJdGVtVHlwZS5JbWFnZV06IGNvbnRlbnRfbG9hZGVyc18xLkltYWdlTG9hZGVyLFxcbiAgICBbQ29udGVudEl0ZW1UeXBlLkF1ZGlvXTogY29udGVudF9sb2FkZXJzXzEuQXVkaW9Mb2FkZXIsXFxuICAgIFtDb250ZW50SXRlbVR5cGUuVGV4dF06IGNvbnRlbnRfbG9hZGVyc18xLlRleHRMb2FkZXIsXFxufTtcXG5jb25zdCBkZWZhdWx0Q29udGVudFByb2Nlc3NvcnMgPSB7XFxuICAgIGltYWdlTmFtZTogY29udGVudF9wcm9jZXNzb3JzXzEuSW1hZ2VOYW1lUHJvY2Vzc29yLFxcbn07XFxuYXN5bmMgZnVuY3Rpb24gc2xlZXAobXMpIHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xcbn1cXG5mdW5jdGlvbiBjbGFtcChhLCBtaW4gPSAwLCBtYXggPSAxKSB7XFxuICAgIHJldHVybiBhIDwgbWluID8gbWluIDogYSA+IG1heCA/IG1heCA6IGE7XFxufVxcbmZ1bmN0aW9uIHJhbmRvbUJldHdlZW4obWluLCBtYXgpIHtcXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG59XFxuY29uc3QgTUlOX1NMRUVQX1RJTUUgPSAxMDAwO1xcbmNvbnN0IE1BWF9TTEVFUF9USU1FID0gMzAwMDtcXG5jbGFzcyBDb250ZW50TWFuYWdlciB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGVudExpc3QgPSBbXTtcXG4gICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gMDtcXG4gICAgICAgIHRoaXMuY3VycmVudFRvdGFsUHJvZ3Jlc3MgPSAwO1xcbiAgICAgICAgdGhpcy5jb250ZW50ID0ge307XFxuICAgICAgICB0aGlzLnN0YXR1cyA9IENvbnRlbnRNYW5hZ2VyU3RhdHVzLklkbGU7XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBDb250ZW50TWFuYWdlci5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHtcXG4gICAgICAgICAgICBsb2FkZXJzOiB7XFxuICAgICAgICAgICAgICAgIC4uLkNvbnRlbnRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLmxvYWRlcnMsXFxuICAgICAgICAgICAgICAgIC4uLigoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9hZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcHJvY2Vzc29yczoge1xcbiAgICAgICAgICAgICAgICAuLi4oKF9iID0gQ29udGVudE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMucHJvY2Vzc29ycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxcbiAgICAgICAgICAgICAgICAuLi4oKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByb2Nlc3NvcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9KSxcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGNvbnRlbnQgbWFuYWdlciBhbmQgcHJvdmlkZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChDb250ZW50TWFuYWdlci5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IG1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgQ29udGVudE1hbmFnZXIob3B0aW9ucyk7XFxuICAgIH1cXG4gICAgc3RhdGljIGRpc3Bvc2UoKSB7XFxuICAgICAgICBpZiAoQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBtYW5hZ2VyIG5vdCBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGVsZXRlIENvbnRlbnRNYW5hZ2VyLmluc3RhbmNlO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmIChDb250ZW50TWFuYWdlci5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IG1hbmFnZXIgbm90IHByb3Blcmx5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gQ29udGVudE1hbmFnZXIuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEN1cnJlbnQgbG9hZGluZyBwcm9ncmVzcywgcmVwcmVzZW50ZWQgYXMgYSB1bml0IHNjYWxhciBbMCwgMV1cXG4gICAgICovXFxuICAgIHN0YXRpYyBnZXQgcHJvZ3Jlc3MoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0UHJvZ3Jlc3MoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ3VycmVudCBjb250ZW50IG1hbmFnZXIgc3RhdHVzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IHN0YXR1cygpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQ29udGVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zdGF0dXM7XFxuICAgIH1cXG4gICAgZ2V0UHJvZ3Jlc3MoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENvbnRlbnRMaXN0Lmxlbmd0aCB8fCB0aGlzLmN1cnJlbnRUb3RhbFByb2dyZXNzID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY2xhbXAodGhpcy5jdXJyZW50UHJvZ3Jlc3MgLyB0aGlzLmN1cnJlbnRUb3RhbFByb2dyZXNzKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogTG9hZCBjb250ZW50IGl0ZW1zXFxuICAgICAqXFxuICAgICAqIEV4aXN0aW5nIGNvbnRlbnQgaXRlbXMgd2lsbCBiZSByZXRhaW5lZCwgYW5kIGFueSBjb250ZW50IGl0ZW1zIHdoaWNoXFxuICAgICAqIGFscmVhZHkgZXhpc3Qgd2lsbCBiZSByZS1sb2FkZWRcXG4gICAgICovXFxuICAgIHN0YXRpYyBhc3luYyBsb2FkKGl0ZW1zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xcbiAgICAgICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnMubG9hZGVycyB8fFxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm9wdGlvbnMubG9hZGVycykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZW50IGxvYWRlcnMgZGVmaW5lZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5zdGFuY2UuY3VycmVudENvbnRlbnRMaXN0ID0gaXRlbXM7XFxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdGFza3Mgd2UgbmVlZCB0byBwZXJmb3JtXFxuICAgICAgICBjb25zdCBjb3VudFRvdGFsVG9Mb2FkID0gaXRlbXMubGVuZ3RoO1xcbiAgICAgICAgY29uc3QgY291bnRUb3RhbFRvUHJvY2VzcyA9IGl0ZW1zLnJlZHVjZSgoYSwgYykgPT4geyB2YXIgX2E7IHJldHVybiBhICsgKChfYSA9IGMucHJvY2Vzc29ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDsgfSwgMCk7XFxuICAgICAgICBpbnN0YW5jZS5jdXJyZW50UHJvZ3Jlc3MgPSAwO1xcbiAgICAgICAgaW5zdGFuY2UuY3VycmVudFRvdGFsUHJvZ3Jlc3MgPSBjb3VudFRvdGFsVG9Mb2FkICsgY291bnRUb3RhbFRvUHJvY2VzcztcXG4gICAgICAgIC8vIExvYWQgaXRlbXNcXG4gICAgICAgIGluc3RhbmNlLnN0YXR1cyA9IENvbnRlbnRNYW5hZ2VyU3RhdHVzLkxvYWRpbmc7XFxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcXG4gICAgICAgICAgICBpZiAoIShpdGVtLnR5cGUgaW4gaW5zdGFuY2Uub3B0aW9ucy5sb2FkZXJzKSkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbnRlbnQgbG9hZGVyIGRlZmluZWQgZm9yIHR5cGUgXFxcIiR7aXRlbS50eXBlfVxcXCJgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLm9wdGlvbnMuc2ltdWxhdGVTbG93TG9hZGluZykge1xcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyYW5kb21CZXR3ZWVuKChfYSA9IGluc3RhbmNlLm9wdGlvbnMuc2xvd0xvYWRpbmdUaW1lTWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNSU5fU0xFRVBfVElNRSwgKF9iID0gaW5zdGFuY2Uub3B0aW9ucy5zbG93TG9hZGluZ1RpbWVNYXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1BWF9TTEVFUF9USU1FKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRJdGVtID0ge1xcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXFxuICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcXG4gICAgICAgICAgICAgICAgY29udGVudDogbnVsbCxcXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBDb250ZW50SXRlbVN0YXR1cy5Mb2FkaW5nLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgaW5zdGFuY2UuY29udGVudFtpdGVtLm5hbWVdID0gY29udGVudEl0ZW07XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uY29udGVudCA9IGF3YWl0IGluc3RhbmNlLm9wdGlvbnMubG9hZGVyc1tpdGVtLnR5cGVdKC4uLml0ZW0uYXJncyk7XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uc3RhdHVzID0gQ29udGVudEl0ZW1TdGF0dXMuTG9hZGVkO1xcbiAgICAgICAgICAgIGluc3RhbmNlLmN1cnJlbnRQcm9ncmVzcysrO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gUHJvY2VzcyBpdGVtc1xcbiAgICAgICAgaW5zdGFuY2Uuc3RhdHVzID0gQ29udGVudE1hbmFnZXJTdGF0dXMuUHJvY2Vzc2luZztcXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xcbiAgICAgICAgICAgIGlmICghaXRlbS5wcm9jZXNzb3JzIHx8IGl0ZW0ucHJvY2Vzc29ycy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2Uub3B0aW9ucy5wcm9jZXNzb3JzIHx8XFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlLm9wdGlvbnMucHJvY2Vzc29ycykubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGVudCBwcm9jZXNzb3JzIGRlZmluZWQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29uc3QgY29udGVudEl0ZW0gPSBpbnN0YW5jZS5jb250ZW50W2l0ZW0ubmFtZV07XFxuICAgICAgICAgICAgaWYgKCFjb250ZW50SXRlbSkge1xcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwb2ludDsgdGhlIGl0ZW0gd2lsbCBoYXZlIGJlZW4gbG9hZGVkXFxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGRlZCB0byB0aGUgaW5zdGFuY2UncyBjb250ZW50IGRpY3Rpb25hcnkuLi4gYnV0IGp1c3QgaW4gY2FzZVxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGl0ZW0gd2l0aCBuYW1lIFxcXCIke2l0ZW0ubmFtZX1cXFwiYCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5vcHRpb25zLnNpbXVsYXRlU2xvd1Byb2Nlc3NpbmcpIHtcXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmFuZG9tQmV0d2VlbigoX2MgPSBpbnN0YW5jZS5vcHRpb25zLnNsb3dQcm9jZXNzaW5nVGltZU1pbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTUlOX1NMRUVQX1RJTUUsIChfZCA9IGluc3RhbmNlLm9wdGlvbnMuc2xvd1Byb2Nlc3NpbmdUaW1lTWF4KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBNQVhfU0xFRVBfVElNRSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZW50SXRlbS5zdGF0dXMgPSBDb250ZW50SXRlbVN0YXR1cy5Qcm9jZXNzaW5nO1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGl0ZW0ucHJvY2Vzc29ycykge1xcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzb3IubmFtZSBpbiBpbnN0YW5jZS5vcHRpb25zLnByb2Nlc3NvcnMpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbnRlbnQgcHJvY2Vzc29yIGRlZmluZWQgd2l0aCBuYW1lIFxcXCIke3Byb2Nlc3Nvci5uYW1lfVxcXCJgKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5vcHRpb25zLnByb2Nlc3NvcnNbcHJvY2Vzc29yLm5hbWVdKGluc3RhbmNlLmNvbnRlbnQsIGNvbnRlbnRJdGVtLCAuLi4oKF9lID0gcHJvY2Vzc29yLmFyZ3MpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSk7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmN1cnJlbnRQcm9ncmVzcysrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZW50SXRlbS5zdGF0dXMgPSBDb250ZW50SXRlbVN0YXR1cy5Qcm9jZXNzZWQ7XFxuICAgICAgICB9XFxuICAgICAgICBpbnN0YW5jZS5zdGF0dXMgPSBDb250ZW50TWFuYWdlclN0YXR1cy5SZWFkeTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmV0cmlldmUgYSBjb250ZW50IGl0ZW0gYnkgbmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGdldChuYW1lKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoIShuYW1lIGluIGluc3RhbmNlLmNvbnRlbnQpKSB7XFxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLm9wdGlvbnMudGhyb3dPbk5vdEZvdW5kKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGVudCBpdGVtIFxcXCIke25hbWV9XFxcIiBub3QgZm91bmRgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5jb250ZW50W25hbWVdLmNvbnRlbnQ7XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gQ29udGVudE1hbmFnZXI7XFxuQ29udGVudE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIGxvYWRlcnM6IGRlZmF1bHRDb250ZW50TG9hZGVycyxcXG4gICAgcHJvY2Vzc29yczogZGVmYXVsdENvbnRlbnRQcm9jZXNzb3JzLFxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLyoqXFxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuY29uc3QgX3ZlY190aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XFxuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcbmNvbnN0IF92ZWNfZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcbmNvbnN0IF92ZWNfaXNfdmVjMiA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhO1xcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjMlxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgMmQgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IDJkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMyKDQpOyAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYzIoYSk7ICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjMiA9ICh4LCB5KSA9PiB7XFxuICBpZiAoIXggJiYgIXkpIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfTtcXG4gIH1cXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzIuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSArIGJcXG4gKi9cXG52ZWMyLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLSBiXFxuICovXFxudmVjMi5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXFxuICovXFxudmVjMi5zY2FsZSA9IChhLCBiKSA9PiB2ZWMyLm11bChhLCBiKTtcXG5cXG4vKipcXG4gKiBEaXZpZGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLyBiXFxuICovXFxudmVjMi5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMyfSBeYVxcbiAqL1xcbnZlYzIubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMi5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMyLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59O1xcblxcbi8qKlxcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgMSBmb3IgOTAgZGVncmVlcyAoY3cpLCAtMSBmb3IgLTkwIGRlZ3JlZXMgKGNjdyksIDIgb3IgLTIgZm9yIDE4MCBkZWdyZWVzXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ZiA9IChhLCByKSA9PiB7XFxuICBzd2l0Y2ggKHIpIHtcXG4gICAgY2FzZSAxOiByZXR1cm4gdmVjMihhLnksIC1hLngpO1xcbiAgICBjYXNlIC0xOiByZXR1cm4gdmVjMigtYS55LCBhLngpO1xcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xcbiAgICBkZWZhdWx0OiByZXR1cm4gYTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcXG4gKi9cXG52ZWMyLmNyb3NzID0gKGEsIGIpID0+IHtcXG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMyLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMyLmNweSA9IGEgPT4gdmVjMihhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAyZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcXG4gKlxcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XFxuICogLSBgeGAgb3IgYHlgXFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBVYCwgYFZgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcXG4gKiAtIGAwYCBvciBgMWAgKHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkKVxcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcXG4gKlxcbiAqIEFueSBvdGhlciBjaGFyYWN0ZXJzIHdpbGwgZGVmYXVsdCB0byAwXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzIoMywgLTIpO1xcbiAqIHZlYzIuc3dpeihhLCAneCcpOyAgICAvLyBbM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxcbiAqIHZlYzIuc3dpeihhLCAneFknKTsgICAvLyBbMywgMl1cXG4gKiB2ZWMyLnN3aXooYSwgJ1l5Jyk7ICAgLy8gWzIsIC0yXVxcbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd5MDF4Jyk7IC8vIFstMiwgMCwgMSwgM11cXG4gKi9cXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgcy5zcGxpdCgnJykuZm9yRWFjaCgoYywgaSkgPT4ge1xcbiAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnldW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczJkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIucG9sYXIgPSBhID0+ICh7IHI6IHZlYzIubGVuKGEpLCB0aGV0YTogTWF0aC5hdGFuMihhLnksIGEueCkgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzIuZnJvbVBvbGFyID0gKHIsIHRoZXRhKSA9PiB2ZWMyKHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpO1xcblxcbi8qKlxcbiAqIEEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjM1xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geiBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMzfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIHRoZSB6IGNvbXBvbmVudCBpZiB4IGlzIGEgdmVjMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyAzZCB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBiID0gdmVjMyg0LCA1KTsgICAgICAgICAgLy8gKDQsIDUsIDApXFxuICogbGV0IGMgPSB2ZWMzKDYpOyAgICAgICAgICAgICAvLyAoNiwgNiwgNilcXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBlID0gdmVjMygpOyAgICAgICAgICAgICAgLy8gKDAsIDAsIDApXFxuICogbGV0IGYgPSB2ZWMzKHZlYzIoMSwgMiksIDMpOyAvLyAoMSwgMiwgMylcXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxcbiAqL1xcbmNvbnN0IHZlYzMgPSAoeCwgeSwgeikgPT4ge1xcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XFxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMzLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueSwgYS56XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICovXFxudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKi9cXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqL1xcbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxcbiAqL1xcbnZlYzMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYiksIHo6IGEueiArIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAtIGJcXG4gKi9cXG52ZWMzLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpLCB6OiBhLnogLSAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAqIGJcXG4gKi9cXG52ZWMzLnNjYWxlID0gKGEsIGIpID0+IHZlYzMubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAvIGJcXG4gKi9cXG52ZWMzLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpLCB6OiBhLnogLyAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSArIGEueiAqIGEueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMzfSBeYVxcbiAqL1xcbnZlYzMubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bWF0fSBtIFRoZSByb3RhdGlvbiBtYXRyaXhcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3QgPSAoYSwgbSkgPT4gdmVjMyhcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDIpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMykpLCBhKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R4ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLngsXFxuICBhLnkgKiBNYXRoLmNvcyhyKSAtIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R5ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55LFxcbiAgLWEueCAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3MocilcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eiA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcXG4gIGEueCAqIE1hdGguc2luKHIpICsgYS55ICogTWF0aC5jb3MociksXFxuICBhLnpcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHEgVGhlIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90cSA9ICh2LCBxKSA9PiB7XFxuICBpZiAocS5sZW5ndGggIT09IDQpIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQocVswXSAqIHFbMF0gKyBxWzFdICogcVsxXSArIHFbMl0gKiBxWzJdICsgcVszXSAqIHFbM10pO1xcbiAgaWYgKGQgPT09IDApIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcXG4gIGNvbnN0IHUgPSB2ZWMzKC4uLnVxLnNsaWNlKDAsIDMpKTtcXG4gIGNvbnN0IHMgPSB1cVszXTtcXG4gIHJldHVybiB2ZWMzLmFkZChcXG4gICAgdmVjMy5hZGQoXFxuICAgICAgdmVjMy5tdWwodSwgMiAqIHZlYzMuZG90KHUsIHYpKSxcXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxcbiAgICApLFxcbiAgICB2ZWMzLm11bCh2ZWMzLmNyb3NzKHUsIHYpLCAyICogcylcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgRXVsZXIgYW5nbGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXFxuICovXFxudmVjMy5jcm9zcyA9IChhLCBiKSA9PiB2ZWMzKFxcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxcbiAgYS56ICogYi54IC0gYS54ICogYi56LFxcbiAgYS54ICogYi55IC0gYS55ICogYi54XFxuKTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS56ID09PSBiLno7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB4IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHkgPSBhID0+IE1hdGguYXRhbjIoYS54LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeiBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeiA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueik7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjM01hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMzLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JyksIHo6IGYoYS56LCAneicpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxcbiAqIC0gYHVgLCBgdmAgb3IgYHdgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgcmAsIGBnYCBvciBgYmAgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xcbiAqIHZlYzMuc3dpeihhLCAneCcpOyAgICAgLy8gWzNdXFxuICogdmVjMy5zd2l6KGEsICd6eXgnKTsgICAvLyBbMSwgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXFxuICogdmVjMy5zd2l6KGEsICdaengnKTsgICAvLyBbLTEsIDEsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4LngnKTsgICAvLyBbMywgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXFxuICovXFxudmVjMy5zd2l6ID0gKGEsIHMgPSAnLi4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogY2FzZSAnZyc6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3onOiBjYXNlICd3JzogY2FzZSAnYic6IHJlc3VsdC5wdXNoKGEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IGNhc2UgJ0cnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWic6IGNhc2UgJ1cnOiBjYXNlICdCJzogcmVzdWx0LnB1c2goLWEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcXG4gICAgICBjYXNlICcuJzogcmVzdWx0LnB1c2goW2EueCwgYS55LCBhLnpdW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczNkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGhpIFRoZSBwYW4gYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzM2R9IFRoZSBtYWduaXR1ZGUsIHRpbHQgYW5kIHBhbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMy5wb2xhciA9IGEgPT4ge1xcbiAgbGV0IHIgPSB2ZWMzLmxlbihhKSxcXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXFxuICAgIHBoaSA9IE1hdGguYXRhbjIoYS56LCBhLngpO1xcbiAgcmV0dXJuIHsgciwgdGhldGEsIHBoaSB9O1xcbn07XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcXG4gKi9cXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XFxuICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcXG4gIHJldHVybiB2ZWMzKFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxcbiAgICByICogTWF0aC5jb3ModGhldGEpLFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLnNpbihwaGkpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIF92ZWNfZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IGEgbWF0cml4IGJ5IGEgdmVjdG9yXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge3ZlYzJ8dmVjM3xudW1iZXJbXX0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlYzJ8dmVjM3xudW1iZXJbXXxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBhbmQgdmVjdG9yIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bHYgPSAoYSwgYikgPT4ge1xcbiAgbGV0IG4sIGJiLCBydDtcXG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcXG4gICAgYmIgPSB2ZWMzLmNvbXBvbmVudHMoYik7XFxuICAgIG4gPSAzO1xcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XFxuICB9IGVsc2UgaWYgKF92ZWNfaXNfdmVjMihiKSkge1xcbiAgICBiYiA9IHZlYzIuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDI7XFxuICAgIHJ0ID0gdmVjMi5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGJiID0gYjtcXG4gICAgbiA9IGIubGVuZ3RoID8/IDA7XFxuICAgIHJ0ID0gdiA9PiB2O1xcbiAgfVxcbiAgaWYgKGEubiAhPT0gbikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgcmVzdWx0LnB1c2goX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgYmIpKTtcXG4gIH1cXG4gIHJldHVybiBydChyZXN1bHQpO1xcbn1cXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgX3ZlY190aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gfGF8IG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5kZXQgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGlmIChhLm0gPT09IDEpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcXG4gIH1cXG4gIGlmIChhLm0gPT09IDIpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcXG4gIH1cXG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgdG90YWwgKz0gc2lnbiAqIGEuZW50cmllc1tqIC0gMV0gKiBtYXQuZGV0KG1hdC5taW5vcihhLCAxLCBqKSk7XFxuICAgIHNpZ24gKj0gLTE7XFxuICB9XFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMyLCB2ZWMzLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZGVidWcvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1xcXCIpO1xcbmNsYXNzIERlYnVnIHtcXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0VmFsdWUpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLkRFRkFVTFRfT1BUSU9OUy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdENoYXJ0KSB7XFxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Q2hhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5ERUZBVUxUX09QVElPTlMuZGVmYXVsdENoYXJ0LCBvcHRpb25zLmRlZmF1bHRDaGFydCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlZmF1bHRNYXJrZXIpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRNYXJrZXIgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5ERUZBVUxUX09QVElPTlMuZGVmYXVsdE1hcmtlciwgb3B0aW9ucy5kZWZhdWx0TWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdEJvcmRlcikge1xcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEJvcmRlciA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLkRFRkFVTFRfT1BUSU9OUy5kZWZhdWx0Qm9yZGVyLCBvcHRpb25zLmRlZmF1bHRCb3JkZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRGVidWcuREVGQVVMVF9PUFRJT05TLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBNYXAoKTtcXG4gICAgICAgIHRoaXMuY2hhcnRzID0gbmV3IE1hcCgpO1xcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbmV3IE1hcCgpO1xcbiAgICAgICAgdGhpcy5ib3JkZXJzID0gbmV3IE1hcCgpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBkZWJ1ZyByZW5kZXJlciBmb3IgZGlzcGxheWluZyB2YWx1ZXMgYW5kIG1hcmtlcnNcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKG9wdGlvbnMgPSB7fSkge1xcbiAgICAgICAgaWYgKERlYnVnLmluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYnVnIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIERlYnVnLmluc3RhbmNlID0gbmV3IERlYnVnKG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmIChEZWJ1Zy5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWJ1ZyBub3QgcHJvcGVybHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBEZWJ1Zy5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogU2hvdyBhIGRlYnVnIHZhbHVlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgdmFsdWUobGFiZWwsIHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS52YWx1ZXMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRWYWx1ZSwgKF9hID0gaW5zdGFuY2UudmFsdWVzLmdldChsYWJlbCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgeyBsYWJlbCwgdmFsdWUgfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTaG93IGEgZGVidWcgY2hhcnRcXG4gICAgICovXFxuICAgIHN0YXRpYyBjaGFydChsYWJlbCwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBjb25zdCBjdXJyZW50Q2hhcnQgPSBpbnN0YW5jZS5jaGFydHMuZ2V0KGxhYmVsKTtcXG4gICAgICAgIGluc3RhbmNlLmNoYXJ0cy5zZXQobGFiZWwsIE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdENoYXJ0LCBjdXJyZW50Q2hhcnQgIT09IG51bGwgJiYgY3VycmVudENoYXJ0ICE9PSB2b2lkIDAgPyBjdXJyZW50Q2hhcnQgOiB7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHtcXG4gICAgICAgICAgICBsYWJlbCxcXG4gICAgICAgICAgICB2YWx1ZXM6IFsuLi4oKF9hID0gY3VycmVudENoYXJ0ID09PSBudWxsIHx8IGN1cnJlbnRDaGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudENoYXJ0LnZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCB2YWx1ZV0uc2xpY2UoLSgoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsdWVCdWZmZXJTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRDaGFydC52YWx1ZUJ1ZmZlclNpemUpKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIGEgZGVidWcgY2hhcnRcXG4gICAgICovXFxuICAgIHN0YXRpYyByZW1vdmVDaGFydChsYWJlbCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UuY2hhcnRzLmRlbGV0ZShsYWJlbCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBtYXJrZXIgaW4gd29ybGQgb3Igc2NyZWVuIHNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbWFya2VyKGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRNYXJrZXIsIChfYSA9IGluc3RhbmNlLm1hcmtlcnMuZ2V0KGxhYmVsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7IGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24gfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTaG93IGEgYm9yZGVyIGluIHdvcmxkIG9yIHNjcmVlbiBzcGFjZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGJvcmRlcihsYWJlbCwgdmFsdWUsIHBvc2l0aW9uLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib3JkZXJTaGFwZSkgPT09ICdjaXJjbGUnICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBib3JkZXIgaWYgaXQncyBjaXJjdWxhciBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJhZGl1c1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvcmRlclNoYXBlKSAhPT0gJ2NpcmNsZScgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaXplKSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBib3JkZXIgaWYgaXQncyByZWN0YW5ndWxhciAoZGVmYXVsdCBpcyByZWN0YW5ndWxhcikgYnV0XFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHNpemVcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS5ib3JkZXJzLnNldChsYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucy5kZWZhdWx0Qm9yZGVyLCAoX2EgPSBpbnN0YW5jZS5ib3JkZXJzLmdldChsYWJlbCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgeyBsYWJlbCwgdmFsdWUsIHBvc2l0aW9uIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVuZGVyIHRoZSBkZWJ1ZyB2YWx1ZXMgYW5kIG1hcmtlcnMgb250byBhIGNhbnZhc1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGRyYXcoY29udGV4dCwgdGFncywgY2xlYXIgPSB0cnVlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBEcmF3IHdvcmxkLXNwYWNlIG1hcmtlcnMgJiBib3JkZXJzXFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IG1hcmtlci50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobWFya2VyLnNwYWNlID09PSAnd29ybGQnKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdNYXJrZXIoY29udGV4dCwgbWFya2VyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuZm9yRWFjaChib3JkZXIgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IGJvcmRlci50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYm9yZGVyLnNwYWNlID09PSAnd29ybGQnKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICAgICAgLy8gRHJhdyB2YWx1ZXMsIGNoYXJ0cyBhbmQgc2NyZWVuLXNwYWNlIG1hcmtlcnMgJiBib3JkZXJzXFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xcbiAgICAgICAgbGV0IHBvc2l0aW9uO1xcbiAgICAgICAgbGV0IGxlZnRZID0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW47XFxuICAgICAgICBsZXQgcmlnaHRZID0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW47XFxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaW5zdGFuY2Uub3B0aW9ucy5saW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5wYWRkaW5nICogMjtcXG4gICAgICAgIGluc3RhbmNlLnZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSB2YWx1ZS50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmFsaWduKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIGxlZnRZKTtcXG4gICAgICAgICAgICAgICAgICAgIGxlZnRZICs9IGxpbmVIZWlnaHQgKyBpbnN0YW5jZS5vcHRpb25zLmxpbmVNYXJnaW47XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoY29udGV4dC5jYW52YXMuY2xpZW50V2lkdGggLSBpbnN0YW5jZS5vcHRpb25zLm1hcmdpbiwgcmlnaHRZKTtcXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGluc3RhbmNlLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gdmFsdWUubGFiZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCAoX2MgPSB2YWx1ZS52YWx1ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsIHZhbHVlLnNob3dMYWJlbCwgdHJ1ZSksIHBvc2l0aW9uLCB2YWx1ZS5hbGlnbiwgKF9kID0gdmFsdWUucGFkZGluZykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogaW5zdGFuY2Uub3B0aW9ucy5wYWRkaW5nLCAoX2UgPSB2YWx1ZS5mb250KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBpbnN0YW5jZS5vcHRpb25zLmZvbnQsIChfZiA9IHZhbHVlLmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGluc3RhbmNlLm9wdGlvbnMuZm9yZWdyb3VuZENvbG91ciwgKF9nID0gdmFsdWUuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogaW5zdGFuY2Uub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3VyKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuY2hhcnRzLmZvckVhY2goY2hhcnQgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gY2hhcnQudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUodGFnID0+IHRhZ3MuaW5jbHVkZXModGFnKSkpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3dpdGNoIChjaGFydC5hbGlnbikge1xcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKGluc3RhbmNlLm9wdGlvbnMubWFyZ2luLCBsZWZ0WSk7XFxuICAgICAgICAgICAgICAgICAgICBsZWZ0WSArPSBsaW5lSGVpZ2h0ICsgaW5zdGFuY2Uub3B0aW9ucy5saW5lTWFyZ2luO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKGNvbnRleHQuY2FudmFzLmNsaWVudFdpZHRoIC0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIHJpZ2h0WSk7XFxuICAgICAgICAgICAgICAgICAgICByaWdodFkgKz0gbGluZUhlaWdodCArIGluc3RhbmNlLm9wdGlvbnMubGluZU1hcmdpbjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnN0YW5jZS5kcmF3Q2hhcnQoY29udGV4dCwgRGVidWcucHJlcGFyZUxhYmVsKChfYiA9IGNoYXJ0LmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgJycsIGNoYXJ0LnNob3dMYWJlbCwgZmFsc2UpLCBwb3NpdGlvbiwgY2hhcnQuYWxpZ24sIChfYyA9IGNoYXJ0LnBhZGRpbmcpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGluc3RhbmNlLm9wdGlvbnMucGFkZGluZywgKF9kID0gY2hhcnQuZm9udCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogaW5zdGFuY2Uub3B0aW9ucy5mb250LCAoX2UgPSBjaGFydC5mb3JlZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBpbnN0YW5jZS5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZiA9IGNoYXJ0LmJhY2tncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGluc3RhbmNlLm9wdGlvbnMuYmFja2dyb3VuZENvbG91ciwgY2hhcnQuY2hhcnRCYWNrZ3JvdW5kQ29sb3VyLCBjaGFydC52YWx1ZXMsIGNoYXJ0LnZhbHVlQnVmZmVyU2l6ZSwgY2hhcnQudmFsdWVCdWZmZXJTdHJpZGUsIGNoYXJ0Lm1pblZhbHVlLCBjaGFydC5tYXhWYWx1ZSwgY2hhcnQuYmFyV2lkdGgsIGNoYXJ0LmJhckNvbG91cnMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpbnN0YW5jZS5tYXJrZXJzLmZvckVhY2gobWFya2VyID0+IHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSBtYXJrZXIudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUodGFnID0+IHRhZ3MuaW5jbHVkZXModGFnKSkpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG1hcmtlci5zcGFjZSA9PT0gJ3NjcmVlbicpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd01hcmtlcihjb250ZXh0LCBtYXJrZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5mb3JFYWNoKGJvcmRlciA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gYm9yZGVyLnRhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKHRhZyA9PiB0YWdzLmluY2x1ZGVzKHRhZykpKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChib3JkZXIuc3BhY2UgPT09ICdzY3JlZW4nKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICAgICAgLy8gQ2xlYXIgdmFsdWVzLCBtYXJrZXJzICYgYm9yZGVycyByZWFkeSBmb3IgbmV4dCBmcmFtZVxcbiAgICAgICAgaWYgKGNsZWFyKSB7XFxuICAgICAgICAgICAgaW5zdGFuY2UudmFsdWVzLmNsZWFyKCk7XFxuICAgICAgICAgICAgaW5zdGFuY2UubWFya2Vycy5jbGVhcigpO1xcbiAgICAgICAgICAgIGluc3RhbmNlLmJvcmRlcnMuY2xlYXIoKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBzdGF0aWMgY2xlYXIoY2xlYXJDaGFydHMgPSBmYWxzZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UudmFsdWVzLmNsZWFyKCk7XFxuICAgICAgICBpbnN0YW5jZS5tYXJrZXJzLmNsZWFyKCk7XFxuICAgICAgICBpZiAoY2xlYXJDaGFydHMpIHtcXG4gICAgICAgICAgICBpbnN0YW5jZS5jaGFydHMuY2xlYXIoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuY2xlYXIoKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgcHJlcGFyZUxhYmVsKGxhYmVsLCB2YWx1ZSwgc2hvd0xhYmVsLCBzaG93VmFsdWUpIHtcXG4gICAgICAgIGNvbnN0IGFjdHVhbExhYmVsID0gc2hvd0xhYmVsICYmIGxhYmVsID8gbGFiZWwgOiAnJztcXG4gICAgICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gISFzaG93VmFsdWUgJiYgdmFsdWUgIT09ICcnID8gdmFsdWUudG9TdHJpbmcoKSA6ICcnO1xcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gYWN0dWFsTGFiZWwgJiYgYWN0dWFsVmFsdWUgPyAnOiAnIDogJyc7XFxuICAgICAgICByZXR1cm4gYCR7YWN0dWFsTGFiZWx9JHtzZXBhcmF0b3J9JHthY3R1YWxWYWx1ZX1gO1xcbiAgICB9XFxuICAgIGRyYXdMYWJlbChjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbiwgYWxpZ24sIHBhZGRpbmcsIGZvbnQsIGZvcmVncm91bmRDb2xvdXIsIGJhY2tncm91bmRDb2xvdXIpIHtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XFxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IHtcXG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB4ID0gYWxpZ24gPT09ICdyaWdodCcgPyBwb3NpdGlvbi54IC0gYmFja2dyb3VuZFNpemUud2lkdGggOiBwb3NpdGlvbi54O1xcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggLSBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgYmFja2dyb3VuZFNpemUud2lkdGgsIGJhY2tncm91bmRTaXplLmhlaWdodCk7XFxuICAgICAgICAvLyBEcmF3IHRleHRcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q2hhcnQoY29udGV4dCwgbGFiZWwsIHBvc2l0aW9uLCBhbGlnbiwgcGFkZGluZywgZm9udCwgZm9yZWdyb3VuZENvbG91ciwgYmFja2dyb3VuZENvbG91ciwgY2hhcnRCYWNrZ3JvdW5kQ29sb3VyLCB2YWx1ZXMsIHZhbHVlQnVmZmVyU2l6ZSwgdmFsdWVCdWZmZXJTdHJpZGUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgYmFyV2lkdGgsIGJhckNvbG91cnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XFxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xcbiAgICAgICAgY29uc3QgY2hhcnRTaXplID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCAqIE1hdGguY2VpbCh2YWx1ZUJ1ZmZlclNpemUgLyBNYXRoLm1heCh2YWx1ZUJ1ZmZlclN0cmlkZSwgMSkpLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCBsYWJlbFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcgKyBjaGFydFNpemUud2lkdGggKyBwYWRkaW5nICogMixcXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5saW5lSGVpZ2h0ICsgcGFkZGluZyAqIDIsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgeCA9IGFsaWduID09PSAncmlnaHQnID8gcG9zaXRpb24ueCAtIGJhY2tncm91bmRTaXplLndpZHRoIDogcG9zaXRpb24ueDtcXG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3VyO1xcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4IC0gcGFkZGluZywgcG9zaXRpb24ueSAtIHBhZGRpbmcsIGJhY2tncm91bmRTaXplLndpZHRoLCBiYWNrZ3JvdW5kU2l6ZS5oZWlnaHQpO1xcbiAgICAgICAgLy8gRHJhdyBsYWJlbFxcbiAgICAgICAgaWYgKGxhYmVsKSB7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmb3JlZ3JvdW5kQ29sb3VyO1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGFiZWwsIHgsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRHJhdyBjaGFydFxcbiAgICAgICAgaWYgKGNoYXJ0QmFja2dyb3VuZENvbG91cikge1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2hhcnRCYWNrZ3JvdW5kQ29sb3VyO1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCArIHBhZGRpbmcgKyBsYWJlbFNpemUud2lkdGggKyBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgY2hhcnRTaXplLndpZHRoLCBjaGFydFNpemUuaGVpZ2h0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbWF4VmFsdWUgLSBtaW5WYWx1ZTtcXG4gICAgICAgIGNvbnN0IGJhck9mZnNldCA9ICgwLCB2ZWNfMS52ZWMyKSh4ICsgcGFkZGluZyArIGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nKTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5jZWlsKHZhbHVlcy5sZW5ndGggLyBNYXRoLm1heCh2YWx1ZUJ1ZmZlclN0cmlkZSwgMSkpOyBpKyspIHtcXG4gICAgICAgICAgICBsZXQgdmFsdWU7XFxuICAgICAgICAgICAgaWYgKHZhbHVlQnVmZmVyU3RyaWRlIDw9IDEpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YWx1ZSA9XFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNcXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaSAqIHZhbHVlQnVmZmVyU3RyaWRlLCAoaSArIDEpICogdmFsdWVCdWZmZXJTdHJpZGUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdmFsdWVCdWZmZXJTdHJpZGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGJhclNpemUgPSAoMCwgdmVjXzEudmVjMikoYmFyV2lkdGgsIE1hdGgucm91bmQoKGNoYXJ0U2l6ZS5oZWlnaHQgKiAodmFsdWUgLSBtaW5WYWx1ZSkpIC8gcmFuZ2UpKTtcXG4gICAgICAgICAgICBjb25zdCBiYXJQb3NpdGlvbiA9IHZlY18xLnZlYzIuYWRkKGJhck9mZnNldCwgKDAsIHZlY18xLnZlYzIpKCh2YWx1ZXMubGVuZ3RoIDwgdmFsdWVCdWZmZXJTaXplXFxuICAgICAgICAgICAgICAgID8gTWF0aC5jZWlsKCh2YWx1ZUJ1ZmZlclNpemUgLSB2YWx1ZXMubGVuZ3RoKSAvIHZhbHVlQnVmZmVyU3RyaWRlKSAqXFxuICAgICAgICAgICAgICAgICAgICBiYXJXaWR0aFxcbiAgICAgICAgICAgICAgICA6IDApICtcXG4gICAgICAgICAgICAgICAgaSAqIGJhcldpZHRoLCBjaGFydFNpemUuaGVpZ2h0IC0gYmFyU2l6ZS55KSk7XFxuICAgICAgICAgICAgY29uc3QgYmFyQ29sb3VyID0gKF9iID0gKGJhckNvbG91cnNcXG4gICAgICAgICAgICAgICAgPyAoX2EgPSBbLi4uYmFyQ29sb3Vyc10ucmV2ZXJzZSgpLmZpbmQoYyA9PiB2YWx1ZXNbaV0gPj0gYy5vZmZzZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3VyXFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhckNvbG91cjtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJhclBvc2l0aW9uLngsIGJhclBvc2l0aW9uLnksIGJhclNpemUueCwgYmFyU2l6ZS55KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdNYXJrZXIoY29udGV4dCwgbWFya2VyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKF9hID0gbWFya2VyLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgIGlmIChtYXJrZXIuc2hvd0xhYmVsIHx8IG1hcmtlci5zaG93VmFsdWUpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gbWFya2VyLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gbWFya2VyLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgbWFya2VyLnNob3dMYWJlbCwgbWFya2VyLnNob3dWYWx1ZSksIHZlY18xLnZlYzIuYWRkKHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6ICgwLCB2ZWNfMS52ZWMyKSgpLCBtYXJrZXIubGFiZWxPZmZzZXQpLCAnbGVmdCcsIChfZCA9IG1hcmtlci5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLm9wdGlvbnMucGFkZGluZywgKF9lID0gbWFya2VyLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3B0aW9ucy5mb250LCAoX2YgPSBtYXJrZXIuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IG1hcmtlci5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobWFya2VyLnNob3dNYXJrZXIpIHtcXG4gICAgICAgICAgICBpZiAobWFya2VyLm1hcmtlckltYWdlKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG1hcmtlci5tYXJrZXJJbWFnZSwgcG9zaXRpb24ueCAtIG1hcmtlci5tYXJrZXJJbWFnZS53aWR0aCAvIDIsIHBvc2l0aW9uLnkgLSBtYXJrZXIubWFya2VySW1hZ2UuaGVpZ2h0IC8gMik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG1hcmtlci5tYXJrZXJMaW5lV2lkdGg7XFxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb250ZXh0LmZpbGxTdHlsZSA9IG1hcmtlci5tYXJrZXJDb2xvdXI7XFxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWFya2VyLm1hcmtlclN0eWxlKSB7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDcm9zcyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBtYXJrZXIubWFya2VyU2l6ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q3Jvc3MoY29udGV4dCwgcG9zaXRpb24sIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3UGx1cyhjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDI7XFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54ICsgaGFsZlNpemUsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3RG90KGNvbnRleHQsIHBvc2l0aW9uLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5hcmMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKTtcXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICB9XFxuICAgIGRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gKF9hID0gYm9yZGVyLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgIGlmIChib3JkZXIuc2hvd0xhYmVsIHx8IGJvcmRlci5zaG93VmFsdWUpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gYm9yZGVyLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gYm9yZGVyLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgYm9yZGVyLnNob3dMYWJlbCwgYm9yZGVyLnNob3dWYWx1ZSksIHZlY18xLnZlYzIuYWRkKHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6ICgwLCB2ZWNfMS52ZWMyKSgpLCBib3JkZXIubGFiZWxPZmZzZXQpLCAnbGVmdCcsIChfZCA9IGJvcmRlci5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLm9wdGlvbnMucGFkZGluZywgKF9lID0gYm9yZGVyLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3B0aW9ucy5mb250LCAoX2YgPSBib3JkZXIuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZyA9IGJvcmRlci5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG91cik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYm9yZGVyLnNob3dCb3JkZXIpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlci5ib3JkZXJXaWR0aDtcXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29udGV4dC5maWxsU3R5bGUgPSBib3JkZXIuYm9yZGVyQ29sb3VyO1xcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclN0eWxlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyRGFzaFNpemUsIGJvcmRlci5ib3JkZXJEYXNoU2l6ZV0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtib3JkZXIuYm9yZGVyV2lkdGgsIGJvcmRlci5ib3JkZXJXaWR0aF0pO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN3aXRjaCAoYm9yZGVyLmJvcmRlclNoYXBlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9yZGVyLnNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5zaXplKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlci5yYWRpdXMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIGJvcmRlci5yYWRpdXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd1JlY3RhbmdsZShjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQucmVjdChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBzaXplLngsIHNpemUueSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDaXJjbGUoY29udGV4dCwgcG9zaXRpb24sIHJhZGl1cykge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQuYXJjKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBEZWJ1ZztcXG5EZWJ1Zy5ERUZBVUxUX09QVElPTlMgPSB7XFxuICAgIG1hcmdpbjogMTAsXFxuICAgIHBhZGRpbmc6IDQsXFxuICAgIGZvbnQ6ICcxMHB0IEx1Y2lkYSBDb25zb2xlLCBtb25vc3BhY2UnLFxcbiAgICBsaW5lSGVpZ2h0OiAxMixcXG4gICAgbGluZU1hcmdpbjogMCxcXG4gICAgZm9yZWdyb3VuZENvbG91cjogJyNmZmYnLFxcbiAgICBiYWNrZ3JvdW5kQ29sb3VyOiAnIzMzMycsXFxuICAgIGRlZmF1bHRWYWx1ZToge1xcbiAgICAgICAgYWxpZ246ICdsZWZ0JyxcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgfSxcXG4gICAgZGVmYXVsdENoYXJ0OiB7XFxuICAgICAgICB2YWx1ZXM6IFtdLFxcbiAgICAgICAgdmFsdWVCdWZmZXJTaXplOiA2MCxcXG4gICAgICAgIHZhbHVlQnVmZmVyU3RyaWRlOiAxLFxcbiAgICAgICAgbWluVmFsdWU6IDAsXFxuICAgICAgICBtYXhWYWx1ZTogMTAwLFxcbiAgICAgICAgYmFyV2lkdGg6IDIsXFxuICAgICAgICBhbGlnbjogJ2xlZnQnLFxcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICAgICAgY2hhcnRCYWNrZ3JvdW5kQ29sb3VyOiAnIzIyMicsXFxuICAgIH0sXFxuICAgIGRlZmF1bHRNYXJrZXI6IHtcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgICAgIHNob3dWYWx1ZTogdHJ1ZSxcXG4gICAgICAgIHNob3dNYXJrZXI6IHRydWUsXFxuICAgICAgICBtYXJrZXJTaXplOiA2LFxcbiAgICAgICAgbWFya2VyTGluZVdpZHRoOiAyLFxcbiAgICAgICAgbWFya2VyU3R5bGU6ICd4JyxcXG4gICAgICAgIG1hcmtlckNvbG91cjogJyNjY2MnLFxcbiAgICAgICAgc3BhY2U6ICd3b3JsZCcsXFxuICAgICAgICBsYWJlbE9mZnNldDogKDAsIHZlY18xLnZlYzIpKDEwKSxcXG4gICAgfSxcXG4gICAgZGVmYXVsdEJvcmRlcjoge1xcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICAgICAgc2hvd1ZhbHVlOiB0cnVlLFxcbiAgICAgICAgc2hvd0JvcmRlcjogdHJ1ZSxcXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxcbiAgICAgICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXFxuICAgICAgICBib3JkZXJTaGFwZTogJ3JlY3RhbmdsZScsXFxuICAgICAgICBib3JkZXJDb2xvdXI6ICcjY2NjJyxcXG4gICAgICAgIGJvcmRlckRhc2hTaXplOiA1LFxcbiAgICAgICAgc3BhY2U6ICd3b3JsZCcsXFxuICAgICAgICBsYWJlbE9mZnNldDogKDAsIHZlY18xLnZlYzIpKDEwKSxcXG4gICAgfSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIntcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pbWFnZUZvbnRDb250ZW50UHJvY2Vzc29yID0gZXhwb3J0cy5JbWFnZUZvbnQgPSBleHBvcnRzLmlzSW1hZ2VGb250Q29uZmlnRGF0YSA9IHZvaWQgMDtcXG5jb25zdCB0ZXh0dXJlX2F0bGFzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS90ZXh0dXJlLWF0bGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS90ZXh0dXJlLWF0bGFzL2J1aWxkL2luZGV4LmpzXFxcIik7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbi8vIFRZUEUgR1VBUkRTXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5mdW5jdGlvbiBpc0ltYWdlRm9udENvbmZpZ0RhdGEodmFsdWUpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgndGV4dHVyZUF0bGFzU2l6ZScgaW4gdmFsdWUpIHx8XFxuICAgICAgICB0eXBlb2YgdmFsdWUudGV4dHVyZUF0bGFzU2l6ZSAhPT0gJ29iamVjdCcgfHxcXG4gICAgICAgIHZhbHVlLnRleHR1cmVBdGxhc1NpemUgPT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgneCcgaW4gdmFsdWUudGV4dHVyZUF0bGFzU2l6ZSkgfHxcXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50ZXh0dXJlQXRsYXNTaXplLnggIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCEoJ3knIGluIHZhbHVlLnRleHR1cmVBdGxhc1NpemUpIHx8XFxuICAgICAgICB0eXBlb2YgdmFsdWUudGV4dHVyZUF0bGFzU2l6ZS55ICE9PSAnbnVtYmVyJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICgnb2Zmc2V0JyBpbiB2YWx1ZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5vZmZzZXQgIT09ICdvYmplY3QnIHx8IHZhbHVlLm9mZnNldCA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghKCd4JyBpbiB2YWx1ZS5vZmZzZXQpIHx8IHR5cGVvZiB2YWx1ZS5vZmZzZXQueCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoISgneScgaW4gdmFsdWUub2Zmc2V0KSB8fCB0eXBlb2YgdmFsdWUub2Zmc2V0LnkgIT09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgnc2NhbGUnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2FsZSAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2RlZmF1bHRDaGFyYWN0ZXJDb25maWcnIGluIHZhbHVlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLmRlZmF1bHRDaGFyYWN0ZXJDb25maWcgIT09ICdvYmplY3QnIHx8XFxuICAgICAgICAgICAgdmFsdWUuZGVmYXVsdENoYXJhY3RlckNvbmZpZyA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghaXNJbWFnZUZvbnRDaGFyYWN0ZXJDb25maWdEYXRhKHZhbHVlLmRlZmF1bHRDaGFyYWN0ZXJDb25maWcsIGZhbHNlKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoISgnY2hhcmFjdGVycycgaW4gdmFsdWUpIHx8XFxuICAgICAgICB0eXBlb2YgdmFsdWUuY2hhcmFjdGVycyAhPT0gJ29iamVjdCcgfHxcXG4gICAgICAgIHZhbHVlLmNoYXJhY3RlcnMgPT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBmb3IgKGNvbnN0IFtjaGFyLCBjb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlLmNoYXJhY3RlcnMpKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnIHx8IGNoYXIubGVuZ3RoICE9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBDaGFyYWN0ZXIga2V5cyBtdXN0IGJlIHNpbmdsZSBjaGFyYWN0ZXJzXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWlzSW1hZ2VGb250Q2hhcmFjdGVyQ29uZmlnRGF0YShjb25maWcpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbn1cXG5leHBvcnRzLmlzSW1hZ2VGb250Q29uZmlnRGF0YSA9IGlzSW1hZ2VGb250Q29uZmlnRGF0YTtcXG5mdW5jdGlvbiBpc0ltYWdlRm9udENoYXJhY3RlckNvbmZpZ0RhdGEodmFsdWUsIGluY2x1ZGVUZXh0dXJlQXRsYXNQb3NpdGlvbiA9IHRydWUpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoaW5jbHVkZVRleHR1cmVBdGxhc1Bvc2l0aW9uKSB7XFxuICAgICAgICBpZiAoISgndGV4dHVyZUF0bGFzUG9zaXRpb24nIGluIHZhbHVlKSB8fFxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50ZXh0dXJlQXRsYXNQb3NpdGlvbiAhPT0gJ29iamVjdCcgfHxcXG4gICAgICAgICAgICB2YWx1ZS50ZXh0dXJlQXRsYXNQb3NpdGlvbiA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghKCd4JyBpbiB2YWx1ZS50ZXh0dXJlQXRsYXNQb3NpdGlvbikgfHxcXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudGV4dHVyZUF0bGFzUG9zaXRpb24ueCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoISgneScgaW4gdmFsdWUudGV4dHVyZUF0bGFzUG9zaXRpb24pIHx8XFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRleHR1cmVBdGxhc1Bvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgnb2Zmc2V0JyBpbiB2YWx1ZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5vZmZzZXQgIT09ICdvYmplY3QnIHx8IHZhbHVlLm9mZnNldCA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghKCd4JyBpbiB2YWx1ZS5vZmZzZXQpIHx8IHR5cGVvZiB2YWx1ZS5vZmZzZXQueCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoISgneScgaW4gdmFsdWUub2Zmc2V0KSB8fCB0eXBlb2YgdmFsdWUub2Zmc2V0LnkgIT09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgnd2lkdGgnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS53aWR0aCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2hlaWdodCcgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmhlaWdodCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG59XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBJTUFHRSBGT05UIENMQVNTXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5jbGFzcyBJbWFnZUZvbnQge1xcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlcywgY29uZmlnKSB7XFxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XFxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcXG4gICAgICAgICAgICAuLi5JbWFnZUZvbnQuREVGQVVMVF9DT05GSUcsXFxuICAgICAgICAgICAgLi4uY29uZmlnLFxcbiAgICAgICAgICAgIGRlZmF1bHRDaGFyYWN0ZXJDb25maWc6IHtcXG4gICAgICAgICAgICAgICAgLi4uSW1hZ2VGb250LkRFRkFVTFRfQ09ORklHLmRlZmF1bHRDaGFyYWN0ZXJDb25maWcsXFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0Q2hhcmFjdGVyQ29uZmlnLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgY2hhcmFjdGVyczoge1xcbiAgICAgICAgICAgICAgICAuLi5JbWFnZUZvbnQuREVGQVVMVF9DT05GSUcuY2hhcmFjdGVycyxcXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLmNoYXJhY3RlcnMsXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgYSBzaW5nbGUgY2hhcmFjdGVyIHdoZW4gcmVuZGVyZWQgd2l0aCB0aGlzIGZvbnRcXG4gICAgICovXFxuICAgIG1lYXN1cmVDaGFyYWN0ZXJXaWR0aChjaGFyYWN0ZXIsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcXG4gICAgICAgIGNvbnN0IGNoYXJhY3RlckNvbmZpZyA9IHRoaXMuY29uZmlnLmNoYXJhY3RlcnNbY2hhcmFjdGVyXTtcXG4gICAgICAgIGNvbnN0IGFjdHVhbFNjYWxlID0gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgKiAoKF9iID0gdGhpcy5jb25maWcuc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpO1xcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbY2hhcmFjdGVyXTtcXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1vbm9zcGFjZSkge1xcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmtlcm5pbmcpICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLmtlcm5pbmc7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB3aWR0aCA9XFxuICAgICAgICAgICAgICAgICAgICAoX2UgPSAoX2QgPSAoX2MgPSB0aGlzLmNvbmZpZy5kZWZhdWx0Q2hhcmFjdGVyQ29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mud2lkdGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRleHR1cmUgPT09IG51bGwgfHwgdGV4dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dHVyZS53aWR0aCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB3aWR0aCA9XFxuICAgICAgICAgICAgICAgICgoX2ogPSAoX2ggPSAoX2YgPSBjaGFyYWN0ZXJDb25maWcgPT09IG51bGwgfHwgY2hhcmFjdGVyQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFyYWN0ZXJDb25maWcud2lkdGgpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChfZyA9IHRoaXMuY29uZmlnLmRlZmF1bHRDaGFyYWN0ZXJDb25maWcpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy53aWR0aCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdGV4dHVyZSA9PT0gbnVsbCB8fCB0ZXh0dXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0dXJlLndpZHRoKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAwKSAqICgoX2sgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2VybmluZykgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogMSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gd2lkdGggKiBhY3R1YWxTY2FsZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgYSBzaW5nbGUgY2hhcmFjdGVyIHdoZW4gcmVuZGVyZWQgd2l0aCB0aGlzIGZvbnRcXG4gICAgICovXFxuICAgIG1lYXN1cmVDaGFyYWN0ZXJIZWlnaHQoY2hhcmFjdGVyLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyQ29uZmlnID0gdGhpcy5jb25maWcuY2hhcmFjdGVyc1tjaGFyYWN0ZXJdO1xcbiAgICAgICAgY29uc3QgYWN0dWFsU2NhbGUgPSAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSAqICgoX2IgPSB0aGlzLmNvbmZpZy5zY2FsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSk7XFxuICAgICAgICByZXR1cm4gKCgoX2UgPSAoX2MgPSBjaGFyYWN0ZXJDb25maWcgPT09IG51bGwgfHwgY2hhcmFjdGVyQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFyYWN0ZXJDb25maWcuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0aGlzLmNvbmZpZy5kZWZhdWx0Q2hhcmFjdGVyQ29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKSAqIGFjdHVhbFNjYWxlKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IHRoZSB3aWR0aCBvZiBhIHN0cmluZyBvZiB0ZXh0IHdoZW4gcmVuZGVyZWQgd2l0aCB0aGlzIGZvbnRcXG4gICAgICovXFxuICAgIG1lYXN1cmVUZXh0KHRleHQsIG9wdGlvbnMpIHtcXG4gICAgICAgIC8vIFdoZW4gY2FsY3VsYXRpbmcgdGhlIHRvdGFsIHdpZHRoLCBpZ25vcmUga2VybmluZyBmb3IgdGhlIGxhc3QgY2hhcmFjdGVyXFxuICAgICAgICBjb25zdCBsYXN0Q2hhcmFjdGVyV2lkdGggPSB0aGlzLm1lYXN1cmVDaGFyYWN0ZXJXaWR0aCh0ZXh0W3RleHQubGVuZ3RoIC0gMV0sIHtcXG4gICAgICAgICAgICBzY2FsZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjYWxlLFxcbiAgICAgICAgfSk7XFxuICAgICAgICBjb25zdCB3aWR0aCA9IHRleHRcXG4gICAgICAgICAgICAuc3BsaXQoJycpXFxuICAgICAgICAgICAgLnNsaWNlKDAsIHRleHQubGVuZ3RoIC0gMSlcXG4gICAgICAgICAgICAucmVkdWNlKCh3aWR0aCwgY2hhcmFjdGVyKSA9PiB3aWR0aCArIHRoaXMubWVhc3VyZUNoYXJhY3RlcldpZHRoKGNoYXJhY3Rlciwgb3B0aW9ucyksIDApICsgbGFzdENoYXJhY3RlcldpZHRoO1xcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoLi4udGV4dFxcbiAgICAgICAgICAgIC5zcGxpdCgnJylcXG4gICAgICAgICAgICAubWFwKGNoYXJhY3RlciA9PiB0aGlzLm1lYXN1cmVDaGFyYWN0ZXJIZWlnaHQoY2hhcmFjdGVyLCBvcHRpb25zKSkpO1xcbiAgICAgICAgcmV0dXJuICgwLCB2ZWNfMS52ZWMyKSh3aWR0aCwgaGVpZ2h0KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRHJhdyB0ZXh0IG9uIGEgY2FudmFzIHVzaW5nIHRoaXMgZm9udFxcbiAgICAgKi9cXG4gICAgZHJhd1RleHQoY29udGV4dCwgdGV4dCwgeCwgeSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XFxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5tZWFzdXJlVGV4dCh0ZXh0LCBvcHRpb25zKTtcXG4gICAgICAgIGxldCBjdXJyZW50WCA9IHg7XFxuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGlnbikge1xcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRYIC09IHNpemUueCAvIDI7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgICAgICAgICAgY3VycmVudFggLT0gc2l6ZS54O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IGFjdHVhbFNjYWxlID0gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgKiAoKF9iID0gdGhpcy5jb25maWcuc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpO1xcbiAgICAgICAgbGV0IGFjdHVhbFkgPSB5O1xcbiAgICAgICAgc3dpdGNoIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZUxpbmUpIHtcXG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxcbiAgICAgICAgICAgICAgICBhY3R1YWxZID0geSAtIHNpemUueSAvIDI7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XFxuICAgICAgICAgICAgICAgIGFjdHVhbFkgPSB5IC0gc2l6ZS55O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoY29uc3QgY2hhcmFjdGVyIG9mIHRleHQpIHtcXG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJXaWR0aCA9IHRoaXMubWVhc3VyZUNoYXJhY3RlcldpZHRoKGNoYXJhY3Rlciwgb3B0aW9ucyk7XFxuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbY2hhcmFjdGVyXTtcXG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFggKz0gY2hhcmFjdGVyV2lkdGg7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJDb25maWcgPSB0aGlzLmNvbmZpZy5jaGFyYWN0ZXJzW2NoYXJhY3Rlcl07XFxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdmVjXzEudmVjMi5hZGQoKF9jID0gdGhpcy5jb25maWcub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoMCwgdmVjXzEudmVjMikoKSwgKF9mID0gKF9kID0gY2hhcmFjdGVyQ29uZmlnID09PSBudWxsIHx8IGNoYXJhY3RlckNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhcmFjdGVyQ29uZmlnLm9mZnNldCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKF9lID0gdGhpcy5jb25maWcuZGVmYXVsdENoYXJhY3RlckNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm9mZnNldCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogKDAsIHZlY18xLnZlYzIpKCkpO1xcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIGN1cnJlbnRYIC0gb2Zmc2V0LnggKiBhY3R1YWxTY2FsZSwgYWN0dWFsWSAtIG9mZnNldC55ICogYWN0dWFsU2NhbGUsIHRleHR1cmUud2lkdGggKiBhY3R1YWxTY2FsZSwgdGV4dHVyZS5oZWlnaHQgKiBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAgICAgY3VycmVudFggKz0gY2hhcmFjdGVyV2lkdGg7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuZXhwb3J0cy5JbWFnZUZvbnQgPSBJbWFnZUZvbnQ7XFxuSW1hZ2VGb250LkRFRkFVTFRfQ09ORklHID0ge1xcbiAgICBvZmZzZXQ6ICgwLCB2ZWNfMS52ZWMyKSgpLFxcbiAgICBzY2FsZTogMSxcXG4gICAgZGVmYXVsdENoYXJhY3RlckNvbmZpZzoge1xcbiAgICAgICAgb2Zmc2V0OiAoMCwgdmVjXzEudmVjMikoKSxcXG4gICAgfSxcXG4gICAgY2hhcmFjdGVyczoge30sXFxufTtcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbi8vIENPTlRFTlQgUFJPQ0VTU09SXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vKipcXG4gKiBDb250ZW50IE1hbmFnZXIgUHJvY2Vzc29yIGZvciBsb2FkaW5nIGltYWdlIGZvbnRzXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlclxcbiAqL1xcbmFzeW5jIGZ1bmN0aW9uIGltYWdlRm9udENvbnRlbnRQcm9jZXNzb3IoY29udGVudCwgZGF0YSwgaW1hZ2VOYW1lKSB7XFxuICAgIHZhciBfYTtcXG4gICAgaWYgKCFpc0ltYWdlRm9udENvbmZpZ0RhdGEoZGF0YS5jb250ZW50KSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltYWdlIGZvbnQgY29uZmlnJyk7XFxuICAgIH1cXG4gICAgY29uc3QgaW1hZ2UgPSAoX2EgPSBjb250ZW50W2ltYWdlTmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xcbiAgICBpZiAoIWltYWdlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlICcke2ltYWdlTmFtZX0nIG5vdCBmb3VuZGApO1xcbiAgICB9XFxuICAgIC8vIENyZWF0ZSB0aGUgdGV4dHVyZSBhdGxhc1xcbiAgICBjb25zdCBhdGxhcyA9ICgwLCB0ZXh0dXJlX2F0bGFzXzEudGV4dHVyZUF0bGFzKShpbWFnZSwge1xcbiAgICAgICAgcmVsYXRpdmU6IHRydWUsXFxuICAgICAgICB3aWR0aDogZGF0YS5jb250ZW50LnRleHR1cmVBdGxhc1NpemUueCxcXG4gICAgICAgIGhlaWdodDogZGF0YS5jb250ZW50LnRleHR1cmVBdGxhc1NpemUueSxcXG4gICAgICAgIHJlZ2lvbnM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkYXRhLmNvbnRlbnQuY2hhcmFjdGVycykubWFwKChbY2hhciwgY29uZmlnXSkgPT4gW1xcbiAgICAgICAgICAgIGNoYXIsXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICB4OiBjb25maWcudGV4dHVyZUF0bGFzUG9zaXRpb24ueCxcXG4gICAgICAgICAgICAgICAgeTogY29uZmlnLnRleHR1cmVBdGxhc1Bvc2l0aW9uLnksXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIF0pKSxcXG4gICAgfSk7XFxuICAgIC8vIENyZWF0ZSB0aGUgaW1hZ2UgZm9udFxcbiAgICBjb25zdCBmb250ID0gbmV3IEltYWdlRm9udChhdGxhcywgZGF0YS5jb250ZW50KTtcXG4gICAgLy8gU3RvcmUgdGhlIGZvbnQgaW4gdGhlIGNvbnRlbnQgbWFuYWdlclxcbiAgICBjb250ZW50W2RhdGEubmFtZV0gPSB7XFxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXFxuICAgICAgICB0eXBlOiAnanNvbicsXFxuICAgICAgICBjb250ZW50OiBmb250LFxcbiAgICAgICAgc3RhdHVzOiAncHJvY2Vzc2VkJyxcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5pbWFnZUZvbnRDb250ZW50UHJvY2Vzc29yID0gaW1hZ2VGb250Q29udGVudFByb2Nlc3NvcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbWFnZS1mb250Ly4vaW5kZXgudHM/XFxufVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdGV4dHVyZS1hdGxhcy9idWlsZC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3RleHR1cmUtYXRsYXMvYnVpbGQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCJ7LypcXG4gKiBBVFRFTlRJT046IFRoZSBcXFwiZXZhbFxcXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFxcXCJkZXZlbG9wbWVudFxcXCIpLlxcbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXFxuICogSXQgdXNlcyBcXFwiZXZhbCgpXFxcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcXFwiZGV2dG9vbDogZmFsc2VcXFwiLlxcbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcXFwicHJvZHVjdGlvblxcXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXFxuICovXFxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZih0cnVlKVxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xcblxcdGVsc2UgLy8gcmVtb3ZlZCBieSBkZWFkIGNvbnRyb2wgZmxvd1xcbnsgdmFyIGksIGE7IH1cXG59KShzZWxmLCAoKSA9PiB7XFxucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcXG4vKioqKioqLyBcXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuLyoqKioqKi8gXFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xcblxcbi8qKiovIFxcXCIuL2luZGV4LnRzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqL1xcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcXG5cXG5ldmFsKFxcXCJcXFxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFxcXFxcIl9fZXNNb2R1bGVcXFxcXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcXFxuZXhwb3J0cy50ZXh0dXJlQXRsYXNDb250ZW50UHJvY2Vzc29yID0gZXhwb3J0cy50ZXh0dXJlQXRsYXMgPSBleHBvcnRzLmlzVGV4dHVyZUF0bGFzUmVnaW9uID0gZXhwb3J0cy5pc1RleHR1cmVBdGxhc09wdGlvbnMgPSB2b2lkIDA7XFxcXG5mdW5jdGlvbiBpc1RleHR1cmVBdGxhc09wdGlvbnModmFsdWUpIHtcXFxcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoISgncmVsYXRpdmUnIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVsYXRpdmUgIT09ICdib29sZWFuJykge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIGlmICghKCd3aWR0aCcgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS53aWR0aCAhPT0gJ251bWJlcicpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoISgnaGVpZ2h0JyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmhlaWdodCAhPT0gJ251bWJlcicpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoISgncmVnaW9ucycgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZWdpb25zICE9PSAnb2JqZWN0Jykge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIGZvciAoY29uc3QgW2tleSwgcmVnaW9uXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZS5yZWdpb25zKSkge1xcXFxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoIWlzVGV4dHVyZUF0bGFzUmVnaW9uKHJlZ2lvbikpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBpZiAoISgnY2VsbE1hcmdpbicgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5jZWxsTWFyZ2luICE9PSAnbnVtYmVyJykge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB0cnVlO1xcXFxufVxcXFxuZXhwb3J0cy5pc1RleHR1cmVBdGxhc09wdGlvbnMgPSBpc1RleHR1cmVBdGxhc09wdGlvbnM7XFxcXG5mdW5jdGlvbiBpc1RleHR1cmVBdGxhc1JlZ2lvbih2YWx1ZSkge1xcXFxuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xcXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgfVxcXFxuICAgIGlmICghKCd4JyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnggIT09ICdudW1iZXInKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKCEoJ3knIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUueSAhPT0gJ251bWJlcicpIHtcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoJ3dpZHRoJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUud2lkdGggIT09ICdudW1iZXInKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKCdoZWlnaHQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5oZWlnaHQgIT09ICdudW1iZXInKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKCdyZXBlYXQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5yZXBlYXQgIT09ICdudW1iZXInKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKCdyZXBlYXRPZmZzZXQnIGluIHZhbHVlKSB7XFxcXG4gICAgICAgIGNvbnN0IHJlcGVhdE9mZnNldCA9IHZhbHVlLnJlcGVhdE9mZnNldDtcXFxcbiAgICAgICAgaWYgKCFyZXBlYXRPZmZzZXQgfHwgdHlwZW9mIHJlcGVhdE9mZnNldCAhPT0gJ29iamVjdCcpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoISgneCcgaW4gcmVwZWF0T2Zmc2V0KSB8fCB0eXBlb2YgcmVwZWF0T2Zmc2V0LnggIT09ICdudW1iZXInKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKCEoJ3knIGluIHJlcGVhdE9mZnNldCkgfHwgdHlwZW9mIHJlcGVhdE9mZnNldC55ICE9PSAnbnVtYmVyJykge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIGlmICgncmVwZWF0TmFtZUZvcm1hdCcgaW4gdmFsdWUgJiZcXFxcbiAgICAgICAgdHlwZW9mIHZhbHVlLnJlcGVhdE5hbWVGb3JtYXQgIT09ICdzdHJpbmcnKSB7XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHRydWU7XFxcXG59XFxcXG5leHBvcnRzLmlzVGV4dHVyZUF0bGFzUmVnaW9uID0gaXNUZXh0dXJlQXRsYXNSZWdpb247XFxcXG5jb25zdCBERUZBVUxUX1JFUEVBVElOR19SRUdJT05fTkFNRV9GT1JNQVQgPSAne25hbWV9LXtufSc7XFxcXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XFxcXG4gICAgcmVsYXRpdmU6IHRydWUsXFxcXG4gICAgd2lkdGg6IDEsXFxcXG4gICAgaGVpZ2h0OiAxLFxcXFxuICAgIHJlZ2lvbnM6IHtcXFxcbiAgICAgICAgZGVmYXVsdDoge1xcXFxuICAgICAgICAgICAgeDogMCxcXFxcbiAgICAgICAgICAgIHk6IDAsXFxcXG4gICAgICAgIH0sXFxcXG4gICAgfSxcXFxcbiAgICBjZWxsTWFyZ2luOiAwLFxcXFxufTtcXFxcbi8qKlxcXFxuICogVGFrZXMgYW4gaW1hZ2UgYW5kIHNvbWUgdGV4dHVyZSBhdGxhcyBvcHRpb25zIGFuZCByZXR1cm5zIGEgZGljdGlvbmFyeVxcXFxuICogb2YgY2FudmFzZXMgaW5kZXhlZCBieSByZWdpb24gbmFtZVxcXFxuICovXFxcXG5mdW5jdGlvbiB0ZXh0dXJlQXRsYXMoaW1hZ2UsIG9wdGlvbnMpIHtcXFxcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XFxcXG4gICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcXFxuICAgIGlmIChhY3R1YWxPcHRpb25zLndpZHRoIDw9IDAgfHwgYWN0dWFsT3B0aW9ucy5oZWlnaHQgPD0gMCkge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoT2JqZWN0LmtleXMoYWN0dWFsT3B0aW9ucy5yZWdpb25zKS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWdpb25zIGRlZmluZWQnKTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IGNlbGxXaWR0aCA9IDE7XFxcXG4gICAgbGV0IGNlbGxIZWlnaHQgPSAxO1xcXFxuICAgIGlmIChhY3R1YWxPcHRpb25zLnJlbGF0aXZlKSB7XFxcXG4gICAgICAgIGxldCBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGg7XFxcXG4gICAgICAgIGxldCBpbWFnZUhlaWdodCA9IGltYWdlLmhlaWdodDtcXFxcbiAgICAgICAgaWYgKGFjdHVhbE9wdGlvbnMuY2VsbE1hcmdpbiA+IDApIHtcXFxcbiAgICAgICAgICAgIGltYWdlV2lkdGggLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcXFxuICAgICAgICAgICAgaW1hZ2VIZWlnaHQgLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGguY2VpbChpbWFnZVdpZHRoIC8gYWN0dWFsT3B0aW9ucy53aWR0aCk7XFxcXG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLmNlaWwoaW1hZ2VIZWlnaHQgLyBhY3R1YWxPcHRpb25zLmhlaWdodCk7XFxcXG4gICAgfVxcXFxuICAgIGNvbnN0IG1hcCA9IHt9O1xcXFxuICAgIGZvciAoY29uc3QgW25hbWUsIHJlZ2lvbl0gb2YgT2JqZWN0LmVudHJpZXMoYWN0dWFsT3B0aW9ucy5yZWdpb25zKSkge1xcXFxuICAgICAgICBsZXQgYWJzb2x1dGVYID0gTWF0aC5mbG9vcihyZWdpb24ueCAqIGNlbGxXaWR0aCk7XFxcXG4gICAgICAgIGxldCBhYnNvbHV0ZVkgPSBNYXRoLmZsb29yKHJlZ2lvbi55ICogY2VsbEhlaWdodCk7XFxcXG4gICAgICAgIGxldCBhYnNvbHV0ZVdpZHRoID0gTWF0aC5jZWlsKHJlZ2lvbi53aWR0aFxcXFxuICAgICAgICAgICAgPyAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcXFxuICAgICAgICAgICAgICAgID8gcmVnaW9uLndpZHRoICogY2VsbFdpZHRoXFxcXG4gICAgICAgICAgICAgICAgOiByZWdpb24ud2lkdGgpXFxcXG4gICAgICAgICAgICA6IChhY3R1YWxPcHRpb25zLnJlbGF0aXZlXFxcXG4gICAgICAgICAgICAgICAgPyBjZWxsV2lkdGhcXFxcbiAgICAgICAgICAgICAgICA6IGltYWdlLndpZHRoIC0gYWJzb2x1dGVYKSk7XFxcXG4gICAgICAgIGxldCBhYnNvbHV0ZUhlaWdodCA9IE1hdGguY2VpbChyZWdpb24uaGVpZ2h0XFxcXG4gICAgICAgICAgICA/IChhY3R1YWxPcHRpb25zLnJlbGF0aXZlXFxcXG4gICAgICAgICAgICAgICAgPyByZWdpb24uaGVpZ2h0ICogY2VsbEhlaWdodFxcXFxuICAgICAgICAgICAgICAgIDogcmVnaW9uLmhlaWdodClcXFxcbiAgICAgICAgICAgIDogKGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXFxcbiAgICAgICAgICAgICAgICA/IGNlbGxIZWlnaHRcXFxcbiAgICAgICAgICAgICAgICA6IGltYWdlLmhlaWdodCAtIGFic29sdXRlWSkpO1xcXFxuICAgICAgICBpZiAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZSAmJiBhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW4gPiAwKSB7XFxcXG4gICAgICAgICAgICBhYnNvbHV0ZVggKz0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcXFxuICAgICAgICAgICAgYWJzb2x1dGVZICs9IGFjdHVhbE9wdGlvbnMuY2VsbE1hcmdpbjtcXFxcbiAgICAgICAgICAgIGFic29sdXRlV2lkdGggLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcXFxuICAgICAgICAgICAgYWJzb2x1dGVIZWlnaHQgLT0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChyZWdpb24ucmVwZWF0ICYmIHJlZ2lvbi5yZXBlYXQgPiAwKSB7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbi5yZXBlYXQ7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGVhdE5hbWUgPSBnZXRSZXBlYXRpbmdSZWdpb25OYW1lKG5hbWUsIGkgKyAxLCByZWdpb24ucmVwZWF0TmFtZUZvcm1hdCk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlcGVhdE9mZnNldFggPSBNYXRoLmZsb29yKCgoKF9hID0gcmVnaW9uLnJlcGVhdE9mZnNldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSB1bmRlZmluZWQgJiZcXFxcbiAgICAgICAgICAgICAgICAgICAgKChfYiA9IHJlZ2lvbi5yZXBlYXRPZmZzZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi54KSAhPT0gbnVsbClcXFxcbiAgICAgICAgICAgICAgICAgICAgPyAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWdpb24ucmVwZWF0T2Zmc2V0LnggKiBjZWxsV2lkdGhcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVnaW9uLnJlcGVhdE9mZnNldC54KVxcXFxuICAgICAgICAgICAgICAgICAgICA6IGNlbGxXaWR0aCk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlcGVhdE9mZnNldFkgPSBNYXRoLmZsb29yKCgoKF9jID0gcmVnaW9uLnJlcGVhdE9mZnNldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnkpICE9PSB1bmRlZmluZWQgJiZcXFxcbiAgICAgICAgICAgICAgICAgICAgKChfZCA9IHJlZ2lvbi5yZXBlYXRPZmZzZXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC55KSAhPT0gbnVsbClcXFxcbiAgICAgICAgICAgICAgICAgICAgPyAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWdpb24ucmVwZWF0T2Zmc2V0LnkgKiBjZWxsSGVpZ2h0XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZ2lvbi5yZXBlYXRPZmZzZXQueSlcXFxcbiAgICAgICAgICAgICAgICAgICAgOiAwKTtcXFxcbiAgICAgICAgICAgICAgICBtYXBbcmVwZWF0TmFtZV0gPSBjaG9wUmVnaW9uKGltYWdlLCBhYnNvbHV0ZVggKyByZXBlYXRPZmZzZXRYICogaSwgYWJzb2x1dGVZICsgcmVwZWF0T2Zmc2V0WSAqIGksIGFic29sdXRlV2lkdGgsIGFic29sdXRlSGVpZ2h0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIG1hcFtuYW1lXSA9IGNob3BSZWdpb24oaW1hZ2UsIGFic29sdXRlWCwgYWJzb2x1dGVZLCBhYnNvbHV0ZVdpZHRoLCBhYnNvbHV0ZUhlaWdodCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIG1hcDtcXFxcbn1cXFxcbmV4cG9ydHMudGV4dHVyZUF0bGFzID0gdGV4dHVyZUF0bGFzO1xcXFxuLyoqXFxcXG4gKiBDaG9wIGEgcmVjdGFuZ3VsYXIgcmVnaW9uIGZyb20gYW4gaW1hZ2UgaW50byBhIG5ldyBjYW52YXNcXFxcbiAqL1xcXFxuZnVuY3Rpb24gY2hvcFJlZ2lvbihpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xcXFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xcXFxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXFxcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcXFxcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xcXFxuICAgIGlmICghY29udGV4dCkge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgMkQgY29udGV4dCcpO1xcXFxuICAgIH1cXFxcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XFxcXG4gICAgcmV0dXJuIGNhbnZhcztcXFxcbn1cXFxcbi8qKlxcXFxuICogR2V0IHRoZSBuYW1lIG9mIGEgcmVwZWF0aW5nIHJlZ2lvblxcXFxuICovXFxcXG5mdW5jdGlvbiBnZXRSZXBlYXRpbmdSZWdpb25OYW1lKHJlZ2lvbk5hbWUsIHJlcGV0aXRpb25JbmRleCwgcmVnaW9uTmFtZUZvcm1hdCkge1xcXFxuICAgIHJldHVybiAocmVnaW9uTmFtZUZvcm1hdCAhPT0gbnVsbCAmJiByZWdpb25OYW1lRm9ybWF0ICE9PSB2b2lkIDAgPyByZWdpb25OYW1lRm9ybWF0IDogREVGQVVMVF9SRVBFQVRJTkdfUkVHSU9OX05BTUVfRk9STUFUKVxcXFxuICAgICAgICAucmVwbGFjZSgne25hbWV9JywgcmVnaW9uTmFtZSlcXFxcbiAgICAgICAgLnJlcGxhY2UoJ3tufScsIHJlcGV0aXRpb25JbmRleC50b1N0cmluZygpKTtcXFxcbn1cXFxcbi8qKlxcXFxuICogQ29udGVudCBNYW5hZ2VyIFByb2Nlc3NvciB3cmFwcGVyIHdoaWNoIGFsbG93cyB0aGUgdGV4dHVyZUF0bGFzIGZ1bmN0aW9uXFxcXG4gKiB0byBiZSB1c2VkIGFzIGEgcHJvY2Vzc29yIGluIGEgQ29udGVudCBNYW5hZ2VyXFxcXG4gKlxcXFxuICogQHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXJcXFxcbiAqL1xcXFxuYXN5bmMgZnVuY3Rpb24gdGV4dHVyZUF0bGFzQ29udGVudFByb2Nlc3Nvcihjb250ZW50LCBkYXRhLCBpbWFnZU5hbWUpIHtcXFxcbiAgICB2YXIgX2E7XFxcXG4gICAgaWYgKCFpc1RleHR1cmVBdGxhc09wdGlvbnMoZGF0YS5jb250ZW50KSkge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGV4dHVyZSBhdGxhcyBvcHRpb25zJyk7XFxcXG4gICAgfVxcXFxuICAgIGNvbnN0IGltYWdlID0gKF9hID0gY29udGVudFtpbWFnZU5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcXFxcbiAgICBpZiAoIWltYWdlKSB7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgJyR7aW1hZ2VOYW1lfScgbm90IGZvdW5kYCk7XFxcXG4gICAgfVxcXFxuICAgIGNvbnN0IG1hcCA9IHRleHR1cmVBdGxhcyhpbWFnZSwgZGF0YS5jb250ZW50KTtcXFxcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjYW52YXNdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcXFxcbiAgICAgICAgY29udGVudFtuYW1lXSA9IHtcXFxcbiAgICAgICAgICAgIG5hbWUsXFxcXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxcXFxuICAgICAgICAgICAgY29udGVudDogY2FudmFzLFxcXFxuICAgICAgICAgICAgc3RhdHVzOiA0LFxcXFxuICAgICAgICB9O1xcXFxuICAgIH1cXFxcbn1cXFxcbmV4cG9ydHMudGV4dHVyZUF0bGFzQ29udGVudFByb2Nlc3NvciA9IHRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3I7XFxcXG5cXFxcblxcXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGV4dHVyZS1hdGxhcy8uL2luZGV4LnRzP1xcXCIpO1xcblxcbi8qKiovIH0pXFxuXFxuLyoqKioqKi8gXFx0fSk7XFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyBcXHRcXG4vKioqKioqLyBcXHQvLyBzdGFydHVwXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cXG4vKioqKioqLyBcXHR2YXIgX19uZXN0ZWRfd2VicGFja19leHBvcnRzX18gPSB7fTtcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfbW9kdWxlc19fW1xcXCIuL2luZGV4LnRzXFxcIl0oMCwgX19uZXN0ZWRfd2VicGFja19leHBvcnRzX18pO1xcbi8qKioqKiovIFxcdFxcbi8qKioqKiovIFxcdHJldHVybiBfX25lc3RlZF93ZWJwYWNrX2V4cG9ydHNfXztcXG4vKioqKioqLyB9KSgpXFxuO1xcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2ltYWdlLWZvbnQvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdGV4dHVyZS1hdGxhcy9idWlsZC9pbmRleC5qcz9cXG59XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcInsvKipcXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5jb25zdCBfdmVjX2NodW5rID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XFxuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XFxuY29uc3QgX3ZlY19pc192ZWMzID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGEgJiYgJ3onIGluIGE7XFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIDIpOyAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMyKCk7ICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcXG4gIGlmICgheCAmJiAheSkge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzIuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzIoLi4uY29tcG9uZW50cy5zbGljZSgwLCAyKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcXG4gKi9cXG52ZWMyLnV4ID0gKCkgPT4gdmVjMigxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqL1xcbnZlYzIudXkgPSAoKSA9PiB2ZWMyKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICsgYlxcbiAqL1xcbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcXG4gKi9cXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMyLm11bFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcXG4gKi9cXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXFxuICovXFxudmVjMi5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuIH0gOiB2ZWMyKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMi5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn07XFxuXFxuLyoqXFxuICogRmFzdCBtZXRob2QgdG8gcm90YXRlIGEgdmVjdG9yIGJ5IC05MCwgOTAgb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcXG4gIHN3aXRjaCAocikge1xcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XFxuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XFxuICAgIGNhc2UgMjogY2FzZSAtMjogcmV0dXJuIHZlYzIoLWEueCwgLWEueSk7XFxuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2NhbGFyIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgw5cgYlxcbiAqL1xcbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xcbiAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMi5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMyTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzIubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCBvciBgeWBcXG4gKiAtIGB1YCBvciBgdmAgKGFsaWFzZXMgZm9yIGB4YCBhbmQgYHlgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAtMik7XFxuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxcbiAqIHZlYzIuc3dpeihhLCAneXgnKTsgICAvLyBbLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxcbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXFxuICogdmVjMi5zd2l6KGEsICd4LngnKTsgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxcbiAqL1xcbnZlYzIuc3dpeiA9IChhLCBzID0gJy4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczJkfSBUaGUgbWFnbml0dWRlIGFuZCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XFxuXFxuLyoqXFxuICogQSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDNkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXFxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAyLCAxKTsgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxcbiAqIGxldCBkID0gdmVjMyhhKTsgICAgICAgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxcbiAqIGxldCBnID0gdmVjMyh2ZWMyKDQsIDUpKTsgICAgLy8gKDQsIDUsIDApXFxuICovXFxuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XFxuICBpZiAoIXggJiYgIXkgJiYgIXopIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMyh4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHgsIHo6IHogPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzMuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzMoLi4uY29tcG9uZW50cy5zbGljZSgwLCAzKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKi9cXG52ZWMzLnV4ID0gKCkgPT4gdmVjMygxLCAwLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqL1xcbnZlYzMudXkgPSAoKSA9PiB2ZWMzKDAsIDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICovXFxudmVjMy51eiA9ICgpID0+IHZlYzMoMCwgMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKyBiXFxuICovXFxudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxcbiAqL1xcbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSwgejogYS56ICogKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzMubXVsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxcbiAqL1xcbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSkgKyBNYXRoLmFicyhhLnopO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXFxuICovXFxudmVjMy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuLCB6OiBhLnogLyBsZW4gfSA6IHZlYzMoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMzLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLno7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcm90YXRpb24gbWF0cml4XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDEpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCxcXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpICsgYS56ICogTWF0aC5zaW4ociksXFxuICBhLnksXFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSAtIGEueSAqIE1hdGguc2luKHIpLFxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcXG4gIGEuelxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcXVhdGVybmlvblxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcXG4gIGlmIChxLmxlbmd0aCAhPT0gNCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XFxuICBpZiAoZCA9PT0gMCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgdXEgPSBbcVswXSAvIGQsIHFbMV0gLyBkLCBxWzJdIC8gZCwgcVszXSAvIGRdO1xcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xcbiAgY29uc3QgcyA9IHVxWzNdO1xcbiAgcmV0dXJuIHZlYzMuYWRkKFxcbiAgICB2ZWMzLmFkZChcXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxcbiAgICAgIHZlYzMubXVsKHYsIHMgKiBzIC0gdmVjMy5kb3QodSwgdSkpXFxuICAgICksXFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge3ZlYzN9IGUgVGhlIEV1bGVyIGFuZ2xlcyB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RhID0gKGEsIGUpID0+IHZlYzMucm90eih2ZWMzLnJvdHkodmVjMy5yb3R4KGEsIGUueCksIGUueSksIGUueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIMOXIGJcXG4gKi9cXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXFxuICBhLnkgKiBiLnogLSBhLnogKiBiLnksXFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcXG4pO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHggPSBhID0+IE1hdGguYXRhbjIoYS56LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzMuY3B5ID0gYSA9PiB2ZWMzKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDNkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knIHwgJ3onfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4LCB5IG9yIHopXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fSR7c30ke2Euen1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgLCBgeWAgb3IgYHpgXFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBaYCwgYFVgLCBgVmAsIGBXYCwgYFJgLCBgR2AsIGBCYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAtMiwgMSk7XFxuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3hZWicpOyAgIC8vIFszLCAyLCAtMV1cXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3kwMXp4Jyk7IC8vIFstMiwgMCwgMSwgMSwgM11cXG4gKi9cXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiBjYXNlICdyJzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiBjYXNlICdSJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnBvbGFyID0gYSA9PiB7XFxuICBsZXQgciA9IHZlYzMubGVuKGEpLFxcbiAgICB0aGV0YSA9IE1hdGguYWNvcyhhLnkgLyByKSxcXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XFxuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzMuZnJvbVBvbGFyID0gKHIsIHRoZXRhLCBwaGkpID0+IHtcXG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguY29zKHBoaSksXFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XFxuXFxuLyoqXFxuICogQWRkIG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcXG4gKi9cXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcXG4gKi9cXG5tYXQuc3ViID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgLSBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XFxuICBsZXQgbiwgYmIsIHJ0O1xcbiAgaWYgKF92ZWNfaXNfdmVjMyhiKSkge1xcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDM7XFxuICAgIHJ0ID0gdmVjMy5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XFxuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMjtcXG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgYmIgPSBiO1xcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcXG4gICAgcnQgPSB2ID0+IHY7XFxuICB9XFxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xcbiAgfVxcbiAgcmV0dXJuIHJ0KHJlc3VsdCk7XFxufVxcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubm9yID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggZnJvbSB3aGljaCB0byBnZXQgdGhlIGFkanVnYXRlXFxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxcbiAqL1xcbm1hdC5hZGogPSBhID0+IHtcXG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcXG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBfdmVjX2NodW5rKGEuZW50cmllcywgYS5uKS5tYXAociA9PiByLmpvaW4obXMpKS5qb2luKG5zKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYzIsIHZlYzMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbWFnZS1mb250Ly4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XFxufVwiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbmNvbnN0IF92ZWNfdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcbmNvbnN0IF92ZWNfY2h1bmsgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5jb25zdCBfdmVjX2RvdCA9IChhLCBiKSA9PiBhLnJlZHVjZSgobiwgdiwgaSkgPT4gbiArIHYgKiBiW2ldLCAwKTtcXG5jb25zdCBfdmVjX2lzX3ZlYzIgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYTtcXG5jb25zdCBfdmVjX2lzX3ZlYzMgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYSAmJiAneicgaW4gYTtcXG5cXG4vKipcXG4gKiBBIDJkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzJcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDJkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyAyZCB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzIoMywgMik7IC8vICgzLCAyKVxcbiAqIGxldCBiID0gdmVjMig0KTsgICAgLy8gKDQsIDQpXFxuICogbGV0IGMgPSB2ZWMyKGEpOyAgICAvLyAoMywgMilcXG4gKiBsZXQgZCA9IHZlYzIoKTsgICAgIC8vICgwLCAwKVxcbiAqL1xcbmNvbnN0IHZlYzIgPSAoeCwgeSkgPT4ge1xcbiAgaWYgKCF4ICYmICF5KSB7XFxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHggfTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMyLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgdmVjdG9yXFxuICovXFxudmVjMi5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMiguLi5jb21wb25lbnRzLnNsaWNlKDAsIDIpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYzIudXggPSAoKSA9PiB2ZWMyKDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjMi51eSA9ICgpID0+IHZlYzIoMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKyBiXFxuICovXFxudmVjMi5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC0gYlxcbiAqL1xcbnZlYzIuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXFxuICovXFxudmVjMi5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzIubXVsXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIuc2NhbGUgPSAoYSwgYikgPT4gdmVjMi5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC8gYlxcbiAqL1xcbnZlYzIuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzIubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjMn0gXmFcXG4gKi9cXG52ZWMyLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYzIubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYzIoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMyLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFuc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3QgPSAoYSwgcikgPT4ge1xcbiAgbGV0IHMgPSBNYXRoLnNpbihyKSxcXG4gICAgYyA9IE1hdGguY29zKHIpO1xcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XFxufTtcXG5cXG4vKipcXG4gKiBGYXN0IG1ldGhvZCB0byByb3RhdGUgYSB2ZWN0b3IgYnkgLTkwLCA5MCBvciAxODAgZGVncmVlc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIDEgZm9yIDkwIGRlZ3JlZXMgKGN3KSwgLTEgZm9yIC05MCBkZWdyZWVzIChjY3cpLCAyIG9yIC0yIGZvciAxODAgZGVncmVlc1xcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMyLnJvdGYgPSAoYSwgcikgPT4ge1xcbiAgc3dpdGNoIChyKSB7XFxuICAgIGNhc2UgMTogcmV0dXJuIHZlYzIoYS55LCAtYS54KTtcXG4gICAgY2FzZSAtMTogcmV0dXJuIHZlYzIoLWEueSwgYS54KTtcXG4gICAgY2FzZSAyOiBjYXNlIC0yOiByZXR1cm4gdmVjMigtYS54LCAtYS55KTtcXG4gICAgZGVmYXVsdDogcmV0dXJuIGE7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsYXIgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDDlyBiXFxuICovXFxudmVjMi5jcm9zcyA9IChhLCBiKSA9PiB7XFxuICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMyLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMi5yYWQgPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLngpO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjMn0gQSBjb3B5IG9mIHZlY3RvciBhXFxuICovXFxudmVjMi5jcHkgPSBhID0+IHZlYzIoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgMmQgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlYzJNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXFxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMk1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxudmVjMi5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMyLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgIG9yIGB5YFxcbiAqIC0gYHVgIG9yIGB2YCAoYWxpYXNlcyBmb3IgYHhgIGFuZCBgeWAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGBYYCwgYFlgLCBgVWAsIGBWYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIC0yKTtcXG4gKiB2ZWMyLnN3aXooYSwgJ3gnKTsgICAgLy8gWzNdXFxuICogdmVjMi5zd2l6KGEsICd5eCcpOyAgIC8vIFstMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3hZJyk7ICAgLy8gWzMsIDJdXFxuICogdmVjMi5zd2l6KGEsICdZeScpOyAgIC8vIFsyLCAtMl1cXG4gKiB2ZWMyLnN3aXooYSwgJ3gueCcpOyAgLy8gWzMsIC0yLCAzXVxcbiAqIHZlYzIuc3dpeihhLCAneTAxeCcpOyAvLyBbLTIsIDAsIDEsIDNdXFxuICovXFxudmVjMi5zd2l6ID0gKGEsIHMgPSAnLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcXG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogcmVzdWx0LnB1c2goLWEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcXG4gICAgICBjYXNlICcuJzogcmVzdWx0LnB1c2goW2EueCwgYS55XVtpXSA/PyAwKTsgYnJlYWs7XFxuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDJkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMyZFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzMmR9IFRoZSBtYWduaXR1ZGUgYW5kIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMyLnBvbGFyID0gYSA9PiAoeyByOiB2ZWMyLmxlbihhKSwgdGhldGE6IE1hdGguYXRhbjIoYS55LCBhLngpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcXG4gKi9cXG52ZWMyLmZyb21Qb2xhciA9IChyLCB0aGV0YSkgPT4gdmVjMihyICogTWF0aC5jb3ModGhldGEpLCByICogTWF0aC5zaW4odGhldGEpKTtcXG5cXG4vKipcXG4gKiBBIDNkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzNcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHogVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgM2QgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjM3x2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciB0aGUgeiBjb21wb25lbnQgaWYgeCBpcyBhIHZlYzJcXG4gKiBAcGFyYW0ge251bWJlcn0gW3pdIFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSBuZXcgM2QgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMzKDMsIDIsIDEpOyAgICAgICAvLyAoMywgMiwgMSlcXG4gKiBsZXQgYiA9IHZlYzMoNCwgNSk7ICAgICAgICAgIC8vICg0LCA1LCAwKVxcbiAqIGxldCBjID0gdmVjMyg2KTsgICAgICAgICAgICAgLy8gKDYsIDYsIDYpXFxuICogbGV0IGQgPSB2ZWMzKGEpOyAgICAgICAgICAgICAvLyAoMywgMiwgMSlcXG4gKiBsZXQgZSA9IHZlYzMoKTsgICAgICAgICAgICAgIC8vICgwLCAwLCAwKVxcbiAqIGxldCBmID0gdmVjMyh2ZWMyKDEsIDIpLCAzKTsgLy8gKDEsIDIsIDMpXFxuICogbGV0IGcgPSB2ZWMzKHZlYzIoNCwgNSkpOyAgICAvLyAoNCwgNSwgMClcXG4gKi9cXG5jb25zdCB2ZWMzID0gKHgsIHksIHopID0+IHtcXG4gIGlmICgheCAmJiAheSAmJiAheikge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB6OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMzKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeC56IHx8IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB5IHx8IDAgfTtcXG4gIH1cXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCwgejogeiA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnksIGEuel07XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSBuZXcgdmVjdG9yXFxuICovXFxudmVjMy5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMyguLi5jb21wb25lbnRzLnNsaWNlKDAsIDMpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxcbiAqL1xcbnZlYzMudXggPSAoKSA9PiB2ZWMzKDEsIDAsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXFxuICovXFxudmVjMy51eSA9ICgpID0+IHZlYzMoMCwgMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMCwgMSlcXG4gKi9cXG52ZWMzLnV6ID0gKCkgPT4gdmVjMygwLCAwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSArIGJcXG4gKi9cXG52ZWMzLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpLCB6OiBhLnogKyAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLSBiXFxuICovXFxudmVjMy5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSwgejogYS56IC0gKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAqIGJcXG4gKi9cXG52ZWMzLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpLCB6OiBhLnogKiAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMy5tdWxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5zY2FsZSA9IChhLCBiKSA9PiB2ZWMzLm11bChhLCBiKTtcXG5cXG4vKipcXG4gKiBEaXZpZGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLyBiXFxuICovXFxudmVjMy5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSwgejogYS56IC8gKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkgKyBhLnogKiBhLnopO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KSArIE1hdGguYWJzKGEueik7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjM30gXmFcXG4gKi9cXG52ZWMzLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYzMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4sIHo6IGEueiAvIGxlbiB9IDogdmVjMygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYzMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSByb3RhdGlvbiBtYXRyaXhcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge21hdH0gbSBUaGUgcm90YXRpb24gbWF0cml4XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90ID0gKGEsIG0pID0+IHZlYzMoXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMSkpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAyKSksIGEpLFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDMpKSwgYSlcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB4IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eCA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54LFxcbiAgYS55ICogTWF0aC5jb3MocikgLSBhLnogKiBNYXRoLnNpbihyKSxcXG4gIGEueSAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3MocilcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB5IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eSA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54ICogTWF0aC5jb3MocikgKyBhLnogKiBNYXRoLnNpbihyKSxcXG4gIGEueSxcXG4gIC1hLnggKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeiBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHogPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpIC0gYS55ICogTWF0aC5zaW4ociksXFxuICBhLnggKiBNYXRoLnNpbihyKSArIGEueSAqIE1hdGguY29zKHIpLFxcbiAgYS56XFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSBxdWF0ZXJuaW9uXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxIFRoZSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHEgPSAodiwgcSkgPT4ge1xcbiAgaWYgKHEubGVuZ3RoICE9PSA0KSB7XFxuICAgIHJldHVybiB2ZWMzKCk7XFxuICB9XFxuXFxuICBjb25zdCBkID0gTWF0aC5zcXJ0KHFbMF0gKiBxWzBdICsgcVsxXSAqIHFbMV0gKyBxWzJdICogcVsyXSArIHFbM10gKiBxWzNdKTtcXG4gIGlmIChkID09PSAwKSB7XFxuICAgIHJldHVybiB2ZWMzKCk7XFxuICB9XFxuXFxuICBjb25zdCB1cSA9IFtxWzBdIC8gZCwgcVsxXSAvIGQsIHFbMl0gLyBkLCBxWzNdIC8gZF07XFxuICBjb25zdCB1ID0gdmVjMyguLi51cS5zbGljZSgwLCAzKSk7XFxuICBjb25zdCBzID0gdXFbM107XFxuICByZXR1cm4gdmVjMy5hZGQoXFxuICAgIHZlYzMuYWRkKFxcbiAgICAgIHZlYzMubXVsKHUsIDIgKiB2ZWMzLmRvdCh1LCB2KSksXFxuICAgICAgdmVjMy5tdWwodiwgcyAqIHMgLSB2ZWMzLmRvdCh1LCB1KSlcXG4gICAgKSxcXG4gICAgdmVjMy5tdWwodmVjMy5jcm9zcyh1LCB2KSwgMiAqIHMpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIEV1bGVyIGFuZ2xlc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7dmVjM30gZSBUaGUgRXVsZXIgYW5nbGVzIHRvIHJvdGF0ZSBieVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdGEgPSAoYSwgZSkgPT4gdmVjMy5yb3R6KHZlYzMucm90eSh2ZWMzLnJvdHgoYSwgZS54KSwgZS55KSwgZS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgw5cgYlxcbiAqL1xcbnZlYzMuY3Jvc3MgPSAoYSwgYikgPT4gdmVjMyhcXG4gIGEueSAqIGIueiAtIGEueiAqIGIueSxcXG4gIGEueiAqIGIueCAtIGEueCAqIGIueixcXG4gIGEueCAqIGIueSAtIGEueSAqIGIueFxcbik7XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMzLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEueiA9PT0gYi56O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeCA9IGEgPT4gTWF0aC5hdGFuMihhLnosIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB5IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR5ID0gYSA9PiBNYXRoLmF0YW4yKGEueCwgYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHogPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLnopO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjM30gQSBjb3B5IG9mIHZlY3RvciBhXFxuICovXFxudmVjMy5jcHkgPSBhID0+IHZlYzMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgM2QgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlYzNNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXFxuICogQHBhcmFtIHsneCcgfCAneScgfCAneid9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHgsIHkgb3IgeilcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM01hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxudmVjMy5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpLCB6OiBmKGEueiwgJ3onKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9JHtzfSR7YS56fWA7XFxuXFxuLyoqXFxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcXG4gKlxcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XFxuICogLSBgeGAsIGB5YCBvciBgemBcXG4gKiAtIGB1YCwgYHZgIG9yIGB3YCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYHJgLCBgZ2Agb3IgYGJgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFpgLCBgVWAsIGBWYCwgYFdgLCBgUmAsIGBHYCwgYEJgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcXG4gKiAtIGAwYCBvciBgMWAgKHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkKVxcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcXG4gKlxcbiAqIEFueSBvdGhlciBjaGFyYWN0ZXJzIHdpbGwgZGVmYXVsdCB0byAwXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMzKDMsIC0yLCAxKTtcXG4gKiB2ZWMzLnN3aXooYSwgJ3gnKTsgICAgIC8vIFszXVxcbiAqIHZlYzMuc3dpeihhLCAnenl4Jyk7ICAgLy8gWzEsIC0yLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneFlaJyk7ICAgLy8gWzMsIDIsIC0xXVxcbiAqIHZlYzMuc3dpeihhLCAnWnp4Jyk7ICAgLy8gWy0xLCAxLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneC54Jyk7ICAgLy8gWzMsIC0yLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneTAxengnKTsgLy8gWy0yLCAwLCAxLCAxLCAzXVxcbiAqL1xcbnZlYzMuc3dpeiA9IChhLCBzID0gJy4uLicpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgcy5zcGxpdCgnJykuZm9yRWFjaCgoYywgaSkgPT4ge1xcbiAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IGNhc2UgJ3InOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcXG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IGNhc2UgJ2cnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICd6JzogY2FzZSAndyc6IGNhc2UgJ2InOiByZXN1bHQucHVzaChhLnopOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IGNhc2UgJ1InOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiBjYXNlICdHJzogcmVzdWx0LnB1c2goLWEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1onOiBjYXNlICdXJzogY2FzZSAnQic6IHJlc3VsdC5wdXNoKC1hLnopOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueSwgYS56XVtpXSA/PyAwKTsgYnJlYWs7XFxuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDNkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMzZFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBoaSBUaGUgcGFuIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczNkfSBUaGUgbWFnbml0dWRlLCB0aWx0IGFuZCBwYW4gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMucG9sYXIgPSBhID0+IHtcXG4gIGxldCByID0gdmVjMy5sZW4oYSksXFxuICAgIHRoZXRhID0gTWF0aC5hY29zKGEueSAvIHIpLFxcbiAgICBwaGkgPSBNYXRoLmF0YW4yKGEueiwgYS54KTtcXG4gIHJldHVybiB7IHIsIHRoZXRhLCBwaGkgfTtcXG59O1xcblxcbi8qKlxcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHBoaSBUaGUgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMy5mcm9tUG9sYXIgPSAociwgdGhldGEsIHBoaSkgPT4ge1xcbiAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XFxuICByZXR1cm4gdmVjMyhcXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5jb3MocGhpKSxcXG4gICAgciAqIE1hdGguY29zKHRoZXRhKSxcXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5zaW4ocGhpKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIEEgbWF0cml4XFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXhcXG4gKiBAcGFyYW0ge251bWJlcn0gW209NF0gVGhlIG51bWJlciBvZiByb3dzXFxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VudHJpZXM9W11dIE1hdHJpeCB2YWx1ZXMgaW4gcmVhZGluZyBvcmRlclxcbiAqIEByZXR1cm4ge21hdH0gQSBuZXcgbWF0cml4XFxuICovXFxuY29uc3QgbWF0ID0gKG0gPSA0LCBuID0gNCwgZW50cmllcyA9IFtdKSA9PiAoe1xcbiAgbSwgbixcXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcXG59KTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxcbiAqL1xcbm1hdC5pZGVudGl0eSA9IG4gPT4gbWF0KG4sIG4sIEFycmF5KG4gKiBuKS5maWxsKDApLm1hcCgodiwgaSkgPT4gKyhNYXRoLmZsb29yKGkgLyBuKSA9PT0gaSAlIG4pKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGVudHJ5IGZyb20gYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuZ2V0ID0gKGEsIGksIGopID0+IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl07XFxuXFxuLyoqXFxuICogU2V0IGFuIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5zZXQgPSAoYSwgaSwgaiwgdikgPT4geyBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dID0gdjsgfTtcXG5cXG4vKipcXG4gKiBHZXQgYSByb3cgZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIHJvdyBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSb3cgbSBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LnJvdyA9IChhLCBtKSA9PiB7XFxuICBjb25zdCBzID0gKG0gLSAxKSAqIGEubjtcXG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjb2x1bW4gZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDb2x1bW4gbiBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LmNvbCA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cmljZXMgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsID0gKGEsIGIpID0+IHtcXG4gIGlmIChhLm4gIT09IGIubSkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IG1hdChhLm0sIGIubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQocmVzdWx0LCBpLCBqLCBfdmVjX2RvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBhIG1hdHJpeCBieSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHt2ZWMyfHZlYzN8bnVtYmVyW119IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfHZlYzN8bnVtYmVyW118ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggYW5kIHZlY3RvciBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWx2ID0gKGEsIGIpID0+IHtcXG4gIGxldCBuLCBiYiwgcnQ7XFxuICBpZiAoX3ZlY19pc192ZWMzKGIpKSB7XFxuICAgIGJiID0gdmVjMy5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMztcXG4gICAgcnQgPSB2ZWMzLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIGlmIChfdmVjX2lzX3ZlYzIoYikpIHtcXG4gICAgYmIgPSB2ZWMyLmNvbXBvbmVudHMoYik7XFxuICAgIG4gPSAyO1xcbiAgICBydCA9IHZlYzIuZnJvbUNvbXBvbmVudHM7XFxuICB9IGVsc2Uge1xcbiAgICBiYiA9IGI7XFxuICAgIG4gPSBiLmxlbmd0aCA/PyAwO1xcbiAgICBydCA9IHYgPT4gdjtcXG4gIH1cXG4gIGlmIChhLm4gIT09IG4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIHJlc3VsdC5wdXNoKF92ZWNfZG90KG1hdC5yb3coYSwgaSksIGJiKSk7XFxuICB9XFxuICByZXR1cm4gcnQocmVzdWx0KTtcXG59XFxuXFxuLyoqXFxuICogU2NhbGUgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7bWF0fSBhICogYlxcbiAqL1xcbm1hdC5zY2FsZSA9IChhLCBiKSA9PiBtYXQubWFwKGEsIHYgPT4gdiAqIGIpO1xcblxcbi8qKlxcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gdHJhbnNwb3NlXFxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XFxuICovXFxubWF0LnRyYW5zID0gYSA9PiBtYXQoYS5uLCBhLm0sIF92ZWNfdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubWlub3IgPSAoYSwgaSwgaikgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZW50cmllcyA9IFtdO1xcbiAgZm9yIChsZXQgaWkgPSAxOyBpaSA8PSBhLm07IGlpKyspIHtcXG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XFxuICAgIGZvciAobGV0IGpqID0gMTsgamogPD0gYS5uOyBqaisrKSB7XFxuICAgICAgaWYgKGpqID09PSBqKSB7IGNvbnRpbnVlOyB9XFxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQuZGV0ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoYS5tID09PSAxKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF07XFxuICB9XFxuICBpZiAoYS5tID09PSAyKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF0gKiBhLmVudHJpZXNbM10gLSBhLmVudHJpZXNbMV0gKiBhLmVudHJpZXNbMl07XFxuICB9XFxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcXG4gIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xcbiAgICBzaWduICo9IC0xO1xcbiAgfVxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxcbiAqL1xcbm1hdC5pbnYgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgaWYgKGQgPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XFxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtYXRyaWNlcyBhIGFuZCBiIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xcblxcbi8qKlxcbiAqIENvcHkgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvcHlcXG4gKiBAcmV0dXJuIHttYXR9IEEgY29weSBvZiBtYXRyaXggYVxcbiAqL1xcbm1hdC5jcHkgPSBhID0+IG1hdChhLm0sIGEubiwgWy4uLmEuZW50cmllc10pO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQGNhbGxiYWNrIG1hdHJpeE1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgZW50cnkgaW5kZXhcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIGFycmF5IG9mIG1hdHJpeCBlbnRyaWVzXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXggYW5kIGJ1aWxkIGEgbmV3IG1hdHJpeCBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gTWF0cml4IGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW21zPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciBjb2x1bW5zXFxuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxcXG4nXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3Igcm93c1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxcbiAqL1xcbm1hdC5zdHIgPSAoYSwgbXMgPSAnLCAnLCBucyA9ICdcXFxcbicpID0+IF92ZWNfY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjMiwgdmVjMywgbWF0IH07XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLk1vdXNlQnV0dG9uID0gdm9pZCAwO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxudmFyIE1vdXNlQnV0dG9uO1xcbihmdW5jdGlvbiAoTW91c2VCdXR0b24pIHtcXG4gICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXFxcIkxlZnRcXFwiXSA9IDBdID0gXFxcIkxlZnRcXFwiO1xcbiAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcXFwiTWlkZGxlXFxcIl0gPSAxXSA9IFxcXCJNaWRkbGVcXFwiO1xcbiAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcXFwiUmlnaHRcXFwiXSA9IDJdID0gXFxcIlJpZ2h0XFxcIjtcXG59KShNb3VzZUJ1dHRvbiA9IGV4cG9ydHMuTW91c2VCdXR0b24gfHwgKGV4cG9ydHMuTW91c2VCdXR0b24gPSB7fSkpO1xcbmNsYXNzIElucHV0TWFuYWdlciB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMua2V5Ym9hcmRTdGF0ZSA9IElucHV0TWFuYWdlci5pbml0aWFsS2V5Ym9hcmRTdGF0ZSgpO1xcbiAgICAgICAgdGhpcy5wcmV2aW91c0tleWJvYXJkU3RhdGUgPSBJbnB1dE1hbmFnZXIuaW5pdGlhbEtleWJvYXJkU3RhdGUoKTtcXG4gICAgICAgIHRoaXMubW91c2VTdGF0ZSA9IElucHV0TWFuYWdlci5pbml0aWFsTW91c2VTdGF0ZSgpO1xcbiAgICAgICAgdGhpcy5wcmV2aW91c01vdXNlU3RhdGUgPSBJbnB1dE1hbmFnZXIuaW5pdGlhbE1vdXNlU3RhdGUoKTtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIElucHV0TWFuYWdlci5ERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb3VzZSkge1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuYnV0dG9uc1tlLmJ1dHRvbl0gPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbZS5idXR0b25dID1cXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5idXR0b25zWzBdID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbMF0gPSBmYWxzZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLnBvc2l0aW9uLnggPSBlLm9mZnNldFg7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5wb3NpdGlvbi55ID0gZS5vZmZzZXRZO1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuaG92ZXJlZEVsZW1lbnQgPSBlLnRhcmdldDtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vdXNlV2hlZWwpIHtcXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUud2hlZWwgPSBlLmRlbHRhWSA+IDAgPyAxIDogLTE7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkU3RhdGVbZS5jb2RlXSA9IHRydWU7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTdGF0ZVtlLmNvZGVdID0gZmFsc2U7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBjb250ZXh0IG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gcmlnaHQtY2xpY2tcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudENvbnRleHRNZW51KSB7XFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBpbnB1dCBtYW5hZ2VyIGZvciBtYW5hZ2luZyBtb3VzZSBhbmQga2V5Ym9hcmQgaW5wdXRcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChJbnB1dE1hbmFnZXIuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbWFuYWdlciBhbHJlYWR5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICBJbnB1dE1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgSW5wdXRNYW5hZ2VyKG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmIChJbnB1dE1hbmFnZXIuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbWFuYWdlciBub3QgcHJvcGVybHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBJbnB1dE1hbmFnZXIuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgc3RhdGljIGluaXRpYWxLZXlib2FyZFN0YXRlKCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICB9XFxuICAgIHN0YXRpYyBpbml0aWFsTW91c2VTdGF0ZSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgYnV0dG9uczoge1xcbiAgICAgICAgICAgICAgICBbTW91c2VCdXR0b24uTGVmdF06IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBbTW91c2VCdXR0b24uTWlkZGxlXTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIFtNb3VzZUJ1dHRvbi5SaWdodF06IGZhbHNlLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMyKSgpLFxcbiAgICAgICAgICAgIHdoZWVsOiAwLFxcbiAgICAgICAgICAgIGhvdmVyZWRFbGVtZW50OiBudWxsLFxcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICBzdGF0aWMgY29weUtleWJvYXJkU3RhdGUoc3RhdGUpIHtcXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XFxuICAgIH1cXG4gICAgc3RhdGljIGNvcHlNb3VzZVN0YXRlKHN0YXRlKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGJ1dHRvbnM6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmJ1dHRvbnMpLFxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWNfMS52ZWMyLmNweShzdGF0ZS5wb3NpdGlvbiksXFxuICAgICAgICAgICAgd2hlZWw6IHN0YXRlLndoZWVsLFxcbiAgICAgICAgICAgIGhvdmVyZWRFbGVtZW50OiBzdGF0ZS5ob3ZlcmVkRWxlbWVudCxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGlucHV0IGRldmljZXNcXG4gICAgICovXFxuICAgIHN0YXRpYyB1cGRhdGUoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlID0gdGhpcy5jb3B5S2V5Ym9hcmRTdGF0ZShpbnN0YW5jZS5rZXlib2FyZFN0YXRlKTtcXG4gICAgICAgIGluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZSA9IHRoaXMuY29weU1vdXNlU3RhdGUoaW5zdGFuY2UubW91c2VTdGF0ZSk7XFxuICAgICAgICBpbnN0YW5jZS5tb3VzZVN0YXRlLndoZWVsID0gMDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQgZG93blxcbiAgICAgKi9cXG4gICAgc3RhdGljIGtleURvd24oY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgaXMgZG93blxcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gISFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVjayBpZiBhIGtleSBoYXMgYmVlbiBwcmVzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMga2V5UHJlc3NlZChjb2RlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGtleSB3YXMgcHJlc3NlZFxcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBpbnN0YW5jZS5rZXlib2FyZFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmXFxuICAgICAgICAgICAgICAgICAgICAoIShrIGluIGluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2tdKSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICghIWluc3RhbmNlLmtleWJvYXJkU3RhdGVbY29kZV0gJiYgIWluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZVtjb2RlXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIGEga2V5IGhhcyBiZWVuIHJlbGVhc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMga2V5UmVsZWFzZWQoY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgd2FzIHJlbGVhc2VkXFxuICAgICAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGluc3RhbmNlLmtleWJvYXJkU3RhdGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmICEhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2tdKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdICYmICEhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2NvZGVdKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQgZG93blxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlRG93bihidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIGlzIGRvd25cXG4gICAgICAgIGlmIChidXR0b24gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBpbiBpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnMpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJ1dHRvbiA9ICtiO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gISFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBtb3VzZSBidXR0b24gaGFzIGJlZW4gcHJlc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlUHJlc3NlZChidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIHdhcyBwcmVzc2VkXFxuICAgICAgICBpZiAoYnV0dG9uID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgaW4gaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCdXR0b24gPSArYjtcXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uc1tjdXJyZW50QnV0dG9uXSAmJlxcbiAgICAgICAgICAgICAgICAgICAgKCEoYiBpbiBpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9ucykgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbY3VycmVudEJ1dHRvbl0pKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCEhaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2J1dHRvbl0gJiZcXG4gICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIGEgbW91c2UgYnV0dG9uIGhhcyBiZWVuIHJlbGVhc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VSZWxlYXNlZChidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIHdhcyByZWxlYXNlZFxcbiAgICAgICAgaWYgKGJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBiIGluIGluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9ucykge1xcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QnV0dG9uID0gK2I7XFxuICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dICYmXFxuICAgICAgICAgICAgICAgICAgICAhIWluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSAmJlxcbiAgICAgICAgICAgICEhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyB1cFxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlV2hlZWxVcCgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UubW91c2VTdGF0ZS53aGVlbCA+IDA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VXaGVlbERvd24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUud2hlZWwgPCAwO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gaW4gc2NyZWVuLXNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IG1vdXNlUG9zaXRpb24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUucG9zaXRpb247XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGhvdmVyZWQgZWxlbWVudFxcbiAgICAgKi9cXG4gICAgc3RhdGljIGdldCBob3ZlcmVkRWxlbWVudCgpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gKF9hID0gaW5zdGFuY2UubW91c2VTdGF0ZS5ob3ZlcmVkRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBJbnB1dE1hbmFnZXI7XFxuSW5wdXRNYW5hZ2VyLkRFRkFVTFRfT1BUSU9OUyA9IHtcXG4gICAgZWxlbWVudDogd2luZG93LFxcbiAgICBtb3VzZTogdHJ1ZSxcXG4gICAgbW91c2VXaGVlbDogdHJ1ZSxcXG4gICAga2V5Ym9hcmQ6IHRydWUsXFxuICAgIHByZXZlbnRDb250ZXh0TWVudTogZmFsc2UsXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuU2NlbmUgPSBleHBvcnRzLlNjZW5lVHJhbnNpdGlvblN0YXRlID0gdm9pZCAwO1xcbnZhciBTY2VuZVRyYW5zaXRpb25TdGF0ZTtcXG4oZnVuY3Rpb24gKFNjZW5lVHJhbnNpdGlvblN0YXRlKSB7XFxuICAgIFNjZW5lVHJhbnNpdGlvblN0YXRlW1xcXCJJblxcXCJdID0gXFxcImluXFxcIjtcXG4gICAgU2NlbmVUcmFuc2l0aW9uU3RhdGVbXFxcIk91dFxcXCJdID0gXFxcIm91dFxcXCI7XFxuICAgIFNjZW5lVHJhbnNpdGlvblN0YXRlW1xcXCJOb25lXFxcIl0gPSBcXFwibm9uZVxcXCI7XFxufSkoU2NlbmVUcmFuc2l0aW9uU3RhdGUgPSBleHBvcnRzLlNjZW5lVHJhbnNpdGlvblN0YXRlIHx8IChleHBvcnRzLlNjZW5lVHJhbnNpdGlvblN0YXRlID0ge30pKTtcXG5mdW5jdGlvbiBjbGFtcChhLCBtaW4gPSAwLCBtYXggPSAxKSB7XFxuICAgIHJldHVybiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcXG59XFxuY2xhc3MgU2NlbmVNYW5hZ2VyIHtcXG4gICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgICB0aGlzLnNjZW5lcyA9IFtdO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBzY2VuZSBtYW5hZ2VyIGZvciBtYW5hZ2luZyBnYW1lIHNjZW5lc1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGluaXRpYWxpc2UoKSB7XFxuICAgICAgICBpZiAoU2NlbmVNYW5hZ2VyLmluc3RhbmNlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2VuZU1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgU2NlbmVNYW5hZ2VyLmluc3RhbmNlID0gbmV3IFNjZW5lTWFuYWdlcigpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmICghU2NlbmVNYW5hZ2VyLmluc3RhbmNlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2VuZU1hbmFnZXIgbm90IHByb3Blcmx5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gU2NlbmVNYW5hZ2VyLmluc3RhbmNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBQdXNoIGEgc2NlbmUgb250byB0aGUgc2NlbmUgc3RhY2sgYW5kIHN0YXJ0IHRyYW5zaXRpb25pbmcgaW5cXG4gICAgICovXFxuICAgIHN0YXRpYyBwdXNoKHNjZW5lLCAuLi5hcmdzKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2Uuc2NlbmVzLnB1c2goc2NlbmUpO1xcbiAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgc2NlbmUgYW5kIHN0YXJ0IHRoZSB0cmFuc2l0aW9uXFxuICAgICAgICBzY2VuZS5pbml0aWFsaXNlKC4uLmFyZ3MpO1xcbiAgICAgICAgc2NlbmUudHJhbnNpdGlvbkluKCk7XFxuICAgICAgICByZXR1cm4gc2NlbmU7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZSBhIHNjZW5lIGZyb20gdGhlIHNjZW5lIHN0YWNrIGFmdGVyIHRyYW5zaXRpb25pbmcgb3V0XFxuICAgICAqL1xcbiAgICBzdGF0aWMgcG9wKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGlmIChpbnN0YW5jZS5zY2VuZXMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aCAtIDE7XFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b3AtbW9zdCBzY2VuZSB0aGF0IGlzbid0IGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nIG91dFxcbiAgICAgICAgICAgIHdoaWxlIChsYXN0ID4gMCAmJlxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zY2VuZXNbbGFzdF0udHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5PdXQpIHtcXG4gICAgICAgICAgICAgICAgbGFzdC0tO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobGFzdCA+PSAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gaW5zdGFuY2Uuc2NlbmVzW2xhc3RdO1xcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0cmFuc2l0aW9uaW5nIG91dFxcbiAgICAgICAgICAgICAgICBzY2VuZS50cmFuc2l0aW9uT3V0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzY2VuZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgYWxsIHNjZW5lIGZyb20gdGhlIHNjZW5lIHN0YWNrXFxuICAgICAqL1xcbiAgICBzdGF0aWMgY2xlYXIoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2Uuc2NlbmVzLmZvckVhY2goc2NlbmUgPT4ge1xcbiAgICAgICAgICAgIGlmIChzY2VuZS50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk91dCkge1xcbiAgICAgICAgICAgICAgICBzY2VuZS50cmFuc2l0aW9uT3V0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFVwZGF0ZSB0aGUgc2NlbmUgbWFuYWdlciBhbmQgdGhlIGN1cnJlbnQgc2NlbmVcXG4gICAgICovXFxuICAgIHN0YXRpYyB1cGRhdGUoZHQsIC4uLmFyZ3MpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdG9wLW1vc3Qgc2NlbmUgdGhhdCBpc24ndCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aDsgaS0tOykge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc2NlbmVzW2ldLnRyYW5zaXRpb25TdGF0ZSAhPT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0KSB7XFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zY2VuZXNbaV0udXBkYXRlKGR0LCAuLi5hcmdzKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc2NlbmUgdHJhbnNpdGlvbnNcXG4gICAgICAgICAgICBpbnN0YW5jZS5zY2VuZXMuZm9yRWFjaChzY2VuZSA9PiB7XFxuICAgICAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVRyYW5zaXRpb24oZHQpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZGlzcG9zZWQgc2NlbmVzXFxuICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzID0gaW5zdGFuY2Uuc2NlbmVzLmZpbHRlcihzY2VuZSA9PiAhc2NlbmUuZGlzcG9zZWQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW5kZXIgc2NlbmVzIG9uIHRoZSBzY3JlZW5cXG4gICAgICovXFxuICAgIHN0YXRpYyBkcmF3KGNvbnRleHQsIC4uLmFyZ3MpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHNjZW5lcyB3ZSBuZWVkIHRvIGRyYXdcXG4gICAgICAgIGNvbnN0IGRyYXdMaXN0ID0gW107XFxuICAgICAgICBmb3IgKGxldCBpID0gaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aDsgaS0tOykge1xcbiAgICAgICAgICAgIGNvbnN0IHNjZW5lID0gaW5zdGFuY2Uuc2NlbmVzW2ldO1xcbiAgICAgICAgICAgIGRyYXdMaXN0LnB1c2goc2NlbmUpO1xcbiAgICAgICAgICAgIC8vIElmIHRyYW5zaXRpb25pbmcsIHRoaXMgc2NlbmUgaXMgYXNzdW1lZCB0byBiZSB0cmFuc3BhcmVudFxcbiAgICAgICAgICAgIC8vICh3ZSBtaWdodCB3YW50IHRvIHNob3cgdGhlIHNjZW5lIHVuZGVybmVhdGggaWYgd2UncmUgZG9pbmcgZS5nLiBhIGZhZGUpXFxuICAgICAgICAgICAgaWYgKCFzY2VuZS50cmFuc3BhcmVudCAmJlxcbiAgICAgICAgICAgICAgICBzY2VuZS50cmFuc2l0aW9uU3RhdGUgPT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmUpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gRHJhdyB0aGUgc2NlbmVzIGluIGJvdHRvbSAtPiB0b3Agb3JkZXJcXG4gICAgICAgIGRyYXdMaXN0LnJldmVyc2UoKS5mb3JFYWNoKHNjZW5lID0+IHtcXG4gICAgICAgICAgICBzY2VuZS5kcmF3KGNvbnRleHQsIC4uLmFyZ3MpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIExldCBhbGwgc2NlbmVzIGtub3cgdGhhdCBhIHJlc2l6ZSBldmVudCBoYXMgb2NjdXJyZWRcXG4gICAgICovXFxuICAgIHN0YXRpYyByZXNpemUod2lkdGgsIGhlaWdodCkge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgaW5zdGFuY2Uuc2NlbmVzKSB7XFxuICAgICAgICAgICAgKF9hID0gc2NlbmUucmVzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzY2VuZSwgd2lkdGgsIGhlaWdodCk7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gU2NlbmVNYW5hZ2VyO1xcbmNsYXNzIFNjZW5lIHtcXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcXG4gICAgICAgICAgICB0cmFuc2l0aW9uVGltZTogMixcXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcXG4gICAgICAgIH07XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmU7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25BbW91bnQgPSAwO1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVGltZSA9IDA7XFxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XFxuICAgICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lID0gYWN0dWFsT3B0aW9ucy50cmFuc2l0aW9uVGltZTtcXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBhY3R1YWxPcHRpb25zLnRyYW5zcGFyZW50O1xcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25lZEluID0gYWN0dWFsT3B0aW9ucy5vblRyYW5zaXRpb25lZEluO1xcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25lZE91dCA9IGFjdHVhbE9wdGlvbnMub25UcmFuc2l0aW9uZWRPdXQ7XFxuICAgIH1cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHRyYW5zaXRpb25JbigpIHtcXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlID0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuSW47XFxuICAgIH1cXG4gICAgdHJhbnNpdGlvbk91dCgpIHtcXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlID0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0O1xcbiAgICB9XFxuICAgIHVwZGF0ZVRyYW5zaXRpb24oZHQpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICBjb25zdCBhbW91bnQgPSBkdCAvIHRoaXMudHJhbnNpdGlvblRpbWU7XFxuICAgICAgICAvLyBUcmFuc2l0aW9uaW5nIGluXFxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uU3RhdGUgPT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLkluKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkFtb3VudCA8IDEpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQW1vdW50ID0gY2xhbXAodGhpcy50cmFuc2l0aW9uQW1vdW50ICsgYW1vdW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlID0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZTtcXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5vblRyYW5zaXRpb25lZEluKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBUcmFuc2l0aW9uaW5nIG91dFxcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5PdXQpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uQW1vdW50ID4gMCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25BbW91bnQgPSBjbGFtcCh0aGlzLnRyYW5zaXRpb25BbW91bnQgLSBhbW91bnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUgPSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lO1xcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcXG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5vblRyYW5zaXRpb25lZE91dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbmV4cG9ydHMuU2NlbmUgPSBTY2VuZTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9zY2VuZS1tYW5hZ2VyLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vKioqKioqLyBcdF9fd2VicGFja19tb2R1bGVzX19bXCIuL2luZGV4LnRzXCJdKDAsIF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiLCIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5jb25zdCBfdmVjX2NodW5rID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBhLnNsaWNlKGkgKiBuLCBpICogbiArIG4pLCBNYXRoLmNlaWwoYS5sZW5ndGggLyBuKSk7XFxuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XFxuY29uc3QgX3ZlY19pc192ZWMzID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGEgJiYgJ3onIGluIGE7XFxuXFxuLyoqXFxuICogQSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIDIpOyAvLyAoMywgMilcXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXFxuICogbGV0IGQgPSB2ZWMyKCk7ICAgICAvLyAoMCwgMClcXG4gKi9cXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcXG4gIGlmICgheCAmJiAheSkge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzIuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzIoLi4uY29tcG9uZW50cy5zbGljZSgwLCAyKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcXG4gKi9cXG52ZWMyLnV4ID0gKCkgPT4gdmVjMigxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqL1xcbnZlYzIudXkgPSAoKSA9PiB2ZWMyKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICsgYlxcbiAqL1xcbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcXG4gKi9cXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMyLm11bFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcXG4gKi9cXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXFxuICovXFxudmVjMi5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuIH0gOiB2ZWMyKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMi5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ID0gKGEsIHIpID0+IHtcXG4gIGxldCBzID0gTWF0aC5zaW4ociksXFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcXG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xcbn07XFxuXFxuLyoqXFxuICogRmFzdCBtZXRob2QgdG8gcm90YXRlIGEgdmVjdG9yIGJ5IC05MCwgOTAgb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcXG4gIHN3aXRjaCAocikge1xcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XFxuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XFxuICAgIGNhc2UgMjogY2FzZSAtMjogcmV0dXJuIHZlYzIoLWEueCwgLWEueSk7XFxuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU2NhbGFyIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEgw5cgYlxcbiAqL1xcbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xcbiAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMi5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMyTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzIubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCBvciBgeWBcXG4gKiAtIGB1YCBvciBgdmAgKGFsaWFzZXMgZm9yIGB4YCBhbmQgYHlgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAtMik7XFxuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxcbiAqIHZlYzIuc3dpeihhLCAneXgnKTsgICAvLyBbLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxcbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXFxuICogdmVjMi5zd2l6KGEsICd4LngnKTsgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxcbiAqL1xcbnZlYzIuc3dpeiA9IChhLCBzID0gJy4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAyZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczJkfSBUaGUgbWFnbml0dWRlIGFuZCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XFxuXFxuLyoqXFxuICogQSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDNkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXFxuICogQHBhcmFtIHtudW1iZXJ9IFt6XSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAyLCAxKTsgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxcbiAqIGxldCBkID0gdmVjMyhhKTsgICAgICAgICAgICAgLy8gKDMsIDIsIDEpXFxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxcbiAqIGxldCBnID0gdmVjMyh2ZWMyKDQsIDUpKTsgICAgLy8gKDQsIDUsIDApXFxuICovXFxuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XFxuICBpZiAoIXggJiYgIXkgJiYgIXopIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMyh4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMyKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHgsIHo6IHogPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbXBvbmVudHMgVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxcbiAqL1xcbnZlYzMuZnJvbUNvbXBvbmVudHMgPSBjb21wb25lbnRzID0+IHZlYzMoLi4uY29tcG9uZW50cy5zbGljZSgwLCAzKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKi9cXG52ZWMzLnV4ID0gKCkgPT4gdmVjMygxLCAwLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqL1xcbnZlYzMudXkgPSAoKSA9PiB2ZWMzKDAsIDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICovXFxudmVjMy51eiA9ICgpID0+IHZlYzMoMCwgMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKyBiXFxuICovXFxudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxcbiAqL1xcbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSwgejogYS56ICogKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzMubXVsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxcbiAqL1xcbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSkgKyBNYXRoLmFicyhhLnopO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXFxuICovXFxudmVjMy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuLCB6OiBhLnogLyBsZW4gfSA6IHZlYzMoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMzLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLno7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcm90YXRpb24gbWF0cml4XFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDEpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCxcXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpICsgYS56ICogTWF0aC5zaW4ociksXFxuICBhLnksXFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSAtIGEueSAqIE1hdGguc2luKHIpLFxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcXG4gIGEuelxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIGEgcXVhdGVybmlvblxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcXG4gIGlmIChxLmxlbmd0aCAhPT0gNCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XFxuICBpZiAoZCA9PT0gMCkge1xcbiAgICByZXR1cm4gdmVjMygpO1xcbiAgfVxcblxcbiAgY29uc3QgdXEgPSBbcVswXSAvIGQsIHFbMV0gLyBkLCBxWzJdIC8gZCwgcVszXSAvIGRdO1xcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xcbiAgY29uc3QgcyA9IHVxWzNdO1xcbiAgcmV0dXJuIHZlYzMuYWRkKFxcbiAgICB2ZWMzLmFkZChcXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxcbiAgICAgIHZlYzMubXVsKHYsIHMgKiBzIC0gdmVjMy5kb3QodSwgdSkpXFxuICAgICksXFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge3ZlYzN9IGUgVGhlIEV1bGVyIGFuZ2xlcyB0byByb3RhdGUgYnlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3RhID0gKGEsIGUpID0+IHZlYzMucm90eih2ZWMzLnJvdHkodmVjMy5yb3R4KGEsIGUueCksIGUueSksIGUueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIMOXIGJcXG4gKi9cXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXFxuICBhLnkgKiBiLnogLSBhLnogKiBiLnksXFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcXG4pO1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHggPSBhID0+IE1hdGguYXRhbjIoYS56LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeSBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxcbiAqL1xcbnZlYzMuY3B5ID0gYSA9PiB2ZWMzKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDNkIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxcbiAqIEBwYXJhbSB7J3gnIHwgJ3knIHwgJ3onfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4LCB5IG9yIHopXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fSR7c30ke2Euen1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgLCBgeWAgb3IgYHpgXFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBaYCwgYFVgLCBgVmAsIGBXYCwgYFJgLCBgR2AsIGBCYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uLiddIFRoZSBzd2l6emxlIHN0cmluZ1xcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXFxuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMygzLCAtMiwgMSk7XFxuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3hZWicpOyAgIC8vIFszLCAyLCAtMV1cXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cXG4gKiB2ZWMzLnN3aXooYSwgJ3kwMXp4Jyk7IC8vIFstMiwgMCwgMSwgMSwgM11cXG4gKi9cXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiBjYXNlICdyJzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiBjYXNlICdSJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcXG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnBvbGFyID0gYSA9PiB7XFxuICBsZXQgciA9IHZlYzMubGVuKGEpLFxcbiAgICB0aGV0YSA9IE1hdGguYWNvcyhhLnkgLyByKSxcXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XFxuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzMuZnJvbVBvbGFyID0gKHIsIHRoZXRhLCBwaGkpID0+IHtcXG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xcbiAgcmV0dXJuIHZlYzMoXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguY29zKHBoaSksXFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBBIG1hdHJpeFxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgbWF0cml4XFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbnRyaWVzPVtdXSBNYXRyaXggdmFsdWVzIGluIHJlYWRpbmcgb3JkZXJcXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxcbiAqL1xcbmNvbnN0IG1hdCA9IChtID0gNCwgbiA9IDQsIGVudHJpZXMgPSBbXSkgPT4gKHtcXG4gIG0sIG4sXFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXFxufSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcXG4gKi9cXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXFxuICovXFxubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xcblxcbi8qKlxcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XFxuXFxuLyoqXFxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtIFRoZSByb3cgb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5yb3cgPSAoYSwgbSkgPT4ge1xcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XFxuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY29sdW1uIGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQ29sdW1uIG4gZnJvbSBtYXRyaXggYVxcbiAqL1xcbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XFxuXFxuLyoqXFxuICogQWRkIG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcXG4gKi9cXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcXG4gKi9cXG5tYXQuc3ViID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgLSBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpY2VzIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bCA9IChhLCBiKSA9PiB7XFxuICBpZiAoYS5uICE9PSBiLm0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYi5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XFxuICBsZXQgbiwgYmIsIHJ0O1xcbiAgaWYgKF92ZWNfaXNfdmVjMyhiKSkge1xcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDM7XFxuICAgIHJ0ID0gdmVjMy5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XFxuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMjtcXG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgYmIgPSBiO1xcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcXG4gICAgcnQgPSB2ID0+IHY7XFxuICB9XFxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xcbiAgfVxcbiAgcmV0dXJuIHJ0KHJlc3VsdCk7XFxufVxcblxcbi8qKlxcbiAqIFNjYWxlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcXG4gKi9cXG5tYXQuc2NhbGUgPSAoYSwgYikgPT4gbWF0Lm1hcChhLCB2ID0+IHYgKiBiKTtcXG5cXG4vKipcXG4gKiBUcmFuc3Bvc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxcbiAqL1xcbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcXG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XFxuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxcbiAgICBmb3IgKGxldCBqaiA9IDE7IGpqIDw9IGEubjsgamorKykge1xcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxcbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubm9yID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggZnJvbSB3aGljaCB0byBnZXQgdGhlIGFkanVnYXRlXFxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxcbiAqL1xcbm1hdC5hZGogPSBhID0+IHtcXG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcXG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcXG4gKi9cXG5tYXQuaW52ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbWF0cmljZXMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbWF0cmljZXMgYSBhbmQgYiBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb3B5XFxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcXG4gKi9cXG5tYXQuY3B5ID0gYSA9PiBtYXQoYS5tLCBhLm4sIFsuLi5hLmVudHJpZXNdKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeFxcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGVudHJ5IGluZGV4XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxcbiAqL1xcblxcbi8qKlxcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4IGFuZCBidWlsZCBhIG5ldyBtYXRyaXggZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IE1hdHJpeCBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcXG4gKi9cXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxcXG4nKSA9PiBfdmVjX2NodW5rKGEuZW50cmllcywgYS5uKS5tYXAociA9PiByLmpvaW4obXMpKS5qb2luKG5zKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYzIsIHZlYzMsIG1hdCB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yID0gZXhwb3J0cy5TcHJpdGUgPSBleHBvcnRzLmlzU3ByaXRlT3B0aW9uc0RhdGEgPSBleHBvcnRzLlNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUgPSB2b2lkIDA7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG52YXIgU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZTtcXG4oZnVuY3Rpb24gKFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUpIHtcXG4gICAgLyoqXFxuICAgICAqIExvb3AgdGhpcyBhbmltYXRpb24gaW5kZWZpbml0ZWx5XFxuICAgICAqL1xcbiAgICBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlW1xcXCJSZXBlYXRcXFwiXSA9IFxcXCJyZXBlYXRcXFwiO1xcbiAgICAvKipcXG4gICAgICogUGxheSBvbmNlIGFuZCB0aGVuIHN0b3Agb24gdGhlIGxhc3QgZnJhbWVcXG4gICAgICovXFxuICAgIFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGVbXFxcIlBsYXlPbmNlQW5kU3RvcFxcXCJdID0gXFxcInBsYXktb25jZS1hbmQtc3RvcFxcXCI7XFxuICAgIC8qKlxcbiAgICAgKiBQbGF5IG9uY2UgYW5kIHRoZW4gcmVzZXQgYmFjayB0byB0aGUgZmlyc3QgZnJhbWVcXG4gICAgICovXFxuICAgIFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGVbXFxcIlBsYXlPbmNlQW5kUmVzZXRcXFwiXSA9IFxcXCJwbGF5LW9uY2UtYW5kLXJlc2V0XFxcIjtcXG59KShTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlID0gZXhwb3J0cy5TcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlIHx8IChleHBvcnRzLlNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUgPSB7fSkpO1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gVFlQRSBHVUFSRFNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbmZ1bmN0aW9uIGlzVmVjMih2YWx1ZSkge1xcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXFxuICAgICAgICAneCcgaW4gdmFsdWUgJiZcXG4gICAgICAgICd5JyBpbiB2YWx1ZSAmJlxcbiAgICAgICAgdHlwZW9mIHZhbHVlLnggPT09ICdudW1iZXInICYmXFxuICAgICAgICB0eXBlb2YgdmFsdWUueSA9PT0gJ251bWJlcicpO1xcbn1cXG5mdW5jdGlvbiBpc1Nwcml0ZUFuaW1hdGlvbk9wdGlvbnNEYXRhKHZhbHVlKSB7XFxuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICghKCduYW1lJyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLm5hbWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdmcmFtZUNvdW50JyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuZnJhbWVDb3VudCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2ZyYW1lUmF0ZScgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmZyYW1lUmF0ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ21vZGUnIGluIHZhbHVlICYmXFxuICAgICAgICAhT2JqZWN0LnZhbHVlcyhTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlKS5pbmNsdWRlcyh2YWx1ZS5tb2RlKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICgnaW1hZ2VOYW1lcycgaW4gdmFsdWUpIHtcXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZS5pbWFnZU5hbWVzKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghdmFsdWUuaW1hZ2VOYW1lcy5ldmVyeSgoaW1hZ2VOYW1lKSA9PiB0eXBlb2YgaW1hZ2VOYW1lID09PSAnc3RyaW5nJykpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCdhdHRhY2htZW50UG9pbnRLZXlmcmFtZXMnIGluIHZhbHVlICYmXFxuICAgICAgICB0eXBlb2YgdmFsdWUuYXR0YWNobWVudFBvaW50S2V5ZnJhbWVzID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgdmFsdWUuYXR0YWNobWVudFBvaW50S2V5ZnJhbWVzICE9PSBudWxsKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IFthdHRhY2htZW50UG9pbnROYW1lLCBrZXlmcmFtZXNdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcykpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF0dGFjaG1lbnRQb2ludE5hbWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleWZyYW1lcykpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoIWtleWZyYW1lcy5ldmVyeShpc1Nwcml0ZUF0dGFjaG1lbnRQb2ludEtleWZyYW1lKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbn1cXG5mdW5jdGlvbiBpc1Nwcml0ZUF0dGFjaG1lbnRQb2ludE9wdGlvbnModmFsdWUpIHtcXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCEoJ25hbWUnIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUubmFtZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgnb2Zmc2V0JyBpbiB2YWx1ZSkgfHwgIWlzVmVjMih2YWx1ZS5vZmZzZXQpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxufVxcbmZ1bmN0aW9uIGlzU3ByaXRlQXR0YWNobWVudFBvaW50S2V5ZnJhbWUodmFsdWUpIHtcXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCEoJ2ZyYW1lJyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZyYW1lICE9PSAnbnVtYmVyJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICghKCdvZmZzZXQnIGluIHZhbHVlKSB8fCAhaXNWZWMyKHZhbHVlLm9mZnNldCkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG59XFxuZnVuY3Rpb24gaXNTcHJpdGVPcHRpb25zRGF0YSh2YWx1ZSkge1xcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ3Bvc2l0aW9uJyBpbiB2YWx1ZSAmJiAhaXNWZWMyKHZhbHVlLnBvc2l0aW9uKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICgnc2l6ZScgaW4gdmFsdWUgJiYgIWlzVmVjMih2YWx1ZS5zaXplKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICgnb3JpZ2luJyBpbiB2YWx1ZSAmJiAhaXNWZWMyKHZhbHVlLm9yaWdpbikpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ3NjYWxlJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc2NhbGUgIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdyb3RhdGlvbicgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnJvdGF0aW9uICE9PSAnbnVtYmVyJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICgnZGlyZWN0aW9ucycgaW4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUuZGlyZWN0aW9ucykpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2RlZmF1bHREaXJlY3Rpb24nIGluIHZhbHVlICYmXFxuICAgICAgICB0eXBlb2YgdmFsdWUuZGVmYXVsdERpcmVjdGlvbiAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2ltYWdlTmFtZScgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmltYWdlTmFtZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ2FuaW1hdGlvbnMnIGluIHZhbHVlKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLmFuaW1hdGlvbnMgIT09ICdvYmplY3QnIHx8IHZhbHVlLmFuaW1hdGlvbnMgPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGNvbnN0IFthbmltYXRpb25OYW1lLCBhbmltYXRpb25EaXJlY3Rpb25zXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZS5hbmltYXRpb25zKSkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5pbWF0aW9uTmFtZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFuaW1hdGlvbkRpcmVjdGlvbnMgIT09ICdvYmplY3QnIHx8XFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRpcmVjdGlvbnMgPT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtkaXJlY3Rpb25OYW1lLCBhbmltYXRpb25PcHRpb25zXSBvZiBPYmplY3QuZW50cmllcyhhbmltYXRpb25EaXJlY3Rpb25zKSkge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRpcmVjdGlvbk5hbWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Nwcml0ZUFuaW1hdGlvbk9wdGlvbnNEYXRhKGFuaW1hdGlvbk9wdGlvbnMpKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCdkZWZhdWx0QW5pbWF0aW9uJyBpbiB2YWx1ZSAmJlxcbiAgICAgICAgdHlwZW9mIHZhbHVlLmRlZmF1bHRBbmltYXRpb24gIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdhdHRhY2htZW50UG9pbnRzJyBpbiB2YWx1ZSkge1xcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlLmF0dGFjaG1lbnRQb2ludHMpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF2YWx1ZS5hdHRhY2htZW50UG9pbnRzLmV2ZXJ5KGlzU3ByaXRlQXR0YWNobWVudFBvaW50T3B0aW9ucykpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxufVxcbmV4cG9ydHMuaXNTcHJpdGVPcHRpb25zRGF0YSA9IGlzU3ByaXRlT3B0aW9uc0RhdGE7XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBTUFJJVEUgQ0xBU1NcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbmNsYXNzIFNwcml0ZSB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKCk7XFxuICAgICAgICB0aGlzLnNpemUgPSAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgIHRoaXMub3JpZ2luID0gKDAsIHZlY18xLnZlYzIpKCk7XFxuICAgICAgICB0aGlzLnNjYWxlID0gMTtcXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucyA9IG51bGw7XFxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSA9IG51bGw7XFxuICAgICAgICB0aGlzLmN1cnJlbnRJbWFnZSA9IG51bGw7XFxuICAgICAgICB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzID0gbnVsbDtcXG4gICAgICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBTcHJpdGUuREVGQVVMVF9PUFRJT05TLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgICAgICBmb3IgKGNvbnN0IGFuaW1hdGlvbiBvZiBPYmplY3Qua2V5cyhhY3R1YWxPcHRpb25zLmFuaW1hdGlvbnMpKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rpb24gb2YgT2JqZWN0LmtleXMoYWN0dWFsT3B0aW9ucy5hbmltYXRpb25zW2FuaW1hdGlvbl0pKSB7XFxuICAgICAgICAgICAgICAgIGFjdHVhbE9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dW2RpcmVjdGlvbl0gPSBPYmplY3QuYXNzaWduKHt9LCBTcHJpdGUuREVGQVVMVF9BTklNQVRJT05fT1BUSU9OUywgYWN0dWFsT3B0aW9ucy5hbmltYXRpb25zW2FuaW1hdGlvbl1bZGlyZWN0aW9uXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFhY3R1YWxPcHRpb25zLmRlYnVnIHx8IGFjdHVhbE9wdGlvbnMuZGVidWcgPT09IHRydWUpIHtcXG4gICAgICAgICAgICBhY3R1YWxPcHRpb25zLmRlYnVnID0ge1xcbiAgICAgICAgICAgICAgICBzaG93U3ByaXRlVHJhbnNmb3JtczogISFhY3R1YWxPcHRpb25zLmRlYnVnLFxcbiAgICAgICAgICAgICAgICBzaG93U3ByaXRlQm91bmRpbmdCb3g6ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICAgICAgc2hvd0F0dGFjaG1lbnRQb2ludHM6ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYWN0dWFsT3B0aW9ucztcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9zaXRpb24pIHtcXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdmVjXzEudmVjMi5jcHkodGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSkge1xcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHZlY18xLnZlYzIuY3B5KHRoaXMub3B0aW9ucy5zaXplKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIHNpemUgb2YgdGhlIGJhc2UgaW1hZ2UgaWYgb25lIGV4aXN0c1xcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gKDAsIHZlY18xLnZlYzIpKHRoaXMub3B0aW9ucy5pbWFnZS53aWR0aCwgdGhpcy5vcHRpb25zLmltYWdlLmhlaWdodCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHNpemUgb2YgdGhlIGltYWdlIGluIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZmlyc3RcXG4gICAgICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGRpcmVjdGlvbiBvZiB0aGUgZGVmYXVsdCBhbmltYXRpb24gaWYgb25lIGV4aXN0c1xcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0QW5pbWF0aW9uRGlyZWN0aW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdGhpcy5vcHRpb25zLmRlZmF1bHRBbmltYXRpb25dKVswXTtcXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRBbmltYXRpb25EaXJlY3Rpb25zICYmXFxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gZGVmYXVsdEFuaW1hdGlvbkRpcmVjdGlvbnMuaW1hZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9ICgwLCB2ZWNfMS52ZWMyKShkZWZhdWx0QW5pbWF0aW9uRGlyZWN0aW9ucy5pbWFnZXNbMF0ud2lkdGgsIGRlZmF1bHRBbmltYXRpb25EaXJlY3Rpb25zLmltYWdlc1swXS5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBsZWF2ZSB0aGUgc2l6ZSBhcyAoMCwgMClcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZ2luKSB7XFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSB2ZWNfMS52ZWMyLmNweSh0aGlzLm9wdGlvbnMub3JpZ2luKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIGNlbnRlciBvZiB0aGUgc3ByaXRlIGJhc2VkIG9uIHNpemVcXG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IHZlY18xLnZlYzIubXVsKHRoaXMuc2l6ZSwgMC41KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGUpIHtcXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGlvbikge1xcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSB0aGlzLm9wdGlvbnMucm90YXRpb247XFxuICAgICAgICB9XFxuICAgICAgICAvLyBDaGVjayBhbmQgaW5pdGlhbGlzZSBkaXJlY3Rpb25cXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kZWZhdWx0RGlyZWN0aW9uO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCB8fFxcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuZGlyZWN0aW9ucy5pbmNsdWRlcyh0aGlzLl9kaXJlY3Rpb24pKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpcmVjdGlvbiBcXFwiJHt0aGlzLl9kaXJlY3Rpb259XFxcImApO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gQ2hlY2sgYW5kIGluaXRpYWxpc2UgYW5pbWF0aW9uXFxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB0aGlzLm9wdGlvbnMuZGVmYXVsdEFuaW1hdGlvbjtcXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9ucyk7XFxuICAgICAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPT09IDAgfHwgIWFuaW1hdGlvbnMuaW5jbHVkZXModGhpcy5fYW5pbWF0aW9uKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhbmltYXRpb24gXFxcIiR7dGhpcy5fYW5pbWF0aW9ufVxcXCJgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhdHRhY2htZW50IHBvaW50IGtleWZyYW1lcyBhcmUgZGVmaW5lZCBpbiBhc2NlbmRpbmdcXG4gICAgICAgIC8vIGZyYW1lIG9yZGVyIGluIGFsbCBhbmltYXRpb25zXFxuICAgICAgICBmb3IgKGNvbnN0IGFuaW1hdGlvbiBvZiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9ucykpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dKSkge1xcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVtkaXJlY3Rpb25dLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRhY2htZW50UG9pbnQgb2YgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbYW5pbWF0aW9uXVtkaXJlY3Rpb25dXFxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1thbmltYXRpb25dW2RpcmVjdGlvbl0uYXR0YWNobWVudFBvaW50S2V5ZnJhbWVzW2F0dGFjaG1lbnRQb2ludF0uc29ydCgoYSwgYikgPT4gYS5mcmFtZSAtIGIuZnJhbWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGdldCBkaXJlY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xcbiAgICB9XFxuICAgIHNldCBkaXJlY3Rpb24odmFsdWUpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9ucy5pbmNsdWRlcyh2YWx1ZSkpIHtcXG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBnZXQgYW5pbWF0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbjtcXG4gICAgfVxcbiAgICBzZXQgYW5pbWF0aW9uKHZhbHVlKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XFxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmFuaW1hdGlvbnMpLmluY2x1ZGVzKHZhbHVlKSkge1xcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fYW5pbWF0aW9uO1xcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IHZhbHVlO1xcbiAgICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGFuaW1hdGlvbnMsIHdlIG1pZ2h0IGJlIHBhcnQtd2F5IHRocm91Z2ggYW5kIHRoZVxcbiAgICAgICAgICAgIC8vIG5ldyBhbmltYXRpb24gbWlnaHQgaGF2ZSBmZXdlciBmcmFtZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGNsYW1wXFxuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZnJhbWUgbnVtYmVyXFxuICAgICAgICAgICAgY29uc3QgY3VycmVudEZyYW1lQ291bnQgPSAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1t2YWx1ZV1bdGhpcy5kaXJlY3Rpb25dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWVDb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZyYW1lQ291bnQgPSAoX2QgPSAoX2MgPSB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1twcmV2aW91c11bdGhpcy5kaXJlY3Rpb25dKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZnJhbWVDb3VudCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMTtcXG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lQ291bnQgPCBwcmV2aW91c0ZyYW1lQ291bnQgJiZcXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUgJiZcXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID49IGN1cnJlbnRGcmFtZUNvdW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA9IGN1cnJlbnRGcmFtZUNvdW50IC0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcGxheUFuaW1hdGlvbigpIHtcXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLnBsYXlpbmcgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHBhdXNlQW5pbWF0aW9uKCkge1xcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUucGxheWluZyA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJlc2V0QW5pbWF0aW9uKCkge1xcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID0gMDtcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWVUaW1lID0gMDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBnZXRBdHRhY2htZW50UG9pbnQobmFtZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYjtcXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbbmFtZV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XFxuICAgIH1cXG4gICAgdXBkYXRlKGR0KSB7XFxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zID0gdGhpcy51cGRhdGVBbmltYXRpb25PcHRpb25zKCk7XFxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSA9IHRoaXMudXBkYXRlQW5pbWF0aW9uU3RhdGUoZHQpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50SW1hZ2UgPSB0aGlzLnVwZGF0ZUltYWdlKCk7XFxuICAgICAgICB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzID0gdGhpcy51cGRhdGVBdHRhY2htZW50UG9pbnRzKCk7XFxuICAgIH1cXG4gICAgdXBkYXRlQW5pbWF0aW9uT3B0aW9ucygpIHtcXG4gICAgICAgIGlmICghKHRoaXMuX2FuaW1hdGlvbiBpbiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9ucykpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYW5pbWF0aW9uIFxcXCIke3RoaXMuX2FuaW1hdGlvbn1cXFwiYCk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBkaXJlY3Rpb25zID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdGhpcy5fYW5pbWF0aW9uXSk7XFxuICAgICAgICBpZiAoZGlyZWN0aW9ucy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRpcmVjdGlvbnMgYXZhaWxhYmxlIGZvciBhbmltYXRpb24gXFxcIiR7dGhpcy5fYW5pbWF0aW9ufVxcXCJgKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gaW4gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdGhpcy5fYW5pbWF0aW9uXSkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uc1t0aGlzLl9hbmltYXRpb25dW3RoaXMuX2RpcmVjdGlvbl07XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoJyonIGluIHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMuX2FuaW1hdGlvbl0pIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnNbdGhpcy5fYW5pbWF0aW9uXVsnKiddO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hbmltYXRpb25zW3RoaXMuX2FuaW1hdGlvbl1bZGlyZWN0aW9uc1swXV07XFxuICAgIH1cXG4gICAgdXBkYXRlQW5pbWF0aW9uU3RhdGUoZHQpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zIHx8ICF0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZSkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIHBsYXlpbmc6IHRydWUsXFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZTogMCxcXG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lVGltZTogMCxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLnBsYXlpbmcpIHtcXG4gICAgICAgICAgICBjb25zdCBmcmFtZVRpbWUgPSAxIC8gKChfYSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuZnJhbWVSYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKTtcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWVUaW1lICs9IGR0O1xcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWVUaW1lID4gZnJhbWVUaW1lKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSAoX2IgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmZyYW1lQ291bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSsrO1xcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50RnJhbWVUaW1lID0gMDtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA+PSBmcmFtZUNvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlID0gKF9jID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5tb2RlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBTcHJpdGVBbmltYXRpb25SZXBlYXRNb2RlLlJlcGVhdDtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZS5QbGF5T25jZUFuZFJlc2V0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25TdGF0ZS5wbGF5aW5nID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA9IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZS5QbGF5T25jZUFuZFN0b3A6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLnBsYXlpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lID0gZnJhbWVDb3VudCAtIDE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ByaXRlQW5pbWF0aW9uUmVwZWF0TW9kZS5SZXBlYXQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlLmN1cnJlbnRGcmFtZSA9IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlO1xcbiAgICB9XFxuICAgIHVwZGF0ZUltYWdlKCkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMgfHwgIXRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuaW1hZ2VzIHx8XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5pbWFnZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3B0aW9ucy5pbWFnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoKF9jID0gKF9iID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uT3B0aW9ucy5pbWFnZXNbdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5vcHRpb25zLmltYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsKTtcXG4gICAgfVxcbiAgICB1cGRhdGVBdHRhY2htZW50UG9pbnRzKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXR0YWNobWVudFBvaW50cyB8fFxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdHRhY2htZW50UG9pbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QXR0YWNobWVudFBvaW50cyA9IE9iamVjdC5mcm9tRW50cmllcyh0aGlzLm9wdGlvbnMuYXR0YWNobWVudFBvaW50cy5tYXAoYXR0YWNobWVudFBvaW50ID0+IFtcXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudFBvaW50Lm5hbWUsXFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRQb2ludC5vZmZzZXQsXFxuICAgICAgICAgICAgXSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMgJiZcXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lcyAmJlxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblN0YXRlKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpKSB7XFxuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHRoaXMuY3VycmVudEFuaW1hdGlvbk9wdGlvbnMuYXR0YWNobWVudFBvaW50S2V5ZnJhbWVzICYmXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lc1tuYW1lXS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0tleWZyYW1lID0gdGhpcy5maW5kUHJldmlvdXNLZXlmcmFtZSh0aGlzLmN1cnJlbnRBbmltYXRpb25PcHRpb25zLmF0dGFjaG1lbnRQb2ludEtleWZyYW1lc1tuYW1lXSwgdGhpcy5jdXJyZW50QW5pbWF0aW9uU3RhdGUuY3VycmVudEZyYW1lKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHNbbmFtZV0gPSBwcmV2aW91c0tleWZyYW1lLm9mZnNldDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRBdHRhY2htZW50UG9pbnRzO1xcbiAgICB9XFxuICAgIGZpbmRQcmV2aW91c0tleWZyYW1lKGtleWZyYW1lcywgY3VycmVudEZyYW1lKSB7XFxuICAgICAgICBjb25zdCBmb3VuZCA9IFsuLi5rZXlmcmFtZXNdXFxuICAgICAgICAgICAgLnJldmVyc2UoKVxcbiAgICAgICAgICAgIC5maW5kKGtleWZyYW1lID0+IGtleWZyYW1lLmZyYW1lIDw9IGN1cnJlbnRGcmFtZSk7XFxuICAgICAgICBpZiAoIWZvdW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZm91bmQ7XFxuICAgIH1cXG4gICAgZHJhdyhjb250ZXh0KSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcXG4gICAgICAgIGNvbnRleHQuc2NhbGUodGhpcy5zY2FsZSwgdGhpcy5zY2FsZSk7XFxuICAgICAgICBjb250ZXh0LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykucHJlUmVuZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY29udGV4dCwgdGhpcyk7XFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50SW1hZ2UpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLmN1cnJlbnRJbWFnZSwgLXRoaXMub3JpZ2luLngsIC10aGlzLm9yaWdpbi55LCB0aGlzLmN1cnJlbnRJbWFnZS53aWR0aCwgdGhpcy5jdXJyZW50SW1hZ2UuaGVpZ2h0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMub3B0aW9ucykucG9zdFJlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIGNvbnRleHQsIHRoaXMpO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zy5zaG93U3ByaXRlQm91bmRpbmdCb3gpIHtcXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gU3ByaXRlLkRFQlVHX0JPVU5ESU5HX0JPWF9DT0xPVVI7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBTcHJpdGUuREVCVUdfQk9VTkRJTkdfQk9YX0xJTkVfV0lEVEg7XFxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KC10aGlzLm9yaWdpbi54LCAtdGhpcy5vcmlnaW4ueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd1Nwcml0ZVRyYW5zZm9ybXMpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdUcmFuc2Zvcm1zTWFya2VyKGNvbnRleHQsICgwLCB2ZWNfMS52ZWMyKSgpLCBTcHJpdGUuREVCVUdfVFJBTlNGT1JNU19DT0xPVVJfWCwgU3ByaXRlLkRFQlVHX1RSQU5TRk9STVNfQ09MT1VSX1ksIFNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX0xJTkVfV0lEVEgsIFNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX1NJWkUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zy5zaG93QXR0YWNobWVudFBvaW50cyAmJlxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnRQb2ludCBvZiBPYmplY3QudmFsdWVzKHRoaXMuY3VycmVudEF0dGFjaG1lbnRQb2ludHMpKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Nyb3NzKGNvbnRleHQsIGF0dGFjaG1lbnRQb2ludCwgU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfQ09MT1VSLCBTcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9MSU5FX1dJRFRILCBTcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9TSVpFKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3VHJhbnNmb3Jtc01hcmtlcihjb250ZXh0LCBwb3NpdGlvbiwgeENvbG91ciwgeUNvbG91ciwgbGluZVdpZHRoLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHhDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54ICsgc2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHlDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55ICsgc2l6ZSk7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd0Nyb3NzKGNvbnRleHQsIHBvc2l0aW9uLCBjb2xvdXIsIGxpbmVXaWR0aCwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gTWF0aC5jZWlsKHNpemUgLyAyKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55ICsgaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxufVxcbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xcblNwcml0ZS5ERUZBVUxUX09QVElPTlMgPSB7XFxuICAgIGRpcmVjdGlvbnM6IFsnZGVmYXVsdCddLFxcbiAgICBkZWZhdWx0RGlyZWN0aW9uOiAnZGVmYXVsdCcsXFxuICAgIGFuaW1hdGlvbnM6IHtcXG4gICAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgICAgICAnKic6IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICAgICAgICAgICAgICBmcmFtZUNvdW50OiAxLFxcbiAgICAgICAgICAgICAgICBmcmFtZVJhdGU6IDEsXFxuICAgICAgICAgICAgICAgIG1vZGU6IFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUuUGxheU9uY2VBbmRTdG9wLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICB9LFxcbiAgICB9LFxcbiAgICBkZWZhdWx0QW5pbWF0aW9uOiAnZGVmYXVsdCcsXFxufTtcXG5TcHJpdGUuREVGQVVMVF9BTklNQVRJT05fT1BUSU9OUyA9IHtcXG4gICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICBmcmFtZUNvdW50OiAxLFxcbiAgICBmcmFtZVJhdGU6IDEsXFxuICAgIG1vZGU6IFNwcml0ZUFuaW1hdGlvblJlcGVhdE1vZGUuUmVwZWF0LFxcbn07XFxuU3ByaXRlLkRFQlVHX0JPVU5ESU5HX0JPWF9DT0xPVVIgPSAnZ3JlZW4nO1xcblNwcml0ZS5ERUJVR19CT1VORElOR19CT1hfTElORV9XSURUSCA9IDI7XFxuU3ByaXRlLkRFQlVHX1RSQU5TRk9STVNfQ09MT1VSX1ggPSAncmVkJztcXG5TcHJpdGUuREVCVUdfVFJBTlNGT1JNU19DT0xPVVJfWSA9ICdvcmFuZ2UnO1xcblNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX0xJTkVfV0lEVEggPSAxO1xcblNwcml0ZS5ERUJVR19UUkFOU0ZPUk1TX1NJWkUgPSAxMDtcXG5TcHJpdGUuREVCVUdfQVRUQUNITUVOVF9QT0lOVF9DT0xPVVIgPSAnYmx1ZSc7XFxuU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfTElORV9XSURUSCA9IDI7XFxuU3ByaXRlLkRFQlVHX0FUVEFDSE1FTlRfUE9JTlRfU0laRSA9IDU7XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBDT05URU5UIFBST0NFU1NPUlxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLyoqXFxuICogQ29udGVudCBNYW5hZ2VyIFByb2Nlc3NvciB3cmFwcGVyIHdoaWNoIGNvbnZlcnRzIFNwcml0ZU9wdGlvbnNEYXRhIGludG9cXG4gKiBTcHJpdGVPcHRpb25zXFxuICpcXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlclxcbiAqL1xcbmFzeW5jIGZ1bmN0aW9uIHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yKGNvbnRlbnQsIGRhdGEpIHtcXG4gICAgaWYgKCFpc1Nwcml0ZU9wdGlvbnNEYXRhKGRhdGEuY29udGVudCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzcHJpdGUgY29uZmlnJyk7XFxuICAgIH1cXG4gICAgY29uc3QgZ2V0SW1hZ2VGcm9tQ29udGVudCA9IChuYW1lKSA9PiB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBjb25zdCBpbWFnZSA9IChfYSA9IGNvbnRlbnRbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xcbiAgICAgICAgaWYgKCFpbWFnZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGltYWdlO1xcbiAgICB9O1xcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmNvbnRlbnQ7XFxuICAgIGlmIChyZXN1bHQuaW1hZ2VOYW1lKSB7XFxuICAgICAgICByZXN1bHQuaW1hZ2UgPSBnZXRJbWFnZUZyb21Db250ZW50KHJlc3VsdC5pbWFnZU5hbWUpO1xcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5pbWFnZU5hbWU7XFxuICAgIH1cXG4gICAgaWYgKHJlc3VsdC5hbmltYXRpb25zKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IFthbmltYXRpb25OYW1lLCBhbmltYXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC5hbmltYXRpb25zKSkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2RpcmVjdGlvbk5hbWUsIGRpcmVjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoYW5pbWF0aW9uKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmltYWdlTmFtZXMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdW2RpcmVjdGlvbk5hbWVdLmltYWdlcyA9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLmltYWdlTmFtZXMubWFwKGdldEltYWdlRnJvbUNvbnRlbnQpO1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdW2RpcmVjdGlvbk5hbWVdLmltYWdlTmFtZXM7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZGF0YS5jb250ZW50ID0gcmVzdWx0O1xcbn1cXG5leHBvcnRzLnNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yID0gc3ByaXRlT3B0aW9uc0NvbnRlbnRQcm9jZXNzb3I7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2Uvc3ByaXRlLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBUWVBFU1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudGV4dHVyZUF0bGFzQ29udGVudFByb2Nlc3NvciA9IGV4cG9ydHMudGV4dHVyZUF0bGFzID0gZXhwb3J0cy5pc1RleHR1cmVBdGxhc1JlZ2lvbiA9IGV4cG9ydHMuaXNUZXh0dXJlQXRsYXNPcHRpb25zID0gdm9pZCAwO1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gVFlQRSBHVUFSRFNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbmZ1bmN0aW9uIGlzVGV4dHVyZUF0bGFzT3B0aW9ucyh2YWx1ZSkge1xcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgncmVsYXRpdmUnIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVsYXRpdmUgIT09ICdib29sZWFuJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICghKCd3aWR0aCcgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS53aWR0aCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgnaGVpZ2h0JyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmhlaWdodCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoISgncmVnaW9ucycgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZWdpb25zICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGZvciAoY29uc3QgW2tleSwgcmVnaW9uXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZS5yZWdpb25zKSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFpc1RleHR1cmVBdGxhc1JlZ2lvbihyZWdpb24pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgnY2VsbE1hcmdpbicgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmNlbGxNYXJnaW4gIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxufVxcbmV4cG9ydHMuaXNUZXh0dXJlQXRsYXNPcHRpb25zID0gaXNUZXh0dXJlQXRsYXNPcHRpb25zO1xcbmZ1bmN0aW9uIGlzVGV4dHVyZUF0bGFzUmVnaW9uKHZhbHVlKSB7XFxuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmICghKCd4JyBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnggIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCEoJ3knIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUueSAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICBpZiAoJ3dpZHRoJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUud2lkdGggIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdoZWlnaHQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5oZWlnaHQgIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdyZXBlYXQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5yZXBlYXQgIT09ICdudW1iZXInKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgaWYgKCdyZXBlYXRPZmZzZXQnIGluIHZhbHVlKSB7XFxuICAgICAgICBjb25zdCByZXBlYXRPZmZzZXQgPSB2YWx1ZS5yZXBlYXRPZmZzZXQ7XFxuICAgICAgICBpZiAoIXJlcGVhdE9mZnNldCB8fCB0eXBlb2YgcmVwZWF0T2Zmc2V0ICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghKCd4JyBpbiByZXBlYXRPZmZzZXQpIHx8IHR5cGVvZiByZXBlYXRPZmZzZXQueCAhPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoISgneScgaW4gcmVwZWF0T2Zmc2V0KSB8fCB0eXBlb2YgcmVwZWF0T2Zmc2V0LnkgIT09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgncmVwZWF0TmFtZUZvcm1hdCcgaW4gdmFsdWUgJiZcXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5yZXBlYXROYW1lRm9ybWF0ICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbn1cXG5leHBvcnRzLmlzVGV4dHVyZUF0bGFzUmVnaW9uID0gaXNUZXh0dXJlQXRsYXNSZWdpb247XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBERUZBVUxUU1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuY29uc3QgREVGQVVMVF9SRVBFQVRJTkdfUkVHSU9OX05BTUVfRk9STUFUID0gJ3tuYW1lfS17bn0nO1xcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcXG4gICAgcmVsYXRpdmU6IHRydWUsXFxuICAgIHdpZHRoOiAxLFxcbiAgICBoZWlnaHQ6IDEsXFxuICAgIHJlZ2lvbnM6IHtcXG4gICAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgICAgICB4OiAwLFxcbiAgICAgICAgICAgIHk6IDAsXFxuICAgICAgICB9LFxcbiAgICB9LFxcbiAgICBjZWxsTWFyZ2luOiAwLFxcbn07XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBGVU5DVElPTlNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbi8qKlxcbiAqIFRha2VzIGFuIGltYWdlIGFuZCBzb21lIHRleHR1cmUgYXRsYXMgb3B0aW9ucyBhbmQgcmV0dXJucyBhIGRpY3Rpb25hcnlcXG4gKiBvZiBjYW52YXNlcyBpbmRleGVkIGJ5IHJlZ2lvbiBuYW1lXFxuICovXFxuZnVuY3Rpb24gdGV4dHVyZUF0bGFzKGltYWdlLCBvcHRpb25zKSB7XFxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xcbiAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgIGlmIChhY3R1YWxPcHRpb25zLndpZHRoIDw9IDAgfHwgYWN0dWFsT3B0aW9ucy5oZWlnaHQgPD0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcXG4gICAgfVxcbiAgICBpZiAoT2JqZWN0LmtleXMoYWN0dWFsT3B0aW9ucy5yZWdpb25zKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVnaW9ucyBkZWZpbmVkJyk7XFxuICAgIH1cXG4gICAgbGV0IGNlbGxXaWR0aCA9IDE7XFxuICAgIGxldCBjZWxsSGVpZ2h0ID0gMTtcXG4gICAgaWYgKGFjdHVhbE9wdGlvbnMucmVsYXRpdmUpIHtcXG4gICAgICAgIGxldCBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGg7XFxuICAgICAgICBsZXQgaW1hZ2VIZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XFxuICAgICAgICBjb25zdCBjZWxsTWFyZ2luID0gKF9hID0gYWN0dWFsT3B0aW9ucy5jZWxsTWFyZ2luKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xcbiAgICAgICAgaWYgKGNlbGxNYXJnaW4gPiAwKSB7XFxuICAgICAgICAgICAgaW1hZ2VXaWR0aCAtPSBjZWxsTWFyZ2luO1xcbiAgICAgICAgICAgIGltYWdlSGVpZ2h0IC09IGNlbGxNYXJnaW47XFxuICAgICAgICB9XFxuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLmNlaWwoaW1hZ2VXaWR0aCAvIGFjdHVhbE9wdGlvbnMud2lkdGgpO1xcbiAgICAgICAgY2VsbEhlaWdodCA9IE1hdGguY2VpbChpbWFnZUhlaWdodCAvIGFjdHVhbE9wdGlvbnMuaGVpZ2h0KTtcXG4gICAgfVxcbiAgICBjb25zdCBtYXAgPSB7fTtcXG4gICAgZm9yIChjb25zdCBbbmFtZSwgcmVnaW9uXSBvZiBPYmplY3QuZW50cmllcyhhY3R1YWxPcHRpb25zLnJlZ2lvbnMpKSB7XFxuICAgICAgICBsZXQgYWJzb2x1dGVYID0gTWF0aC5mbG9vcihyZWdpb24ueCAqIGNlbGxXaWR0aCk7XFxuICAgICAgICBsZXQgYWJzb2x1dGVZID0gTWF0aC5mbG9vcihyZWdpb24ueSAqIGNlbGxIZWlnaHQpO1xcbiAgICAgICAgbGV0IGFic29sdXRlV2lkdGggPSBNYXRoLmNlaWwocmVnaW9uLndpZHRoXFxuICAgICAgICAgICAgPyBhY3R1YWxPcHRpb25zLnJlbGF0aXZlXFxuICAgICAgICAgICAgICAgID8gcmVnaW9uLndpZHRoICogY2VsbFdpZHRoXFxuICAgICAgICAgICAgICAgIDogcmVnaW9uLndpZHRoXFxuICAgICAgICAgICAgOiBhY3R1YWxPcHRpb25zLnJlbGF0aXZlXFxuICAgICAgICAgICAgICAgID8gY2VsbFdpZHRoXFxuICAgICAgICAgICAgICAgIDogaW1hZ2Uud2lkdGggLSBhYnNvbHV0ZVgpO1xcbiAgICAgICAgbGV0IGFic29sdXRlSGVpZ2h0ID0gTWF0aC5jZWlsKHJlZ2lvbi5oZWlnaHRcXG4gICAgICAgICAgICA/IGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgPyByZWdpb24uaGVpZ2h0ICogY2VsbEhlaWdodFxcbiAgICAgICAgICAgICAgICA6IHJlZ2lvbi5oZWlnaHRcXG4gICAgICAgICAgICA6IGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgPyBjZWxsSGVpZ2h0XFxuICAgICAgICAgICAgICAgIDogaW1hZ2UuaGVpZ2h0IC0gYWJzb2x1dGVZKTtcXG4gICAgICAgIGNvbnN0IGNlbGxNYXJnaW4gPSAoX2IgPSBhY3R1YWxPcHRpb25zLmNlbGxNYXJnaW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XFxuICAgICAgICBpZiAoYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZSAmJiBjZWxsTWFyZ2luID4gMCkge1xcbiAgICAgICAgICAgIGFic29sdXRlWCArPSBjZWxsTWFyZ2luO1xcbiAgICAgICAgICAgIGFic29sdXRlWSArPSBjZWxsTWFyZ2luO1xcbiAgICAgICAgICAgIGFic29sdXRlV2lkdGggLT0gY2VsbE1hcmdpbjtcXG4gICAgICAgICAgICBhYnNvbHV0ZUhlaWdodCAtPSBjZWxsTWFyZ2luO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlZ2lvbi5yZXBlYXQgJiYgcmVnaW9uLnJlcGVhdCA+IDApIHtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2lvbi5yZXBlYXQ7IGkrKykge1xcbiAgICAgICAgICAgICAgICBjb25zdCByZXBlYXROYW1lID0gZ2V0UmVwZWF0aW5nUmVnaW9uTmFtZShuYW1lLCBpICsgMSwgcmVnaW9uLnJlcGVhdE5hbWVGb3JtYXQpO1xcbiAgICAgICAgICAgICAgICBsZXQgcmVwZWF0T2Zmc2V0WCA9IE1hdGguZmxvb3IoKChfYyA9IHJlZ2lvbi5yZXBlYXRPZmZzZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy54KSAhPT0gdW5kZWZpbmVkICYmXFxuICAgICAgICAgICAgICAgICAgICAoKF9kID0gcmVnaW9uLnJlcGVhdE9mZnNldCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLngpICE9PSBudWxsXFxuICAgICAgICAgICAgICAgICAgICA/IGFjdHVhbE9wdGlvbnMucmVsYXRpdmVcXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZ2lvbi5yZXBlYXRPZmZzZXQueCAqIGNlbGxXaWR0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVnaW9uLnJlcGVhdE9mZnNldC54XFxuICAgICAgICAgICAgICAgICAgICA6IGNlbGxXaWR0aCk7XFxuICAgICAgICAgICAgICAgIGxldCByZXBlYXRPZmZzZXRZID0gTWF0aC5mbG9vcigoKF9lID0gcmVnaW9uLnJlcGVhdE9mZnNldCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnkpICE9PSB1bmRlZmluZWQgJiZcXG4gICAgICAgICAgICAgICAgICAgICgoX2YgPSByZWdpb24ucmVwZWF0T2Zmc2V0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YueSkgIT09IG51bGxcXG4gICAgICAgICAgICAgICAgICAgID8gYWN0dWFsT3B0aW9ucy5yZWxhdGl2ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVnaW9uLnJlcGVhdE9mZnNldC55ICogY2VsbEhlaWdodFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVnaW9uLnJlcGVhdE9mZnNldC55XFxuICAgICAgICAgICAgICAgICAgICA6IDApO1xcbiAgICAgICAgICAgICAgICBtYXBbcmVwZWF0TmFtZV0gPSBjaG9wUmVnaW9uKGltYWdlLCBhYnNvbHV0ZVggKyByZXBlYXRPZmZzZXRYICogaSwgYWJzb2x1dGVZICsgcmVwZWF0T2Zmc2V0WSAqIGksIGFic29sdXRlV2lkdGgsIGFic29sdXRlSGVpZ2h0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBtYXBbbmFtZV0gPSBjaG9wUmVnaW9uKGltYWdlLCBhYnNvbHV0ZVgsIGFic29sdXRlWSwgYWJzb2x1dGVXaWR0aCwgYWJzb2x1dGVIZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBtYXA7XFxufVxcbmV4cG9ydHMudGV4dHVyZUF0bGFzID0gdGV4dHVyZUF0bGFzO1xcbi8qKlxcbiAqIENob3AgYSByZWN0YW5ndWxhciByZWdpb24gZnJvbSBhbiBpbWFnZSBpbnRvIGEgbmV3IGNhbnZhc1xcbiAqL1xcbmZ1bmN0aW9uIGNob3BSZWdpb24oaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XFxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XFxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XFxuICAgIGlmICghY29udGV4dCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IDJEIGNvbnRleHQnKTtcXG4gICAgfVxcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XFxuICAgIHJldHVybiBjYW52YXM7XFxufVxcbi8qKlxcbiAqIEdldCB0aGUgbmFtZSBvZiBhIHJlcGVhdGluZyByZWdpb25cXG4gKi9cXG5mdW5jdGlvbiBnZXRSZXBlYXRpbmdSZWdpb25OYW1lKHJlZ2lvbk5hbWUsIHJlcGV0aXRpb25JbmRleCwgcmVnaW9uTmFtZUZvcm1hdCkge1xcbiAgICByZXR1cm4gKHJlZ2lvbk5hbWVGb3JtYXQgIT09IG51bGwgJiYgcmVnaW9uTmFtZUZvcm1hdCAhPT0gdm9pZCAwID8gcmVnaW9uTmFtZUZvcm1hdCA6IERFRkFVTFRfUkVQRUFUSU5HX1JFR0lPTl9OQU1FX0ZPUk1BVClcXG4gICAgICAgIC5yZXBsYWNlKCd7bmFtZX0nLCByZWdpb25OYW1lKVxcbiAgICAgICAgLnJlcGxhY2UoJ3tufScsIHJlcGV0aXRpb25JbmRleC50b1N0cmluZygpKTtcXG59XFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBDT05URU5UIFBST0NFU1NPUlxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLyoqXFxuICogQ29udGVudCBNYW5hZ2VyIFByb2Nlc3NvciB3cmFwcGVyIHdoaWNoIGFsbG93cyB0aGUgdGV4dHVyZUF0bGFzIGZ1bmN0aW9uXFxuICogdG8gYmUgdXNlZCBhcyBhIHByb2Nlc3NvciBpbiBhIENvbnRlbnQgTWFuYWdlclxcbiAqXFxuICogQHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXJcXG4gKi9cXG5hc3luYyBmdW5jdGlvbiB0ZXh0dXJlQXRsYXNDb250ZW50UHJvY2Vzc29yKGNvbnRlbnQsIGRhdGEsIGltYWdlTmFtZSkge1xcbiAgICB2YXIgX2E7XFxuICAgIGlmICghaXNUZXh0dXJlQXRsYXNPcHRpb25zKGRhdGEuY29udGVudCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0ZXh0dXJlIGF0bGFzIG9wdGlvbnMnKTtcXG4gICAgfVxcbiAgICBjb25zdCBpbWFnZSA9IChfYSA9IGNvbnRlbnRbaW1hZ2VOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XFxuICAgIGlmICghaW1hZ2UpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgJyR7aW1hZ2VOYW1lfScgbm90IGZvdW5kYCk7XFxuICAgIH1cXG4gICAgY29uc3QgbWFwID0gdGV4dHVyZUF0bGFzKGltYWdlLCBkYXRhLmNvbnRlbnQpO1xcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjYW52YXNdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcXG4gICAgICAgIGNvbnRlbnRbYCR7ZGF0YS5uYW1lfV8ke25hbWV9YF0gPSB7XFxuICAgICAgICAgICAgbmFtZSxcXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNhbnZhcyxcXG4gICAgICAgICAgICBzdGF0dXM6ICdwcm9jZXNzZWQnLFxcbiAgICAgICAgfTtcXG4gICAgfVxcbn1cXG5leHBvcnRzLnRleHR1cmVBdGxhc0NvbnRlbnRQcm9jZXNzb3IgPSB0ZXh0dXJlQXRsYXNDb250ZW50UHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RleHR1cmUtYXRsYXMvLi9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgY2FuJ3QgYmUgaW5saW5lZCBiZWNhdXNlIHRoZSBldmFsIGRldnRvb2wgaXMgdXNlZC5cbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1tcIi4vaW5kZXgudHNcIl0oMCwgX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIE1lbW9pemUgYSBmdW5jdGlvblxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemVcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbWVtb2l6ZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb25cXG4gKi9cXG5jb25zdCBtZW1vaXplID0gZiA9PiB7XFxuICB2YXIgY2FjaGUgPSB7fTtcXG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XFxuICAgIHJldHVybiBjYWNoZVthcmdzXSA/PyAoY2FjaGVbYXJnc10gPSBmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcXG4gIH07XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gW3A9TnVtYmVyLkVQU0lMT05dIFRoZSBwcmVjaXNpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG51bWJlcnMgYSBhbmQgYiBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxcbiAqL1xcbmNvbnN0IGZsb2F0RXF1YWxzID0gKGEsIGIsIHAgPSBOdW1iZXIuRVBTSUxPTikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgcDtcXG5cXG4vKipcXG4gKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byBjbGFtcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBudW1iZXJcXG4gKi9cXG5jb25zdCBjbGFtcCA9IChhLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiBhIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgZnJvbSB3aGljaCB0byBnZXQgdGhlIGZyYWN0aW9uYWwgcGFydFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgbnVtYmVyXFxuICovXFxuY29uc3QgZnJhYyA9IGEgPT4gYSA+PSAwID8gYSAtIE1hdGguZmxvb3IoYSkgOiBhIC0gTWF0aC5jZWlsKGEpO1xcblxcbi8qKlxcbiAqIFJvdW5kIG4gdG8gZCBkZWNpbWFsIHBsYWNlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmRcXG4gKiBAcGFyYW0ge251bWJlcn0gW2Q9MF0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSByb3VuZGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IHJvdW5kID0gKG4sIGQgPSAwKSA9PiB7XFxuICBjb25zdCBwID0gTWF0aC5wb3coMTAsIGQpO1xcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIHAgKyBOdW1iZXIuRVBTSUxPTikgLyBwO1xcbn1cXG5cXG4vKipcXG4gKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cXG4gKi9cXG5jb25zdCBsZXJwID0gKGEsIGIsIGkpID0+IGEgKyAoYiAtIGEpICogaTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcXG4gKi9cXG5jb25zdCB1bmxlcnAgPSAoYSwgYiwgaSkgPT4gKGkgLSBhKSAvIChiIC0gYSk7XFxuXFxuLyoqXFxuICogRG8gYSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTAgVG9wLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGMwMSBCb3R0b20tbGVmdCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGl4IEludGVycG9sYXRpb24gdmFsdWUgYWxvbmcgeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeSBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXFxuICovXFxuY29uc3QgYmxlcnAgPSAoYzAwLCBjMTAsIGMwMSwgYzExLCBpeCwgaXkpID0+IGxlcnAobGVycChjMDAsIGMxMCwgaXgpLCBsZXJwKGMwMSwgYzExLCBpeCksIGl5KTtcXG5cXG4vKipcXG4gKiBSZS1tYXAgYSBudW1iZXIgaSBmcm9tIHJhbmdlIGExLi4uYTIgdG8gYjEuLi5iMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXFxuICogQHBhcmFtIHtudW1iZXJ9IGExXFxuICogQHBhcmFtIHtudW1iZXJ9IGEyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIxXFxuICogQHBhcmFtIHtudW1iZXJ9IGIyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmNvbnN0IHJlbWFwID0gKGksIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArIChpIC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpO1xcblxcbi8qKlxcbiAqIERvIGEgc21vb3RoIGludGVycG9sYXRpb24gYmV0d2VlbiBhIGFuZCBiXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGludGVycG9sYXRpb24gdmFsdWVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3Qgc21vb3Roc3RlcCA9IChhLCBiLCBpKSA9PiBsZXJwKGEsIGIsIDMgKiBNYXRoLnBvdyhpLCAyKSAtIDIgKiBNYXRoLnBvdyhpLCAzKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKi9cXG5jb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiBkZWdyZWVzXFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiBkZWdyZWVzXFxuICovXFxuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEV4Y2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICovXFxuY29uc3QgcmFuZG9tQmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xcblxcbi8qKlxcbiAqIEdldCBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBJbmNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXFxuICovXFxuY29uc3QgcmFuZG9tSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IFttdT0wLjVdIFRoZSBtZWFuIHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9Ml0gVGhlIG51bWJlciBvZiBzYW1wbGVzXFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb20gPSAobXUgPSAwLjUsIHNpZ21hID0gMC41LCBzYW1wbGVzID0gMikgPT4ge1xcbiAgbGV0IHRvdGFsID0gMDtcXG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XFxuICAgIHRvdGFsICs9IE1hdGgucmFuZG9tKCk7XFxuICB9XFxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gaW50ZWdlclxcbiAqL1xcbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdyBBbiBhcnJheSBvZiB3ZWlnaHRzXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbmRleCBmcm9tIHdcXG4gKi9cXG5jb25zdCB3ZWlnaHRlZFJhbmRvbSA9IHcgPT4ge1xcbiAgbGV0IHRvdGFsID0gdy5yZWR1Y2UoKGEsIGkpID0+IGEgKyBpLCAwKSwgbiA9IDA7XFxuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xcbiAgd2hpbGUgKHRvdGFsID4gcikge1xcbiAgICB0b3RhbCAtPSB3W24rK107XFxuICB9XFxuICByZXR1cm4gbiAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uXFxuICogQGNhbGxiYWNrIEludGVycG9sYXRpb25GdW5jdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmcm9tIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEEgbnVtYmVyIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcGFyYW0ge0ludGVycG9sYXRpb25GdW5jdGlvbn0gW2Y9TWF0aC5sZXJwXSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB0byB1c2VcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxcbiAqL1xcbmNvbnN0IGxlcnBBcnJheSA9IChhLCBpLCBmID0gbGVycCkgPT4ge1xcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcXG4gIGNvbnN0IHAgPSBjbGFtcChNYXRoLnRydW5jKHMpLCAwLCBhLmxlbmd0aCAtIDEpO1xcbiAgcmV0dXJuIGYoYVtwXSB8fCAwLCBhW3AgKyAxXSB8fCAwLCBmcmFjKHMpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG5jb25zdCBkb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmYWN0b3JpYWwgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYVxcbiAqIEByZXR1cm4ge251bWJlcn0gYSFcXG4gKi9cXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcXG4gIGxldCByZXN1bHQgPSAxO1xcbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gYTsgaSsrKSB7XFxuICAgIHJlc3VsdCAqPSBpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxcbiAqL1xcbmNvbnN0IG5wciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IG5jciA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyAoZmFjdG9yaWFsKHIpICogZmFjdG9yaWFsKG4gLSByKSk7XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYWxsIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYW4gYXJyYXlcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogYGBganNcXG4gKiBwZXJtdXRhdGlvbnMoWzEsIDIsIDNdLCAyKTtcXG4gKiBgYGBcXG4gKlxcbiAqIE91dHB1dDpcXG4gKiBgYGBqc29uXFxuICogW1xcbiAqICAgWzEsIDJdLFxcbiAqICAgWzEsIDNdLFxcbiAqICAgWzIsIDFdLFxcbiAqICAgWzIsIDNdLFxcbiAqICAgWzMsIDFdLFxcbiAqICAgWzMsIDJdXFxuICogXVxcbiAqIGBgYFxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNob29zZSBpbiBlYWNoIHBlcm11dGF0aW9uXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBwZXJtdXRhdGlvbiBhcnJheXNcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbnMgPSAoYSwgcikgPT4ge1xcbiAgaWYgKHIgPT09IDEpIHtcXG4gICAgcmV0dXJuIGEubWFwKGl0ZW0gPT4gW2l0ZW1dKTtcXG4gIH1cXG5cXG4gIHJldHVybiBhLnJlZHVjZShcXG4gICAgKGFjYywgaXRlbSwgaSkgPT4gW1xcbiAgICAgIC4uLmFjYyxcXG4gICAgICAuLi5wZXJtdXRhdGlvbnMoYS5zbGljZSgwLCBpKS5jb25jYXQoYS5zbGljZShpICsgMSkpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcXG4gICAgXSxcXG4gICAgW11cXG4gICk7XFxufVxcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFsbCBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCAyXSxcXG4gKiAgIFsxLCAzXSxcXG4gKiAgIFsyLCAzXVxcbiAqIF1cXG4gKiBgYGBcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgY29tYmluYXRpb24gYXJyYXlzXFxuICovXFxuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcXG4gIGlmIChyID09PSAxKSB7XFxuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XFxuICB9XFxuXFxuICByZXR1cm4gYS5yZWR1Y2UoXFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcXG4gICAgICAuLi5hY2MsXFxuICAgICAgLi4uY29tYmluYXRpb25zKGEuc2xpY2UoaSArIDEpLCByIC0gMSkubWFwKGMgPT4gW2l0ZW0sIC4uLmNdKSxcXG4gICAgXSxcXG4gICAgW11cXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcXG4gKlxcbiAqIEBleGFtcGxlXFxuICogYGBganNcXG4gKiBjYXJ0ZXNpYW4oWzEsIDIsIDNdLCBbJ2EnLCAnYiddKTtcXG4gKiBgYGBcXG4gKlxcbiAqIE91dHB1dDpcXG4gKiBgYGBqc29uXFxuICogW1xcbiAqICAgWzEsIFxcXCJhXFxcIl0sXFxuICogICBbMSwgXFxcImJcXFwiXSxcXG4gKiAgIFsyLCBcXFwiYVxcXCJdLFxcbiAqICAgWzIsIFxcXCJiXFxcIl0sXFxuICogICBbMywgXFxcImFcXFwiXSxcXG4gKiAgIFszLCBcXFwiYlxcXCJdXFxuICogXVxcbiAqIGBgYFxcbiAqL1xcbmNvbnN0IGNhcnRlc2lhbiA9ICguLi5hcnIpID0+XFxuICBhcnIucmVkdWNlKFxcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcXG4gICAgW1tdXVxcbiAgKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7VGltZXNGdW5jdGlvbn0gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIG11bHRpcGxlIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxcbiAqIEBwYXJhbSB7Li4uQXJyYXk8Kj59IGEgVGhlIGFycmF5cyB0byB6aXBcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKC4uLmEpID0+IHRpbWVzKGkgPT4gYS5tYXAoYSA9PiBhW2ldKSwgTWF0aC5tYXgoLi4uYS5tYXAoYSA9PiBhLmxlbmd0aCkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYXJyYXlbaV0gd2l0aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgd3JhcHBpbmdcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhIFRoZSBhcnJheSB0byBhY2Nlc3NcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7Kn0gVGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxcbiAqL1xcbmNvbnN0IHBlZWsgPSAoYSkgPT4ge1xcbiAgaWYgKCFhLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgfVxcblxcbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4gcG9zaXRpb24gaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBwb3NpdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSAyZCBhcnJheVxcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBpbiB0aGUgdW5yb2xsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBpbmQgPSAoeCwgeSwgdykgPT4geCArIHkgKiB3O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgcG9zaXRpb24gZm9yIGEgZ2l2ZW4gaW5kZXggaW4gYW4gdW5yb2xsZWQgMmQgYXJyYXlcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXhcXG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XFxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBwb3NpdGlvbiBhcyBhIDItdHVwbGVcXG4gKi9cXG5jb25zdCBwb3MgPSAoaSwgdykgPT4gW2kgJSB3LCBNYXRoLmZsb29yKGkgLyB3KV07XFxuXFxuLyoqXFxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNodW5rIHNpemVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xcbiAqL1xcbmNvbnN0IGNodW5rID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcblxcbi8qKlxcbiAqIFJhbmRvbWx5IHNodWZmbGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSBzaHVmZmxlZCBhcnJheVxcbiAqL1xcbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xcblxcbi8qKlxcbiAqIEZsYXR0ZW4gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uY2F0ZW5hdG9yIFRoZSBzdHJpbmcgdG8gdXNlIGZvciBjb25jYXRlbmF0aW5nIGtleXNcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgZmxhdHRlbmVkIG9iamVjdFxcbiAqL1xcbmNvbnN0IGZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XFxuICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xcbiAgICBpZiAob1trZXldIGluc3RhbmNlb2YgRGF0ZSkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICAuLi5hY2MsXFxuICAgICAgICBba2V5XTogb1trZXldLnRvSVNPU3RyaW5nKCksXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9ba2V5XSAhPT0gJ29iamVjdCcgfHwgIW9ba2V5XSkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICAuLi5hY2MsXFxuICAgICAgICBba2V5XTogb1trZXldLFxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgY29uc3QgZmxhdHRlbmVkID0gZmxhdChvW2tleV0sIGNvbmNhdGVuYXRvcik7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgLi4uYWNjLFxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGZsYXR0ZW5lZCkucmVkdWNlKFxcbiAgICAgICAgKGNoaWxkQWNjLCBjaGlsZEtleSkgPT4gKHtcXG4gICAgICAgICAgLi4uY2hpbGRBY2MsXFxuICAgICAgICAgIFtgJHtrZXl9JHtjb25jYXRlbmF0b3J9JHtjaGlsZEtleX1gXTogZmxhdHRlbmVkW2NoaWxkS2V5XSxcXG4gICAgICAgIH0pLFxcbiAgICAgICAge31cXG4gICAgICApLFxcbiAgICB9O1xcbiAgfSwge30pO1xcbn07XFxuXFxuLyoqXFxuICogVW5mbGF0dGVuIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIGNoZWNrIGZvciBpbiBjb25jYXRlbmF0ZWQga2V5c1xcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gdW4tZmxhdHRlbmVkIG9iamVjdFxcbiAqL1xcbmNvbnN0IHVuZmxhdCA9IChvLCBjb25jYXRlbmF0b3IgPSAnLicpID0+IHtcXG4gIGxldCByZXN1bHQgPSB7fSwgdGVtcCwgc3Vic3RyaW5ncywgcHJvcGVydHksIGk7XFxuXFxuICBmb3IgKHByb3BlcnR5IGluIG8pIHtcXG4gICAgc3Vic3RyaW5ncyA9IHByb3BlcnR5LnNwbGl0KGNvbmNhdGVuYXRvcik7XFxuICAgIHRlbXAgPSByZXN1bHQ7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAgIGlmICghKHN1YnN0cmluZ3NbaV0gaW4gdGVtcCkpIHtcXG4gICAgICAgIGlmIChpc0Zpbml0ZShzdWJzdHJpbmdzW2kgKyAxXSkpIHtcXG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IFtdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGVtcFtzdWJzdHJpbmdzW2ldXSA9IHt9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB0ZW1wID0gdGVtcFtzdWJzdHJpbmdzW2ldXTtcXG4gICAgfVxcbiAgICB0ZW1wW3N1YnN0cmluZ3Nbc3Vic3RyaW5ncy5sZW5ndGggLSAxXV0gPSBvW3Byb3BlcnR5XTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBBIHNwbGl0IHByZWRpY2F0ZVxcbiAqIEBjYWxsYmFjayBTcGxpdFByZWRpY2F0ZVxcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFycmF5IHNob3VsZCBzcGxpdCBhdCB0aGlzIGluZGV4XFxuICovXFxuXFxuLyoqXFxuICogU3BsaXQgYW4gYXJyYXkgaW50byBzdWItYXJyYXlzIGJhc2VkIG9uIGEgcHJlZGljYXRlXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcXG4gKiBAcGFyYW0ge1NwbGl0UHJlZGljYXRlfSBwcmVkaWNhdGVcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5c1xcbiAqL1xcbmNvbnN0IHNwbGl0ID0gKGFycmF5LCBwcmVkaWNhdGUpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgbGV0IGN1cnJlbnQgPSBbXTtcXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcXG4gICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xcbiAgICAgIH1cXG4gICAgICBjdXJyZW50ID0gW3ZhbHVlXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjdXJyZW50LnB1c2godmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXN1bHQucHVzaChjdXJyZW50KTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBQbHVjayBrZXlzIGZyb20gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBwbHVjayBmcm9tIHRoZSBvYmplY3RcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwbHVja2VkIGtleXNcXG4gKi9cXG5jb25zdCBwbHVjayA9IChvLCAuLi5rZXlzKSA9PiB7XFxuICByZXR1cm4ga2V5cy5yZWR1Y2UoXFxuICAgIChyZXN1bHQsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9ba2V5XSB9KSxcXG4gICAge31cXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBFeGNsdWRlIGtleXMgZnJvbSBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgb2JqZWN0XFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5cyBleGNlcHQgZXhjbHVkZWQga2V5c1xcbiAqL1xcbmNvbnN0IGV4Y2x1ZGUgPSAobywgLi4ua2V5cykgPT4ge1xcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcXG4gICAgT2JqZWN0LmVudHJpZXMobykuZmlsdGVyKChba2V5XSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSlcXG4gICk7XFxufTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIG1lbW9pemUsXFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgcm91bmQsXFxuICAgIGxlcnAsXFxuICAgIHVubGVycCxcXG4gICAgYmxlcnAsXFxuICAgIHJlbWFwLFxcbiAgICBzbW9vdGhzdGVwLFxcbiAgICByYWRpYW5zLFxcbiAgICBkZWdyZWVzLFxcbiAgICByYW5kb21CZXR3ZWVuLFxcbiAgICByYW5kb21JbnRCZXR3ZWVuLFxcbiAgICBjbHRSYW5kb20sXFxuICAgIGNsdFJhbmRvbUludCxcXG4gICAgd2VpZ2h0ZWRSYW5kb20sXFxuICAgIGxlcnBBcnJheSxcXG4gICAgZG90LFxcbiAgICBmYWN0b3JpYWwsXFxuICAgIG5wcixcXG4gICAgbmNyLFxcbiAgICBwZXJtdXRhdGlvbnMsXFxuICAgIGNvbWJpbmF0aW9ucyxcXG4gICAgY2FydGVzaWFuLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIHBlZWssXFxuICAgIGluZCxcXG4gICAgcG9zLFxcbiAgICBjaHVuayxcXG4gICAgc2h1ZmZsZSxcXG4gICAgZmxhdCxcXG4gICAgdW5mbGF0LFxcbiAgICBzcGxpdCxcXG4gICAgcGx1Y2ssXFxuICAgIGV4Y2x1ZGUsXFxuICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS90aWxlLW1hcC8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLyoqXFxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXFxuICovXFxuXFxuY29uc3QgX3ZlY190aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XFxuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xcbmNvbnN0IF92ZWNfZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcbmNvbnN0IF92ZWNfaXNfdmVjMiA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhO1xcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjMlxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgMmQgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XFxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IDJkIHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMyKDQpOyAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYzIoYSk7ICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjMiA9ICh4LCB5KSA9PiB7XFxuICBpZiAoIXggJiYgIXkpIHtcXG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfTtcXG4gIH1cXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYzIuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICovXFxudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKi9cXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSArIGJcXG4gKi9cXG52ZWMyLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLSBiXFxuICovXFxudmVjMi5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcXG4gKi9cXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXFxuICovXFxudmVjMi5zY2FsZSA9IChhLCBiKSA9PiB2ZWMyLm11bChhLCBiKTtcXG5cXG4vKipcXG4gKiBEaXZpZGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgLyBiXFxuICovXFxudmVjMi5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMi5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMyfSBeYVxcbiAqL1xcbnZlYzIubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMi5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMyLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59O1xcblxcbi8qKlxcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgMSBmb3IgOTAgZGVncmVlcyAoY3cpLCAtMSBmb3IgLTkwIGRlZ3JlZXMgKGNjdyksIDIgb3IgLTIgZm9yIDE4MCBkZWdyZWVzXFxuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzIucm90ZiA9IChhLCByKSA9PiB7XFxuICBzd2l0Y2ggKHIpIHtcXG4gICAgY2FzZSAxOiByZXR1cm4gdmVjMihhLnksIC1hLngpO1xcbiAgICBjYXNlIC0xOiByZXR1cm4gdmVjMigtYS55LCBhLngpO1xcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xcbiAgICBkZWZhdWx0OiByZXR1cm4gYTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcXG4gKi9cXG52ZWMyLmNyb3NzID0gKGEsIGIpID0+IHtcXG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMyLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMyLmNweSA9IGEgPT4gdmVjMihhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAyZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZ1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcXG4gKlxcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XFxuICogLSBgeGAgb3IgYHlgXFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYFhgLCBgWWAsIGBVYCwgYFZgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcXG4gKiAtIGAwYCBvciBgMWAgKHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkKVxcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcXG4gKlxcbiAqIEFueSBvdGhlciBjaGFyYWN0ZXJzIHdpbGwgZGVmYXVsdCB0byAwXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzIoMywgLTIpO1xcbiAqIHZlYzIuc3dpeihhLCAneCcpOyAgICAvLyBbM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxcbiAqIHZlYzIuc3dpeihhLCAneFknKTsgICAvLyBbMywgMl1cXG4gKiB2ZWMyLnN3aXooYSwgJ1l5Jyk7ICAgLy8gWzIsIC0yXVxcbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXFxuICogdmVjMi5zd2l6KGEsICd5MDF4Jyk7IC8vIFstMiwgMCwgMSwgM11cXG4gKi9cXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgcy5zcGxpdCgnJykuZm9yRWFjaCgoYywgaSkgPT4ge1xcbiAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMCc6IHJlc3VsdC5wdXNoKDApOyBicmVhaztcXG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnldW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczJkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzIucG9sYXIgPSBhID0+ICh7IHI6IHZlYzIubGVuKGEpLCB0aGV0YTogTWF0aC5hdGFuMihhLnksIGEueCkgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxcbiAqL1xcbnZlYzIuZnJvbVBvbGFyID0gKHIsIHRoZXRhKSA9PiB2ZWMyKHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpO1xcblxcbi8qKlxcbiAqIEEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjM1xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geiBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMzfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIHRoZSB6IGNvbXBvbmVudCBpZiB4IGlzIGEgdmVjMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyAzZCB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBiID0gdmVjMyg0LCA1KTsgICAgICAgICAgLy8gKDQsIDUsIDApXFxuICogbGV0IGMgPSB2ZWMzKDYpOyAgICAgICAgICAgICAvLyAoNiwgNiwgNilcXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxcbiAqIGxldCBlID0gdmVjMygpOyAgICAgICAgICAgICAgLy8gKDAsIDAsIDApXFxuICogbGV0IGYgPSB2ZWMzKHZlYzIoMSwgMiksIDMpOyAvLyAoMSwgMiwgMylcXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxcbiAqL1xcbmNvbnN0IHZlYzMgPSAoeCwgeSwgeikgPT4ge1xcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XFxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xcbiAgfVxcbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHkgfHwgMCB9O1xcbiAgfVxcbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMzLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueSwgYS56XTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSB2ZWN0b3IgZnJvbSBhbiBhcnJheSBvZiBjb21wb25lbnRzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyB2ZWN0b3JcXG4gKi9cXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXFxuICovXFxudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMSwgMClcXG4gKi9cXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxcbiAqL1xcbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxcbiAqL1xcbnZlYzMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYiksIHo6IGEueiArIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAtIGJcXG4gKi9cXG52ZWMzLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpLCB6OiBhLnogLSAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxcbiAqL1xcbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAqIGJcXG4gKi9cXG52ZWMzLnNjYWxlID0gKGEsIGIpID0+IHZlYzMubXVsKGEsIGIpO1xcblxcbi8qKlxcbiAqIERpdmlkZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAvIGJcXG4gKi9cXG52ZWMzLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpLCB6OiBhLnogLyAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMzLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSArIGEueiAqIGEueik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHt2ZWMzfSBeYVxcbiAqL1xcbnZlYzMubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjMy5sZW4oYSk7XFxuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bWF0fSBtIFRoZSByb3RhdGlvbiBtYXRyaXhcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3QgPSAoYSwgbSkgPT4gdmVjMyhcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDIpKSwgYSksXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMykpLCBhKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R4ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLngsXFxuICBhLnkgKiBNYXRoLmNvcyhyKSAtIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxcbik7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMy5yb3R5ID0gKGEsIHIpID0+IHZlYzMoXFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxcbiAgYS55LFxcbiAgLWEueCAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3MocilcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eiA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcXG4gIGEueCAqIE1hdGguc2luKHIpICsgYS55ICogTWF0aC5jb3MociksXFxuICBhLnpcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHEgVGhlIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90cSA9ICh2LCBxKSA9PiB7XFxuICBpZiAocS5sZW5ndGggIT09IDQpIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQocVswXSAqIHFbMF0gKyBxWzFdICogcVsxXSArIHFbMl0gKiBxWzJdICsgcVszXSAqIHFbM10pO1xcbiAgaWYgKGQgPT09IDApIHtcXG4gICAgcmV0dXJuIHZlYzMoKTtcXG4gIH1cXG5cXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcXG4gIGNvbnN0IHUgPSB2ZWMzKC4uLnVxLnNsaWNlKDAsIDMpKTtcXG4gIGNvbnN0IHMgPSB1cVszXTtcXG4gIHJldHVybiB2ZWMzLmFkZChcXG4gICAgdmVjMy5hZGQoXFxuICAgICAgdmVjMy5tdWwodSwgMiAqIHZlYzMuZG90KHUsIHYpKSxcXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxcbiAgICApLFxcbiAgICB2ZWMzLm11bCh2ZWMzLmNyb3NzKHUsIHYpLCAyICogcylcXG4gICk7XFxufTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgRXVsZXIgYW5nbGVzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXFxuICovXFxudmVjMy5jcm9zcyA9IChhLCBiKSA9PiB2ZWMzKFxcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxcbiAgYS56ICogYi54IC0gYS54ICogYi56LFxcbiAgYS54ICogYi55IC0gYS55ICogYi54XFxuKTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYzMuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS56ID09PSBiLno7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB4IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHkgPSBhID0+IE1hdGguYXRhbjIoYS54LCBhLnkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeiBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeiA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueik7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcXG4gKiBAY2FsbGJhY2sgdmVjM01hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMzLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JyksIHo6IGYoYS56LCAneicpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcXG5cXG4vKipcXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xcbiAqXFxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcXG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxcbiAqIC0gYHVgLCBgdmAgb3IgYHdgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgcmAsIGBnYCBvciBgYmAgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXFxuICogLSBgLmAgdG8gcmV0dXJuIHRoZSBjb21wb25lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBhdCB0aGlzIHBvc2l0aW9uIChvciAwKVxcbiAqXFxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBzd2l6emxlXFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xcbiAqIHZlYzMuc3dpeihhLCAneCcpOyAgICAgLy8gWzNdXFxuICogdmVjMy5zd2l6KGEsICd6eXgnKTsgICAvLyBbMSwgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXFxuICogdmVjMy5zd2l6KGEsICdaengnKTsgICAvLyBbLTEsIDEsIDNdXFxuICogdmVjMy5zd2l6KGEsICd4LngnKTsgICAvLyBbMywgLTIsIDNdXFxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXFxuICovXFxudmVjMy5zd2l6ID0gKGEsIHMgPSAnLi4uJykgPT4ge1xcbiAgY29uc3QgcmVzdWx0ID0gW107XFxuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XFxuICAgIHN3aXRjaCAoYykge1xcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogY2FzZSAnZyc6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ3onOiBjYXNlICd3JzogY2FzZSAnYic6IHJlc3VsdC5wdXNoKGEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcXG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IGNhc2UgJ0cnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWic6IGNhc2UgJ1cnOiBjYXNlICdCJzogcmVzdWx0LnB1c2goLWEueik7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcXG4gICAgICBjYXNlICcuJzogcmVzdWx0LnB1c2goW2EueCwgYS55LCBhLnpdW2ldID8/IDApOyBicmVhaztcXG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgM2QgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczNkXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGhpIFRoZSBwYW4gYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzM2R9IFRoZSBtYWduaXR1ZGUsIHRpbHQgYW5kIHBhbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMy5wb2xhciA9IGEgPT4ge1xcbiAgbGV0IHIgPSB2ZWMzLmxlbihhKSxcXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXFxuICAgIHBoaSA9IE1hdGguYXRhbjIoYS56LCBhLngpO1xcbiAgcmV0dXJuIHsgciwgdGhldGEsIHBoaSB9O1xcbn07XFxuXFxuLyoqXFxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcXG4gKi9cXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XFxuICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcXG4gIHJldHVybiB2ZWMzKFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxcbiAgICByICogTWF0aC5jb3ModGhldGEpLFxcbiAgICByICogc2luVGhldGEgKiBNYXRoLnNpbihwaGkpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IF92ZWNfdGltZXMoaSA9PiBtYXQuZ2V0KGEsIChpICsgMSksIG4pLCBhLm0pO1xcblxcbi8qKlxcbiAqIEFkZCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKyBiXFxuICovXFxubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXFxuICovXFxubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIF92ZWNfZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IGEgbWF0cml4IGJ5IGEgdmVjdG9yXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge3ZlYzJ8dmVjM3xudW1iZXJbXX0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlYzJ8dmVjM3xudW1iZXJbXXxmYWxzZX0gYWIgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBhbmQgdmVjdG9yIGNhbm5vdCBiZSBtdWx0aXBsaWVkXFxuICovXFxubWF0Lm11bHYgPSAoYSwgYikgPT4ge1xcbiAgbGV0IG4sIGJiLCBydDtcXG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcXG4gICAgYmIgPSB2ZWMzLmNvbXBvbmVudHMoYik7XFxuICAgIG4gPSAzO1xcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XFxuICB9IGVsc2UgaWYgKF92ZWNfaXNfdmVjMihiKSkge1xcbiAgICBiYiA9IHZlYzIuY29tcG9uZW50cyhiKTtcXG4gICAgbiA9IDI7XFxuICAgIHJ0ID0gdmVjMi5mcm9tQ29tcG9uZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGJiID0gYjtcXG4gICAgbiA9IGIubGVuZ3RoID8/IDA7XFxuICAgIHJ0ID0gdiA9PiB2O1xcbiAgfVxcbiAgaWYgKGEubiAhPT0gbikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgcmVzdWx0LnB1c2goX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgYmIpKTtcXG4gIH1cXG4gIHJldHVybiBydChyZXN1bHQpO1xcbn1cXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgX3ZlY190aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gfGF8IG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5kZXQgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGlmIChhLm0gPT09IDEpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcXG4gIH1cXG4gIGlmIChhLm0gPT09IDIpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcXG4gIH1cXG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgdG90YWwgKz0gc2lnbiAqIGEuZW50cmllc1tqIC0gMV0gKiBtYXQuZGV0KG1hdC5taW5vcihhLCAxLCBqKSk7XFxuICAgIHNpZ24gKj0gLTE7XFxuICB9XFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gXmEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0Lm5vciA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYWRqdWdhdGUgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcXG4gKi9cXG5tYXQuYWRqID0gYSA9PiB7XFxuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcXG4gICAgfVxcbiAgfVxcbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XFxuICByZXR1cm4gbWF0LnRyYW5zKGNvZmFjdG9ycyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0geyB2ZWMyLCB2ZWMzLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcmxlL2RlY29kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZmFzdC1ybGUvZGVjb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCJjb25zdCBkZWNvZGUgPSBudW1zID0+IHtcXG4gIGNvbnN0IGRlY29kZWQgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkgKz0gMikge1xcbiAgICBjb25zdCBydW5fbGVuZ3RoID0gbnVtc1tpXTtcXG4gICAgY29uc3QgdmFsdWUgPSBudW1zW2kgKyAxXTtcXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJ1bl9sZW5ndGg7IGlpKyspIHtcXG4gICAgICBkZWNvZGVkLnB1c2godmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZGVjb2RlZDtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vbm9kZV9tb2R1bGVzL2Zhc3QtcmxlL2RlY29kZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2xydV9tYXAvZGlzdC9scnUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9scnVfbWFwL2Rpc3QvbHJ1LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIiFmdW5jdGlvbihnLGMpeyB0cnVlP2MoZXhwb3J0cyk6MH0odGhpcyxmdW5jdGlvbihnKXtjb25zdCBjPVN5bWJvbChcXFwibmV3ZXJcXFwiKSxlPVN5bWJvbChcXFwib2xkZXJcXFwiKTtjbGFzcyBue2NvbnN0cnVjdG9yKGEsYil7dHlwZW9mIGEhPT1cXFwibnVtYmVyXFxcIiYmKGI9YSxhPTApLHRoaXMuc2l6ZT0wLHRoaXMubGltaXQ9YSx0aGlzLm9sZGVzdD10aGlzLm5ld2VzdD12b2lkIDAsdGhpcy5fa2V5bWFwPW5ldyBNYXAoKSxiJiYodGhpcy5hc3NpZ24oYiksYTwxJiYodGhpcy5saW1pdD10aGlzLnNpemUpKX1fbWFya0VudHJ5QXNVc2VkKGEpe2lmKGE9PT10aGlzLm5ld2VzdClyZXR1cm47YVtjXSYmKGE9PT10aGlzLm9sZGVzdCYmKHRoaXMub2xkZXN0PWFbY10pLGFbY11bZV09YVtlXSksYVtlXSYmKGFbZV1bY109YVtjXSksYVtjXT12b2lkIDAsYVtlXT10aGlzLm5ld2VzdCx0aGlzLm5ld2VzdCYmKHRoaXMubmV3ZXN0W2NdPWEpLHRoaXMubmV3ZXN0PWF9YXNzaWduKGEpe2xldCBiLGQ9dGhpcy5saW1pdHx8TnVtYmVyLk1BWF9WQUxVRTt0aGlzLl9rZXltYXAuY2xlYXIoKTtsZXQgbT1hW1N5bWJvbC5pdGVyYXRvcl0oKTtmb3IobGV0IGg9bS5uZXh0KCk7IWguZG9uZTtoPW0ubmV4dCgpKXtsZXQgZj1uZXcgbChoLnZhbHVlWzBdLGgudmFsdWVbMV0pO3RoaXMuX2tleW1hcC5zZXQoZi5rZXksZiksYj8oYltjXT1mLGZbZV09Yik6dGhpcy5vbGRlc3Q9ZixiPWY7aWYoZC0tPT0wKXRocm93IG5ldyBFcnJvcihcXFwib3ZlcmZsb3dcXFwiKX10aGlzLm5ld2VzdD1iLHRoaXMuc2l6ZT10aGlzLl9rZXltYXAuc2l6ZX1nZXQoYSl7dmFyIGI9dGhpcy5fa2V5bWFwLmdldChhKTtyZXR1cm4gYj8odGhpcy5fbWFya0VudHJ5QXNVc2VkKGIpLGIudmFsdWUpOnZvaWQgMH1zZXQoYSxiKXt2YXIgZD10aGlzLl9rZXltYXAuZ2V0KGEpO3JldHVybiBkPyhkLnZhbHVlPWIsdGhpcy5fbWFya0VudHJ5QXNVc2VkKGQpLHRoaXMpOih0aGlzLl9rZXltYXAuc2V0KGEsZD1uZXcgbChhLGIpKSx0aGlzLm5ld2VzdD8odGhpcy5uZXdlc3RbY109ZCxkW2VdPXRoaXMubmV3ZXN0KTp0aGlzLm9sZGVzdD1kLHRoaXMubmV3ZXN0PWQsKyt0aGlzLnNpemUsdGhpcy5zaXplPnRoaXMubGltaXQmJnRoaXMuc2hpZnQoKSx0aGlzKX1zaGlmdCgpe3ZhciBhPXRoaXMub2xkZXN0O2lmKGEpcmV0dXJuIHRoaXMub2xkZXN0W2NdPyh0aGlzLm9sZGVzdD10aGlzLm9sZGVzdFtjXSx0aGlzLm9sZGVzdFtlXT12b2lkIDApOih0aGlzLm9sZGVzdD12b2lkIDAsdGhpcy5uZXdlc3Q9dm9pZCAwKSxhW2NdPWFbZV09dm9pZCAwLHRoaXMuX2tleW1hcC5kZWxldGUoYS5rZXkpLC0tdGhpcy5zaXplLFthLmtleSxhLnZhbHVlXX1maW5kKGEpe2xldCBiPXRoaXMuX2tleW1hcC5nZXQoYSk7cmV0dXJuIGI/Yi52YWx1ZTp2b2lkIDB9aGFzKGEpe3JldHVybiB0aGlzLl9rZXltYXAuaGFzKGEpfWRlbGV0ZShhKXt2YXIgYj10aGlzLl9rZXltYXAuZ2V0KGEpO3JldHVybiBiPyh0aGlzLl9rZXltYXAuZGVsZXRlKGIua2V5KSxiW2NdJiZiW2VdPyhiW2VdW2NdPWJbY10sYltjXVtlXT1iW2VdKTpiW2NdPyhiW2NdW2VdPXZvaWQgMCx0aGlzLm9sZGVzdD1iW2NdKTpiW2VdPyhiW2VdW2NdPXZvaWQgMCx0aGlzLm5ld2VzdD1iW2VdKTp0aGlzLm9sZGVzdD10aGlzLm5ld2VzdD12b2lkIDAsdGhpcy5zaXplLS0sYi52YWx1ZSk6dm9pZCAwfWNsZWFyKCl7dGhpcy5vbGRlc3Q9dGhpcy5uZXdlc3Q9dm9pZCAwLHRoaXMuc2l6ZT0wLHRoaXMuX2tleW1hcC5jbGVhcigpfWtleXMoKXtyZXR1cm4gbmV3IGoodGhpcy5vbGRlc3QpfXZhbHVlcygpe3JldHVybiBuZXcgayh0aGlzLm9sZGVzdCl9ZW50cmllcygpe3JldHVybiB0aGlzfVtTeW1ib2wuaXRlcmF0b3JdKCl7cmV0dXJuIG5ldyBpKHRoaXMub2xkZXN0KX1mb3JFYWNoKGEsYil7dHlwZW9mIGIhPT1cXFwib2JqZWN0XFxcIiYmKGI9dGhpcyk7bGV0IGQ9dGhpcy5vbGRlc3Q7Zm9yKDtkOylhLmNhbGwoYixkLnZhbHVlLGQua2V5LHRoaXMpLGQ9ZFtjXX10b0pTT04oKXtmb3IodmFyIGE9bmV3IEFycmF5KHRoaXMuc2l6ZSksYj0wLGQ9dGhpcy5vbGRlc3Q7ZDspYVtiKytdPXtrZXk6ZC5rZXksdmFsdWU6ZC52YWx1ZX0sZD1kW2NdO3JldHVybiBhfXRvU3RyaW5nKCl7Zm9yKHZhciBhPVxcXCJcXFwiLGI9dGhpcy5vbGRlc3Q7YjspYSs9U3RyaW5nKGIua2V5KStcXFwiOlxcXCIrYi52YWx1ZSxiPWJbY10sYiYmKGErPVxcXCIgPCBcXFwiKTtyZXR1cm4gYX19Zy5MUlVNYXA9bjtmdW5jdGlvbiBsKGEsYil7dGhpcy5rZXk9YSx0aGlzLnZhbHVlPWIsdGhpc1tjXT12b2lkIDAsdGhpc1tlXT12b2lkIDB9ZnVuY3Rpb24gaShhKXt0aGlzLmVudHJ5PWF9aS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxpLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7bGV0IGE9dGhpcy5lbnRyeTtyZXR1cm4gYT8odGhpcy5lbnRyeT1hW2NdLHtkb25lOiExLHZhbHVlOlthLmtleSxhLnZhbHVlXX0pOntkb25lOiEwLHZhbHVlOnZvaWQgMH19O2Z1bmN0aW9uIGooYSl7dGhpcy5lbnRyeT1hfWoucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sai5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2xldCBhPXRoaXMuZW50cnk7cmV0dXJuIGE/KHRoaXMuZW50cnk9YVtjXSx7ZG9uZTohMSx2YWx1ZTphLmtleX0pOntkb25lOiEwLHZhbHVlOnZvaWQgMH19O2Z1bmN0aW9uIGsoYSl7dGhpcy5lbnRyeT1hfWsucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30say5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2xldCBhPXRoaXMuZW50cnk7cmV0dXJuIGE/KHRoaXMuZW50cnk9YVtjXSx7ZG9uZTohMSx2YWx1ZTphLnZhbHVlfSk6e2RvbmU6ITAsdmFsdWU6dm9pZCAwfX19KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUuanMubWFwXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAvLi9ub2RlX21vZHVsZXMvbHJ1X21hcC9kaXN0L2xydS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vYml0bWFwLWRlY29tcG9zZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9iaXRtYXAtZGVjb21wb3NlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYml0bWFwVG9SZWN0YW5nbGVzID0gdm9pZCAwO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxuZnVuY3Rpb24gYml0bWFwVG9SZWN0YW5nbGVzKGJpdG1hcCkge1xcbiAgICBjb25zdCByZWN0YW5nbGVzID0gW107XFxuICAgIC8vIFN0ZXAgMSAtIGNyZWF0ZSAxLXVuaXQgdGFsbCByZWN0YW5nbGVzIGZvciBlYWNoIHJvd1xcbiAgICBmb3IgKGNvbnN0IFt5LCByb3ddIG9mIGJpdG1hcC5lbnRyaWVzKCkpIHtcXG4gICAgICAgIGxldCBjdXJyZW50UmVjdGFuZ2xlID0gbnVsbDtcXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93Lmxlbmd0aDsgeCsrKSB7XFxuICAgICAgICAgICAgaWYgKHJvd1t4XSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRSZWN0YW5nbGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN0YW5nbGUgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMyKSh4LCB5KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMikoMSwgMSksXFxuICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3RhbmdsZS5zaXplLngrKztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZWN0YW5nbGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZXMucHVzaChjdXJyZW50UmVjdGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWN0YW5nbGUgPSBudWxsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8vIFN0ZXAgMiAtIGV4dGVuZCBlYWNoIHJlY3RhbmdsZSBkb3dud2FyZHMgaWYgcG9zc2libGVcXG4gICAgbGV0IHBhaXI7XFxuICAgIHdoaWxlICgocGFpciA9IGZpbmRSZWN0YW5nbGVUb0V4dGVuZChyZWN0YW5nbGVzKSkpIHtcXG4gICAgICAgIGNvbnN0IFthLCBiXSA9IHBhaXI7XFxuICAgICAgICByZWN0YW5nbGVzLnNwbGljZShpbmRleE9mKGIsIHJlY3RhbmdsZXMpLCAxLCAuLi5jaG9wUmVjdGFuZ2xlKGIsIGEpKTtcXG4gICAgICAgIGEuc2l6ZS55ICs9IGIuc2l6ZS55O1xcbiAgICB9XFxuICAgIHJldHVybiByZWN0YW5nbGVzO1xcbn1cXG5leHBvcnRzLmJpdG1hcFRvUmVjdGFuZ2xlcyA9IGJpdG1hcFRvUmVjdGFuZ2xlcztcXG4vKipcXG4gKiBHZXQgdGhlIGluZGV4IG9mIHJlY3RhbmdsZSBhIGluIGEgbGlzdCBvZiByZWN0YW5nbGVzXFxuICovXFxuZnVuY3Rpb24gaW5kZXhPZihhLCByZWN0YW5nbGVzKSB7XFxuICAgIHJldHVybiByZWN0YW5nbGVzLmZpbmRJbmRleChiID0+IHZlY18xLnZlYzIuZXEoYS5wb3NpdGlvbiwgYi5wb3NpdGlvbikgJiYgdmVjXzEudmVjMi5lcShhLnNpemUsIGIuc2l6ZSkpO1xcbn1cXG4vKipcXG4gKiBGaW5kIGEgcGFpciBvZiByZWN0YW5nbGVzIHdoZXJlIHRoZSBmaXJzdCBvbmUgY2FuIGJlIGV4dGVuZGVkIGludG8gdGhlXFxuICogc2Vjb25kIG9uZVxcbiAqXFxuICogSWYgbm8gc3VjaCBwYWlyIGV4aXN0cywgcmV0dXJuIG51bGxcXG4gKi9cXG5mdW5jdGlvbiBmaW5kUmVjdGFuZ2xlVG9FeHRlbmQocmVjdGFuZ2xlcykge1xcbiAgICBmb3IgKGNvbnN0IGEgb2YgcmVjdGFuZ2xlcykge1xcbiAgICAgICAgY29uc3QgYiA9IGZpbmRSZWN0YW5nbGVUb0V4dGVuZEludG8oYSwgcmVjdGFuZ2xlcyk7XFxuICAgICAgICBpZiAoYikge1xcbiAgICAgICAgICAgIHJldHVybiBbYSwgYl07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxufVxcbi8qKlxcbiAqIEZpbmQgYSByZWN0YW5nbGUgd2hpY2ggcmVjdGFuZ2xlIGEgY2FuIGV4dGVuZCBpbnRvLCBvciBudWxsIGlmIG5vbmUgY2FuIGJlXFxuICogZm91bmRcXG4gKlxcbiAqIEEgcmVjdGFuZ2xlIGNhbiBleHRlbmQgaW50byBhbm90aGVyIG9uZSBpZiB0aGUgb3RoZXIgb25lIGlzIGV4YWN0bHkgYmVsb3dcXG4gKiBhbmQgdGhlaXIgeC1heGlzIHByb2plY3Rpb25zIG92ZXJsYXBcXG4gKi9cXG5mdW5jdGlvbiBmaW5kUmVjdGFuZ2xlVG9FeHRlbmRJbnRvKGEsIHJlY3RhbmdsZXMpIHtcXG4gICAgdmFyIF9hO1xcbiAgICByZXR1cm4gKChfYSA9IHJlY3RhbmdsZXMuZmluZChvdGhlciA9PiBcXG4gICAgLy8gVGhlIG90aGVyIHJlY3RhbmdsZSBpcyBleGFjdGx5IGJlbG93IHRoZSBjdXJyZW50IG9uZVxcbiAgICBvdGhlci5wb3NpdGlvbi55ID09PSBhLnBvc2l0aW9uLnkgKyBhLnNpemUueSAmJlxcbiAgICAgICAgLy8gVGhlIG90aGVyIHJlY3RhbmdsZSBzdGFydHMgYmVmb3JlIChvciBhdCkgdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IG9uZVxcbiAgICAgICAgb3RoZXIucG9zaXRpb24ueCA8PSBhLnBvc2l0aW9uLnggJiZcXG4gICAgICAgIC8vIFRoZSBvdGhlciByZWN0YW5nbGUgZW5kcyBhZnRlciAob3IgYXQpIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgb25lXFxuICAgICAgICBvdGhlci5wb3NpdGlvbi54ICsgb3RoZXIuc2l6ZS54ID49IGEucG9zaXRpb24ueCArIGEuc2l6ZS54KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XFxufVxcbi8qKlxcbiAqIFN1YnRyYWN0IHJlY3RhbmdsZSBiIGZyb20gcmVjdGFuZ2xlIGEsIGlnbm9yaW5nIGhlaWdodCAoaS5lLiBvbmx5IGluIHRoZVxcbiAqIHgtYXhpcykgYW5kIHJldHVybiAwLCAxIG9yIDIgcmVzdWx0aW5nIHJlY3RhbmdsZXNcXG4gKi9cXG5mdW5jdGlvbiBjaG9wUmVjdGFuZ2xlKGEsIGIpIHtcXG4gICAgY29uc3QgcmVzdWx0ID0gW107XFxuICAgIGlmIChiLnBvc2l0aW9uLnggPiBhLnBvc2l0aW9uLngpIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYzIpKGEucG9zaXRpb24ueCwgYS5wb3NpdGlvbi55KSxcXG4gICAgICAgICAgICBzaXplOiAoMCwgdmVjXzEudmVjMikoYi5wb3NpdGlvbi54IC0gYS5wb3NpdGlvbi54LCBhLnNpemUueSksXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAoYi5wb3NpdGlvbi54ICsgYi5zaXplLnggPCBhLnBvc2l0aW9uLnggKyBhLnNpemUueCkge1xcbiAgICAgICAgcmVzdWx0LnB1c2goe1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjMikoYi5wb3NpdGlvbi54ICsgYi5zaXplLngsIGEucG9zaXRpb24ueSksXFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKGEucG9zaXRpb24ueCArIGEuc2l6ZS54IC0gKGIucG9zaXRpb24ueCArIGIuc2l6ZS54KSwgYS5zaXplLnkpLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAvLi9iaXRtYXAtZGVjb21wb3NlLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcXFwiZGVmYXVsdFxcXCI6IG1vZCB9O1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yID0gZXhwb3J0cy5UaWxlTWFwID0gZXhwb3J0cy5jYW1lcmFCb3VuZHNTaXplID0gZXhwb3J0cy5jYW1lcmFCb3VuZHNUb1RpbGVNYXBCb3VuZHMgPSBleHBvcnRzLlRpbGVBbGlnbm1lbnQgPSB2b2lkIDA7XFxuY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxuY29uc3QgZGVjb2RlXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZmFzdC1ybGUvZGVjb2RlICovIFxcXCIuL25vZGVfbW9kdWxlcy9mYXN0LXJsZS9kZWNvZGUuanNcXFwiKSk7XFxuY29uc3QgbHJ1X21hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbHJ1X21hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvbHJ1X21hcC9kaXN0L2xydS5qc1xcXCIpO1xcbmNvbnN0IGJpdG1hcF9kZWNvbXBvc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYml0bWFwLWRlY29tcG9zZSAqLyBcXFwiLi9iaXRtYXAtZGVjb21wb3NlLnRzXFxcIik7XFxudmFyIFRpbGVBbGlnbm1lbnQ7XFxuKGZ1bmN0aW9uIChUaWxlQWxpZ25tZW50KSB7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIlRvcExlZnRcXFwiXSA9IFxcXCJ0b3AtbGVmdFxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIlRvcFxcXCJdID0gXFxcInRvcFxcXCI7XFxuICAgIFRpbGVBbGlnbm1lbnRbXFxcIlRvcFJpZ2h0XFxcIl0gPSBcXFwidG9wLXJpZ2h0XFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiTGVmdFxcXCJdID0gXFxcImxlZnRcXFwiO1xcbiAgICBUaWxlQWxpZ25tZW50W1xcXCJDZW50ZXJcXFwiXSA9IFxcXCJjZW50ZXJcXFwiO1xcbiAgICBUaWxlQWxpZ25tZW50W1xcXCJSaWdodFxcXCJdID0gXFxcInJpZ2h0XFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiQm90dG9tTGVmdFxcXCJdID0gXFxcImJvdHRvbS1sZWZ0XFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiQm90dG9tXFxcIl0gPSBcXFwiYm90dG9tXFxcIjtcXG4gICAgVGlsZUFsaWdubWVudFtcXFwiQm90dG9tUmlnaHRcXFwiXSA9IFxcXCJib3R0b20tcmlnaHRcXFwiO1xcbn0pKFRpbGVBbGlnbm1lbnQgPSBleHBvcnRzLlRpbGVBbGlnbm1lbnQgfHwgKGV4cG9ydHMuVGlsZUFsaWdubWVudCA9IHt9KSk7XFxuZnVuY3Rpb24gcG9pbnRJblJlY3RhbmdsZShwb2ludCwgdG9wTGVmdCwgYm90dG9tUmlnaHQpIHtcXG4gICAgcmV0dXJuIChwb2ludC54ID49IHRvcExlZnQueCAmJlxcbiAgICAgICAgcG9pbnQueSA+PSB0b3BMZWZ0LnkgJiZcXG4gICAgICAgIHBvaW50LnggPCBib3R0b21SaWdodC54ICYmXFxuICAgICAgICBwb2ludC55IDwgYm90dG9tUmlnaHQueSk7XFxufVxcbmZ1bmN0aW9uIGNhbWVyYUJvdW5kc1RvVGlsZU1hcEJvdW5kcyhib3VuZHMpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIHRvcExlZnQ6ICgwLCB2ZWNfMS52ZWMyKShib3VuZHMubGVmdCwgYm91bmRzLnRvcCksXFxuICAgICAgICBib3R0b21SaWdodDogKDAsIHZlY18xLnZlYzIpKGJvdW5kcy5yaWdodCwgYm91bmRzLmJvdHRvbSksXFxuICAgIH07XFxufVxcbmV4cG9ydHMuY2FtZXJhQm91bmRzVG9UaWxlTWFwQm91bmRzID0gY2FtZXJhQm91bmRzVG9UaWxlTWFwQm91bmRzO1xcbmZ1bmN0aW9uIGNhbWVyYUJvdW5kc1NpemUoYm91bmRzKSB7XFxuICAgIGNvbnN0IGNvbnZlcnRlZEJvdW5kcyA9IGNhbWVyYUJvdW5kc1RvVGlsZU1hcEJvdW5kcyhib3VuZHMpO1xcbiAgICByZXR1cm4gdmVjXzEudmVjMi5zdWIoY29udmVydGVkQm91bmRzLmJvdHRvbVJpZ2h0LCBjb252ZXJ0ZWRCb3VuZHMudG9wTGVmdCk7XFxufVxcbmV4cG9ydHMuY2FtZXJhQm91bmRzU2l6ZSA9IGNhbWVyYUJvdW5kc1NpemU7XFxuY2xhc3MgVGlsZU1hcCB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBUaWxlTWFwLkRFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICAgICAgZm9yIChjb25zdCBbaSwgbGF5ZXJdIG9mIGFjdHVhbE9wdGlvbnMubGF5ZXJzLmVudHJpZXMoKSkge1xcbiAgICAgICAgICAgIGFjdHVhbE9wdGlvbnMubGF5ZXJzW2ldID0gT2JqZWN0LmFzc2lnbih7fSwgVGlsZU1hcC5ERUZBVUxUX0xBWUVSX09QVElPTlMsIGxheWVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghYWN0dWFsT3B0aW9ucy5kZWJ1ZyB8fCBhY3R1YWxPcHRpb25zLmRlYnVnID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgYWN0dWFsT3B0aW9ucy5kZWJ1ZyA9IHtcXG4gICAgICAgICAgICAgICAgc2hvd09yaWdpbjogISFhY3R1YWxPcHRpb25zLmRlYnVnLFxcbiAgICAgICAgICAgICAgICBzaG93Q2h1bmtCb3JkZXJzOiAhIWFjdHVhbE9wdGlvbnMuZGVidWcsXFxuICAgICAgICAgICAgICAgIHNob3dDaHVua0xhYmVsczogISFhY3R1YWxPcHRpb25zLmRlYnVnLFxcbiAgICAgICAgICAgICAgICBzaG93VGlsZUJvcmRlcnM6ICEhYWN0dWFsT3B0aW9ucy5kZWJ1ZyxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYWN0dWFsT3B0aW9ucztcXG4gICAgICAgIHRoaXMuY2h1bmtCdWZmZXIgPSBuZXcgbHJ1X21hcF8xLkxSVU1hcCh0aGlzLm9wdGlvbnMuY2h1bmtCdWZmZXJNYXhTaXplKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0IGEgKHJvdWdobHkgbWluaW1hbCkgc2V0IG9mIHJlY3RhbmdsZXMgd2hpY2ggY292ZXIgdGhlIHRpbGVzIGluIGFcXG4gICAgICogZ2l2ZW4gbGF5ZXJcXG4gICAgICpcXG4gICAgICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgdG8gZ2V0IHJlY3RhbmdsZXMgZm9yXFxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWUgV2Ugd2lsbCBjaGVjayB0aGUgdHJ1dGh5bmVzcyBvZiB0aGlzIGZpZWxkIGluIHRoZVxcbiAgICAgKiB0aWxlIGRlZmluaXRpb25cXG4gICAgICogQHBhcmFtIHRpbGVCb3VuZHMgT3B0aW9uYWwgYm91bmRzIHRvIGNoZWNrIHdpdGhpbiwgcmVsYXRpdmUgdG8gYm91bmRzXFxuICAgICAqIGRlZmluZWQgaW4gb3B0aW9ucyBpZiBhbnkgZXhpc3QsIG90aGVyd2lzZSByZWxhdGl2ZSB0byAoMCwgMClcXG4gICAgICovXFxuICAgIGdldExheWVyUmVjdGFuZ2xlcyhsYXllck5hbWUsIGZpZWxkTmFtZSwgdGlsZUJvdW5kcykge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XFxuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMub3B0aW9ucy5sYXllcnMuZmluZChsID0+IGwubmFtZSA9PT0gbGF5ZXJOYW1lKTtcXG4gICAgICAgIGlmICghbGF5ZXIpIHtcXG4gICAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gKF9hID0gdGlsZUJvdW5kcyA9PT0gbnVsbCB8fCB0aWxlQm91bmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlQm91bmRzLnRvcExlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgwLCB2ZWNfMS52ZWMyKSgwKTtcXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gKF9iID0gdGlsZUJvdW5kcyA9PT0gbnVsbCB8fCB0aWxlQm91bmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlQm91bmRzLmJvdHRvbVJpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoMCwgdmVjXzEudmVjMikoTWF0aC5tYXgoLi4uKChfZCA9IChfYyA9IGxheWVyLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAocm93ID0+IHJvdy5sZW5ndGgpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbMF0pKSwgKF9mID0gKF9lID0gbGF5ZXIuZGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMCk7XFxuICAgICAgICBpZiAoYm90dG9tUmlnaHQueCA8PSB0b3BMZWZ0LnggfHwgYm90dG9tUmlnaHQueSA8PSB0b3BMZWZ0LnkpIHtcXG4gICAgICAgICAgICByZXR1cm4gW107XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBiaXRtYXAgPSBbXTtcXG4gICAgICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0Lnk7IHkgPCBib3R0b21SaWdodC55OyB5KyspIHtcXG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gdG9wTGVmdC54OyB4IDwgYm90dG9tUmlnaHQueDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVEYXRhID0gKF9oID0gKF9nID0gbGF5ZXIuZGF0YSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nW3ldKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hbeF07XFxuICAgICAgICAgICAgICAgIGlmICh0aWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHRpbGVEYXRhID09PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc3QgdGlsZSA9IChfaiA9IGxheWVyLnRpbGVzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2pbdGlsZURhdGFdO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgJiYgIXRpbGVbZmllbGROYW1lXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcm93LnB1c2godHJ1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGJpdG1hcC5wdXNoKHJvdyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKDAsIGJpdG1hcF9kZWNvbXBvc2VfMS5iaXRtYXBUb1JlY3RhbmdsZXMpKGJpdG1hcCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgdGlsZSBhdCBhIGdpdmVuIHBvc2l0aW9uIGFuZCBpbiB0aGUgc3BlY2lmaWVkIGxheWVyXFxuICAgICAqXFxuICAgICAqIElmIG5vIGxheWVyIGlzIHNwZWNpZmllZCwgcmV0dXJuIGEgZGljdGlvbmFyeSBvZiBsYXllciBuYW1lcyB0byB0aWxlXFxuICAgICAqIGRlZmluaXRpb25zIChpLmUuIHJldHVybiBhbGwgbGF5ZXJzKVxcbiAgICAgKlxcbiAgICAgKiBJZiBubyB0aWxlIGV4aXN0cyBhdCB0aGlzIHBvc2l0aW9uLCByZXR1cm4gbnVsbFxcbiAgICAgKi9cXG4gICAgZ2V0VGlsZUF0UG9zaXRpb24ocG9zaXRpb24sIGxheWVyTmFtZSkge1xcbiAgICAgICAgaWYgKGxheWVyTmFtZSkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVBdFBvc2l0aW9uSW5MYXllcihwb3NpdGlvbiwgbGF5ZXJOYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLm9wdGlvbnMubGF5ZXJzKSB7XFxuICAgICAgICAgICAgcmVzdWx0W2xheWVyLm5hbWVdID0gdGhpcy5nZXRUaWxlQXRQb3NpdGlvbkluTGF5ZXIocG9zaXRpb24sIGxheWVyLm5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgICBnZXRUaWxlQXRQb3NpdGlvbkluTGF5ZXIocG9zaXRpb24sIGxheWVyTmFtZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XFxuICAgICAgICBjb25zdCB0aWxlUG9zaXRpb24gPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChwb3NpdGlvbiwgMSAvIHRoaXMub3B0aW9ucy50aWxlU2l6ZSksIE1hdGguZmxvb3IpO1xcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLm9wdGlvbnMubGF5ZXJzLmZpbmQobCA9PiBsLm5hbWUgPT09IGxheWVyTmFtZSk7XFxuICAgICAgICBpZiAoIWxheWVyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB0aWxlRGF0YSA9IChfYiA9IChfYSA9IGxheWVyLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0aWxlUG9zaXRpb24ueV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlt0aWxlUG9zaXRpb24ueF07XFxuICAgICAgICBpZiAodGlsZURhdGEgPT09IHVuZGVmaW5lZCB8fCB0aWxlRGF0YSA9PT0gLTEpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsYXllci50aWxlcykge1xcbiAgICAgICAgICAgIHJldHVybiAoX2MgPSBsYXllci50aWxlc1t0aWxlRGF0YV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBoYXNoVmVjdG9yKHYpIHtcXG4gICAgICAgIHJldHVybiB2ZWNfMS52ZWMyLnN0cih2KTtcXG4gICAgfVxcbiAgICBkcmF3KGNvbnRleHQsIGEsIGIsIGMpIHtcXG4gICAgICAgIGlmIChiICYmIGMpIHtcXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1EcmF3KGNvbnRleHQsIGEsIGIsIGMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuID0gY2FtZXJhQm91bmRzU2l6ZShhLmJvdW5kcyk7XFxuICAgICAgICAgICAgdGhpcy5wZXJmb3JtRHJhdyhjb250ZXh0LCBzY3JlZW4sIGEuYWN0dWFsUG9zaXRpb24sIGEuYWN0dWFsU2NhbGUsIGZhbHNlKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBwZXJmb3JtRHJhdyhjb250ZXh0LCBzY3JlZW4sIHBvc2l0aW9uLCBzY2FsZSwgZG9UcmFuc2Zvcm1zID0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xcbiAgICAgICAgY29uc3QgYWJzb2x1dGVDaHVua1NpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUgKiB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xcbiAgICAgICAgY29uc3QgY2h1bmtCb3JkZXIgPSAoMCwgdmVjXzEudmVjMikodGhpcy5vcHRpb25zLmNodW5rQm9yZGVyKTtcXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHNjYWxlXFxuICAgICAgICBsZXQgYWN0dWFsU2NhbGUgPSBzY2FsZTtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluU2NhbGUgJiYgYWN0dWFsU2NhbGUgPCB0aGlzLm9wdGlvbnMubWluU2NhbGUpIHtcXG4gICAgICAgICAgICBhY3R1YWxTY2FsZSA9IHRoaXMub3B0aW9ucy5taW5TY2FsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4U2NhbGUgJiYgYWN0dWFsU2NhbGUgPiB0aGlzLm9wdGlvbnMubWF4U2NhbGUpIHtcXG4gICAgICAgICAgICBhY3R1YWxTY2FsZSA9IHRoaXMub3B0aW9ucy5tYXhTY2FsZTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIE1heWJlIGNsYW1wIHBvc2l0aW9uIHRvIGJvdW5kc1xcbiAgICAgICAgbGV0IGFjdHVhbFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKHBvc2l0aW9uKTtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzICYmIHRoaXMub3B0aW9ucy5jbGFtcFBvc2l0aW9uVG9Cb3VuZHMpIHtcXG4gICAgICAgICAgICBjb25zdCB0aWxlU2l6ZVNjYWxlZCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIGFjdHVhbFNjYWxlO1xcbiAgICAgICAgICAgIGNvbnN0IGhhbGZTY3JlZW5TY2FsZWQgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChzY3JlZW4sIDEgLyAoYWN0dWFsU2NhbGUgKiAyKSksIE1hdGguY2VpbCk7XFxuICAgICAgICAgICAgY29uc3QgbWluUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikodGhpcy5vcHRpb25zLmJvdW5kcy50b3BMZWZ0LnggKiB0aWxlU2l6ZVNjYWxlZCArIGhhbGZTY3JlZW5TY2FsZWQueCwgdGhpcy5vcHRpb25zLmJvdW5kcy50b3BMZWZ0LnkgKiB0aWxlU2l6ZVNjYWxlZCArIGhhbGZTY3JlZW5TY2FsZWQueSk7XFxuICAgICAgICAgICAgY29uc3QgbWF4UG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikodGhpcy5vcHRpb25zLmJvdW5kcy5ib3R0b21SaWdodC54ICogdGlsZVNpemVTY2FsZWQgLSBoYWxmU2NyZWVuU2NhbGVkLngsIHRoaXMub3B0aW9ucy5ib3VuZHMuYm90dG9tUmlnaHQueSAqIHRpbGVTaXplU2NhbGVkIC0gaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICBhY3R1YWxQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSgoMCwgdXRpbHNfMS5jbGFtcCkoYWN0dWFsUG9zaXRpb24ueCwgbWluUG9zaXRpb24ueCwgbWF4UG9zaXRpb24ueCksICgwLCB1dGlsc18xLmNsYW1wKShhY3R1YWxQb3NpdGlvbi55LCBtaW5Qb3NpdGlvbi55LCBtYXhQb3NpdGlvbi55KSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBzY3JlZW5TaXplSW5DaHVua3MgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChzY3JlZW4sIDEgLyAoYWJzb2x1dGVDaHVua1NpemUgKiBhY3R1YWxTY2FsZSkpLCBNYXRoLmNlaWwpO1xcbiAgICAgICAgY29uc3Qgc2NyZWVuQ2VudGVyQ2h1bmsgPSB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChhY3R1YWxQb3NpdGlvbiwgMSAvIGFic29sdXRlQ2h1bmtTaXplKSwgTWF0aC5mbG9vcik7XFxuICAgICAgICBjb25zdCB0b3BMZWZ0Q2h1bmsgPSB2ZWNfMS52ZWMyLnN1Yih2ZWNfMS52ZWMyLnN1YihzY3JlZW5DZW50ZXJDaHVuaywgdmVjXzEudmVjMi5tYXAodmVjXzEudmVjMi5tdWwoc2NyZWVuU2l6ZUluQ2h1bmtzLCAwLjUpLCBNYXRoLmNlaWwpKSwgY2h1bmtCb3JkZXIpO1xcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHRDaHVuayA9IHZlY18xLnZlYzIuYWRkKHZlY18xLnZlYzIuYWRkKHNjcmVlbkNlbnRlckNodW5rLCB2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChzY3JlZW5TaXplSW5DaHVua3MsIDAuNSksIE1hdGguY2VpbCkpLCBjaHVua0JvcmRlcik7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGlmIChkb1RyYW5zZm9ybXMpIHtcXG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKGFjdHVhbFNjYWxlLCBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWFjdHVhbFBvc2l0aW9uLnggKyBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCAtYWN0dWFsUG9zaXRpb24ueSArIHNjcmVlbi55IC8gKGFjdHVhbFNjYWxlICogMikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5wcmVSZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBjb250ZXh0LCB0aGlzLCBzY3JlZW4sIGFjdHVhbFBvc2l0aW9uLCBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAvLyBSZW5kZXIgY2h1bmtzXFxuICAgICAgICBmb3IgKGxldCB5ID0gdG9wTGVmdENodW5rLnk7IHkgPCBib3R0b21SaWdodENodW5rLnk7IHkrKykge1xcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0Q2h1bmsueDsgeCA8IGJvdHRvbVJpZ2h0Q2h1bmsueDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoeCwgeSk7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQWJzb2x1dGVQb3NpdGlvbiA9IHZlY18xLnZlYzIubXVsKGNodW5rUG9zaXRpb24sIGFic29sdXRlQ2h1bmtTaXplKTtcXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGlzIGNodW5rIGluIHRoZSBjYWNoZVxcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0hhc2ggPSB0aGlzLmhhc2hWZWN0b3IoY2h1bmtQb3NpdGlvbik7XFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaHVua0J1ZmZlci5oYXMoY2h1bmtIYXNoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZmZlci5zZXQoY2h1bmtIYXNoLCB0aGlzLmdlbmVyYXRlQ2h1bmsoY2h1bmtQb3NpdGlvbiwgYWJzb2x1dGVDaHVua1NpemUpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtCdWZmZXIuZ2V0KGNodW5rSGFzaCk7XFxuICAgICAgICAgICAgICAgIGlmIChjaHVuaykge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoY2h1bmsuaW1hZ2UsIGNodW5rQWJzb2x1dGVQb3NpdGlvbi54LCBjaHVua0Fic29sdXRlUG9zaXRpb24ueSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAoX2QgPSAoX2MgPSB0aGlzLm9wdGlvbnMpLnBvc3RSZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBjb250ZXh0LCB0aGlzLCBzY3JlZW4sIGFjdHVhbFBvc2l0aW9uLCBhY3R1YWxTY2FsZSk7XFxuICAgICAgICAvLyBSZW5kZXIgZGVidWcgaGVscGVyc1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zy5zaG93VGlsZUJvcmRlcnMpIHtcXG4gICAgICAgICAgICBjb25zdCB0b3BMZWZ0VGlsZSA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIuc3ViKHNjcmVlbkNlbnRlckNodW5rLCB2ZWNfMS52ZWMyLmFkZCh2ZWNfMS52ZWMyLm1hcCh2ZWNfMS52ZWMyLm11bChzY3JlZW5TaXplSW5DaHVua3MsIDAuNSksIE1hdGguY2VpbCksICgwLCB2ZWNfMS52ZWMyKSgxKSkpLCB0aGlzLm9wdGlvbnMuY2h1bmtTaXplKTtcXG4gICAgICAgICAgICBjb25zdCBib3R0b21SaWdodFRpbGUgPSB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLmFkZChzY3JlZW5DZW50ZXJDaHVuaywgdmVjXzEudmVjMi5hZGQodmVjXzEudmVjMi5tYXAodmVjXzEudmVjMi5tdWwoc2NyZWVuU2l6ZUluQ2h1bmtzLCAwLjUpLCBNYXRoLmNlaWwpLCAoMCwgdmVjXzEudmVjMikoMSkpKSwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XFxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHRvcExlZnRUaWxlLnk7IHkgPCBib3R0b21SaWdodFRpbGUueTsgeSsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoY29udGV4dCwgKDAsIHZlY18xLnZlYzIpKGFjdHVhbFBvc2l0aW9uLnggLSBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCB5ICogdGhpcy5vcHRpb25zLnRpbGVTaXplKSwgKDAsIHZlY18xLnZlYzIpKGFjdHVhbFBvc2l0aW9uLnggKyBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCB5ICogdGhpcy5vcHRpb25zLnRpbGVTaXplKSwgVGlsZU1hcC5ERUJVR19USUxFX0JPUkRFUl9DT0xPVVIsIFRpbGVNYXAuREVCVUdfVElMRV9CT1JERVJfTElORV9XSURUSCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0VGlsZS54OyB4IDwgYm90dG9tUmlnaHRUaWxlLng7IHgrKykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMaW5lKGNvbnRleHQsICgwLCB2ZWNfMS52ZWMyKSh4ICogdGhpcy5vcHRpb25zLnRpbGVTaXplLCBhY3R1YWxQb3NpdGlvbi55IC0gc2NyZWVuLnkgLyAoYWN0dWFsU2NhbGUgKiAyKSksICgwLCB2ZWNfMS52ZWMyKSh4ICogdGhpcy5vcHRpb25zLnRpbGVTaXplLCBhY3R1YWxQb3NpdGlvbi55ICsgc2NyZWVuLnkgLyAoYWN0dWFsU2NhbGUgKiAyKSksIFRpbGVNYXAuREVCVUdfVElMRV9CT1JERVJfQ09MT1VSLCBUaWxlTWFwLkRFQlVHX1RJTEVfQk9SREVSX0xJTkVfV0lEVEgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcuc2hvd0NodW5rQm9yZGVycykge1xcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSB0b3BMZWZ0Q2h1bmsueTsgeSA8IGJvdHRvbVJpZ2h0Q2h1bmsueTsgeSsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoY29udGV4dCwgKDAsIHZlY18xLnZlYzIpKGFjdHVhbFBvc2l0aW9uLnggLSBzY3JlZW4ueCAvIChhY3R1YWxTY2FsZSAqIDIpLCB5ICogYWJzb2x1dGVDaHVua1NpemUpLCAoMCwgdmVjXzEudmVjMikoYWN0dWFsUG9zaXRpb24ueCArIHNjcmVlbi54IC8gKGFjdHVhbFNjYWxlICogMiksIHkgKiBhYnNvbHV0ZUNodW5rU2l6ZSksIFRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0NPTE9VUiwgVGlsZU1hcC5ERUJVR19DSFVOS19CT1JERVJfTElORV9XSURUSCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0Q2h1bmsueDsgeCA8IGJvdHRvbVJpZ2h0Q2h1bmsueDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoY29udGV4dCwgKDAsIHZlY18xLnZlYzIpKHggKiBhYnNvbHV0ZUNodW5rU2l6ZSwgYWN0dWFsUG9zaXRpb24ueSAtIHNjcmVlbi55IC8gKGFjdHVhbFNjYWxlICogMikpLCAoMCwgdmVjXzEudmVjMikoeCAqIGFic29sdXRlQ2h1bmtTaXplLCBhY3R1YWxQb3NpdGlvbi55ICsgc2NyZWVuLnkgLyAoYWN0dWFsU2NhbGUgKiAyKSksIFRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0NPTE9VUiwgVGlsZU1hcC5ERUJVR19DSFVOS19CT1JERVJfTElORV9XSURUSCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zy5zaG93Q2h1bmtMYWJlbHMpIHtcXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFRpbGVNYXAuREVCVUdfQ0hVTktfTEFCRUxfQ09MT1VSO1xcbiAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IFRpbGVNYXAuREVCVUdfQ0hVTktfTEFCRUxfRk9OVDtcXG4gICAgICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xcbiAgICAgICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XFxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHRvcExlZnRDaHVuay55OyB5IDwgYm90dG9tUmlnaHRDaHVuay55OyB5KyspIHtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHRvcExlZnRDaHVuay54OyB4IDwgYm90dG9tUmlnaHRDaHVuay54OyB4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoYCR7eH0sICR7eX1gLCB4ICogYWJzb2x1dGVDaHVua1NpemUgKyBhYnNvbHV0ZUNodW5rU2l6ZSAvIDIsIHkgKiBhYnNvbHV0ZUNodW5rU2l6ZSArIGFic29sdXRlQ2h1bmtTaXplIC8gMik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnLnNob3dPcmlnaW4gJiZcXG4gICAgICAgICAgICBwb2ludEluUmVjdGFuZ2xlKCgwLCB2ZWNfMS52ZWMyKSgwLCAwKSwgdG9wTGVmdENodW5rLCBib3R0b21SaWdodENodW5rKSkge1xcbiAgICAgICAgICAgIHRoaXMuZHJhd0Nyb3NzKGNvbnRleHQsICgwLCB2ZWNfMS52ZWMyKSgwLCAwKSwgVGlsZU1hcC5ERUJVR19PUklHSU5fQ09MT1VSLCBUaWxlTWFwLkRFQlVHX09SSUdJTl9MSU5FX1dJRFRILCBUaWxlTWFwLkRFQlVHX09SSUdJTl9TSVpFKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGdlbmVyYXRlQ2h1bmsoY2h1bmtQb3NpdGlvbiwgYWJzb2x1dGVDaHVua1NpemUpIHtcXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xcbiAgICAgICAgY29uc3QgY2h1bmtDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgICAgIGNvbnN0IGNodW5rQ29udGV4dCA9IGNodW5rQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XFxuICAgICAgICBjaHVua0NhbnZhcy53aWR0aCA9IGFic29sdXRlQ2h1bmtTaXplO1xcbiAgICAgICAgY2h1bmtDYW52YXMuaGVpZ2h0ID0gYWJzb2x1dGVDaHVua1NpemU7XFxuICAgICAgICBsZXQgY2h1bmsgPSB7XFxuICAgICAgICAgICAgY2h1bmtQb3NpdGlvbixcXG4gICAgICAgICAgICBpbWFnZTogY2h1bmtDYW52YXMsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgdG9wTGVmdFRpbGUgPSB2ZWNfMS52ZWMyLm11bChjaHVua1Bvc2l0aW9uLCB0aGlzLm9wdGlvbnMuY2h1bmtTaXplKTtcXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0VGlsZSA9IHZlY18xLnZlYzIuYWRkKHRvcExlZnRUaWxlLCAoMCwgdmVjXzEudmVjMikodGhpcy5vcHRpb25zLmNodW5rU2l6ZSAtIDEpKTtcXG4gICAgICAgIGNvbnN0IGJvdW5kc1RvcExlZnQgPSAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuYm91bmRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9wTGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKDAsIHZlY18xLnZlYzIpKDApO1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmVHZW5lcmF0ZUNodW5rKSB7XFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vcHRpb25zLnByZUdlbmVyYXRlQ2h1bmsoY2h1bmtDb250ZXh0LCB0aGlzLCB7XFxuICAgICAgICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnRUaWxlLFxcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodDogYm90dG9tUmlnaHRUaWxlLFxcbiAgICAgICAgICAgIH0sIGNodW5rUG9zaXRpb24pO1xcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbMV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaHVuaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERlZmF1bHQgZ2VuZXJhdGlvbiwgcmVuZGVyIHRpbGVzIGZyb20gdGlsZW1hcCBkYXRhXFxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMub3B0aW9ucy5sYXllcnMpIHtcXG4gICAgICAgICAgICBjaHVua0NvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgICAgIGNodW5rQ29udGV4dC5nbG9iYWxBbHBoYSA9IChfYyA9IGxheWVyLm9wYWNpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDE7XFxuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gKF9kID0gbGF5ZXIuYWxpZ25tZW50KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBUaWxlQWxpZ25tZW50LkNlbnRlcjtcXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gdG9wTGVmdFRpbGUueTsgeSA8PSBib3R0b21SaWdodFRpbGUueTsgeSsrKSB7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSB0b3BMZWZ0VGlsZS54OyB4IDw9IGJvdHRvbVJpZ2h0VGlsZS54OyB4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh4LCB5KTtcXG4gICAgICAgICAgICAgICAgICAgIChfZSA9IGxheWVyLnByZVJlbmRlclRpbGUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKGxheWVyLCBjaHVua0NvbnRleHQsIHRoaXMsIGxheWVyLCBjaHVua1Bvc2l0aW9uLCB0aWxlUG9zaXRpb24pO1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZURhdGFQb3NpdGlvbiA9IHZlY18xLnZlYzIuc3ViKHRpbGVQb3NpdGlvbiwgYm91bmRzVG9wTGVmdCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZURhdGFQb3NpdGlvbi54IDwgMCB8fCB0aWxlRGF0YVBvc2l0aW9uLnkgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlRGF0YSA9IChfZyA9IChfZiA9IGxheWVyLmRhdGEpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlt0aWxlRGF0YVBvc2l0aW9uLnldKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbdGlsZURhdGFQb3NpdGlvbi54XTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHRpbGVEYXRhID09PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZUltYWdlID0gKF9qID0gKF9oID0gbGF5ZXIudGlsZXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaFt0aWxlRGF0YV0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5pbWFnZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlsZUltYWdlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlQWJzb2x1dGVQb3NpdGlvbiA9IHZlY18xLnZlYzIuc3ViKHZlY18xLnZlYzIubXVsKHRpbGVQb3NpdGlvbiwgdGhpcy5vcHRpb25zLnRpbGVTaXplKSwgdmVjXzEudmVjMi5tdWwoY2h1bmtQb3NpdGlvbiwgYWJzb2x1dGVDaHVua1NpemUpKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpbGUgY2xpcHBpbmdcXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5jbGlwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDb250ZXh0LnNhdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0NvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDb250ZXh0LnJlY3QodGlsZUFic29sdXRlUG9zaXRpb24ueCwgdGlsZUFic29sdXRlUG9zaXRpb24ueSwgdGhpcy5vcHRpb25zLnRpbGVTaXplLCB0aGlzLm9wdGlvbnMudGlsZVNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5jbGlwKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvLyBUaWxlIGFsaWdubWVudFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb247XFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5Ub3BMZWZ0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKHRpbGVBYnNvbHV0ZVBvc2l0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaWxlQWxpZ25tZW50LlRvcDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLndpZHRoIC8gMiwgdGlsZUFic29sdXRlUG9zaXRpb24ueSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5Ub3BSaWdodDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2Uud2lkdGgsIHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuTGVmdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54LCB0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLmhlaWdodCAvIDIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuQ2VudGVyOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uID0gKDAsIHZlY18xLnZlYzIpKHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnggK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVTaXplIC8gMiAtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2Uud2lkdGggLyAyLCB0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLmhlaWdodCAvIDIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuUmlnaHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikodGlsZUFic29sdXRlUG9zaXRpb24ueCArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGlsZVNpemUgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLndpZHRoLCB0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLmhlaWdodCAvIDIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbGVBbGlnbm1lbnQuQm90dG9tTGVmdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54LCB0aWxlQWJzb2x1dGVQb3NpdGlvbi55ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2UuaGVpZ2h0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaWxlQWxpZ25tZW50LkJvdHRvbTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAvIDIgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLndpZHRoIC8gMiwgdGlsZUFic29sdXRlUG9zaXRpb24ueSArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGlsZVNpemUgLVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlLmhlaWdodCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGlsZUFsaWdubWVudC5Cb3R0b21SaWdodDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZUltYWdlQWJzb2x1dGVQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKSh0aWxlQWJzb2x1dGVQb3NpdGlvbi54ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aWxlU2l6ZSAtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlSW1hZ2Uud2lkdGgsIHRpbGVBYnNvbHV0ZVBvc2l0aW9uLnkgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpbGVTaXplIC1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVJbWFnZS5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5kcmF3SW1hZ2UodGlsZUltYWdlLCB0aWxlSW1hZ2VBYnNvbHV0ZVBvc2l0aW9uLngsIHRpbGVJbWFnZUFic29sdXRlUG9zaXRpb24ueSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIuY2xpcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAoX2sgPSBsYXllci5wb3N0UmVuZGVyVGlsZSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmNhbGwobGF5ZXIsIGNodW5rQ2FudmFzLCBjaHVua0NvbnRleHQsIHRoaXMsIGxheWVyLCBjaHVua1Bvc2l0aW9uLCB0aWxlUG9zaXRpb24pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNodW5rQ29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICB9XFxuICAgICAgICAoX20gPSAoX2wgPSB0aGlzLm9wdGlvbnMpLnBvc3RHZW5lcmF0ZUNodW5rKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uY2FsbChfbCwgY2h1bmtDYW52YXMsIGNodW5rQ29udGV4dCwgdGhpcywge1xcbiAgICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnRUaWxlLFxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBib3R0b21SaWdodFRpbGUsXFxuICAgICAgICB9LCBjaHVua1Bvc2l0aW9uKTtcXG4gICAgICAgIHJldHVybiBjaHVuaztcXG4gICAgfVxcbiAgICBkcmF3TGluZShjb250ZXh0LCBzdGFydCwgZW5kLCBjb2xvdXIsIGxpbmVXaWR0aCkge1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XFxuICAgICAgICBjb250ZXh0LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdDcm9zcyhjb250ZXh0LCBwb3NpdGlvbiwgY29sb3VyLCBsaW5lV2lkdGgsIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IE1hdGguY2VpbChzaXplIC8gMik7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3VyO1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzLlRpbGVNYXAgPSBUaWxlTWFwO1xcblRpbGVNYXAuREVGQVVMVF9PUFRJT05TID0ge1xcbiAgICBjbGFtcFBvc2l0aW9uVG9Cb3VuZHM6IHRydWUsXFxuICAgIHRpbGVTaXplOiAxNixcXG4gICAgbGF5ZXJzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgICAgbmFtZTogJ2RlZmF1bHQnLFxcbiAgICAgICAgfSxcXG4gICAgXSxcXG4gICAgY2h1bmtTaXplOiA4LFxcbiAgICBjaHVua0JvcmRlcjogMSxcXG4gICAgY2h1bmtCdWZmZXJNYXhTaXplOiA2NCxcXG59O1xcblRpbGVNYXAuREVGQVVMVF9MQVlFUl9PUFRJT05TID0ge1xcbiAgICBuYW1lOiAnZGVmYXVsdCcsXFxufTtcXG5UaWxlTWFwLkRFQlVHX09SSUdJTl9DT0xPVVIgPSAnY3lhbic7XFxuVGlsZU1hcC5ERUJVR19PUklHSU5fTElORV9XSURUSCA9IDI7XFxuVGlsZU1hcC5ERUJVR19PUklHSU5fU0laRSA9IDEwO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0NPTE9VUiA9ICd5ZWxsb3cnO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfQk9SREVSX0xJTkVfV0lEVEggPSAyO1xcblRpbGVNYXAuREVCVUdfQ0hVTktfTEFCRUxfQ09MT1VSID0gJ3doaXRlJztcXG5UaWxlTWFwLkRFQlVHX0NIVU5LX0xBQkVMX0ZPTlQgPSAnMTJweCBtb25vc3BhY2UnO1xcblRpbGVNYXAuREVCVUdfVElMRV9CT1JERVJfQ09MT1VSID0gJ29yYW5nZSc7XFxuVGlsZU1hcC5ERUJVR19USUxFX0JPUkRFUl9MSU5FX1dJRFRIID0gMTtcXG4vKipcXG4gKiBDb250ZW50IE1hbmFnZXIgUHJvY2Vzc29yIHdyYXBwZXIgd2hpY2ggY29udmVydHMgVGlsZU1hcE9wdGlvbnNEYXRhIGludG9cXG4gKiBUaWxlTWFwT3B0aW9uc1xcbiAqXFxuICogQHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXJcXG4gKi9cXG5hc3luYyBmdW5jdGlvbiB0aWxlTWFwT3B0aW9uc0NvbnRlbnRQcm9jZXNzb3IoY29udGVudCwgZGF0YSwgb3B0aW9ucykge1xcbiAgICBjb25zdCBnZXRJbWFnZUZyb21Db250ZW50ID0gKG5hbWUpID0+IHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGltYWdlID0gKF9hID0gY29udGVudFtuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XFxuICAgICAgICBpZiAoIWltYWdlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaW1hZ2U7XFxuICAgIH07XFxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuY29udGVudDtcXG4gICAgaWYgKHJlc3VsdC5sYXllcnMpIHtcXG4gICAgICAgIGZvciAoY29uc3QgW2ksIGxheWVyXSBvZiByZXN1bHQubGF5ZXJzLmVudHJpZXMoKSkge1xcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgaW1hZ2VOYW1lIHdpdGggaW1hZ2UgaW4gdGhlIHRpbGUgZGVmaW5pdGlvbnMgYXJyYXlcXG4gICAgICAgICAgICBpZiAobGF5ZXIudGlsZXMpIHtcXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaiwgdGlsZV0gb2YgbGF5ZXIudGlsZXMuZW50cmllcygpKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGF5ZXJzW2ldLnRpbGVzW2pdLmltYWdlID0gZ2V0SW1hZ2VGcm9tQ29udGVudCh0aWxlLmltYWdlTmFtZSk7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LmxheWVyc1tpXS50aWxlc1tqXS5pbWFnZU5hbWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gRGVjb21wcmVzcyBsYXllciBkYXRhXFxuICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb21wcmVzc0RhdGEpICYmIGxheWVyLmRhdGEgJiYgbGF5ZXIud2lkdGgpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0LmxheWVyc1tpXS5kYXRhID0gKDAsIHV0aWxzXzEuY2h1bmspKCgwLCBkZWNvZGVfMS5kZWZhdWx0KShsYXllci5kYXRhKSwgbGF5ZXIud2lkdGgpO1xcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LmxheWVyc1tpXS53aWR0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLy8gQHRzLWlnbm9yZVxcbiAgICBkYXRhLmNvbnRlbnQgPSByZXN1bHQ7XFxufVxcbmV4cG9ydHMudGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yID0gdGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXG4gKi9cblxuLyoqXG4gKiBNZW1vaXplIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvblxuICovXG5jb25zdCBtZW1vaXplID0gZiA9PiB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjYWNoZVthcmdzXSA/PyAoY2FjaGVbYXJnc10gPSBmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG51bWJlcnMgYSBhbmQgYiBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICovXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XG5cbi8qKlxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBudW1iZXJcbiAqL1xuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XG5cbi8qKlxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgZnJvbSB3aGljaCB0byBnZXQgdGhlIGZyYWN0aW9uYWwgcGFydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcbiAqL1xuY29uc3QgZnJhYyA9IGEgPT4gYSA+PSAwID8gYSAtIE1hdGguZmxvb3IoYSkgOiBhIC0gTWF0aC5jZWlsKGEpO1xuXG4vKipcbiAqIFJvdW5kIG4gdG8gZCBkZWNpbWFsIHBsYWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtkPTBdIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm4ge251bWJlcn0gQSByb3VuZGVkIG51bWJlclxuICovXG5jb25zdCByb3VuZCA9IChuLCBkID0gMCkgPT4ge1xuICBjb25zdCBwID0gTWF0aC5wb3coMTAsIGQpO1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogcCArIE51bWJlci5FUFNJTE9OKSAvIHA7XG59XG5cbi8qKlxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XG5cbi8qKlxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xuXG4vKipcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMxMCBUb3AtcmlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaXggSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB4XG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXG4gKi9cbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XG5cbi8qKlxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXG4gKiBAcGFyYW0ge251bWJlcn0gYTFcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxuICogQHBhcmFtIHtudW1iZXJ9IGIxXG4gKiBAcGFyYW0ge251bWJlcn0gYjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgcmVtYXAgPSAoaSwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKGkgLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSk7XG5cbi8qKlxuICogRG8gYSBzbW9vdGggaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5jb25zdCBzbW9vdGhzdGVwID0gKGEsIGIsIGkpID0+IGxlcnAoYSwgYiwgMyAqIE1hdGgucG93KGksIDIpIC0gMiAqIE1hdGgucG93KGksIDMpKTtcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqL1xuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXG4gKi9cbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICovXG5jb25zdCByYW5kb21JbnRCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlcz0yXSBUaGUgbnVtYmVyIG9mIHNhbXBsZXNcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbSA9IChtdSA9IDAuNSwgc2lnbWEgPSAwLjUsIHNhbXBsZXMgPSAyKSA9PiB7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XG4gICAgdG90YWwgKz0gTWF0aC5yYW5kb20oKTtcbiAgfVxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XG59O1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB3IEFuIGFycmF5IG9mIHdlaWdodHNcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XG4gKi9cbmNvbnN0IHdlaWdodGVkUmFuZG9tID0gdyA9PiB7XG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xuICB3aGlsZSAodG90YWwgPiByKSB7XG4gICAgdG90YWwgLT0gd1tuKytdO1xuICB9XG4gIHJldHVybiBuIC0gMTtcbn07XG5cbi8qKlxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxuICogQGNhbGxiYWNrIEludGVycG9sYXRpb25GdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQSBudW1iZXIgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHBhcmFtIHtJbnRlcnBvbGF0aW9uRnVuY3Rpb259IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxuICovXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcbiAgY29uc3QgcCA9IGNsYW1wKE1hdGgudHJ1bmMocyksIDAsIGEubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xuXG4vKipcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHJldHVybiB7bnVtYmVyfSBhIVxuICovXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcbiAgbGV0IHJlc3VsdCA9IDE7XG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xuICAgIHJlc3VsdCAqPSBpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSByXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxuICovXG5jb25zdCBucHIgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gZmFjdG9yaWFsKG4gLSByKTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gclxuICogQHJldHVybiB7bnVtYmVyfSBuQ3JcbiAqL1xuY29uc3QgbmNyID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogcGVybXV0YXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgMV0sXG4gKiAgIFsyLCAzXSxcbiAqICAgWzMsIDFdLFxuICogICBbMywgMl1cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBwZXJtdXRhdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBwZXJtdXRhdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgcGVybXV0YXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLnBlcm11dGF0aW9ucyhhLnNsaWNlKDAsIGkpLmNvbmNhdChhLnNsaWNlKGkgKyAxKSksIHIgLSAxKS5tYXAoYyA9PiBbaXRlbSwgLi4uY10pLFxuICAgIF0sXG4gICAgW11cbiAgKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgM11cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBjb21iaW5hdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLmNvbWJpbmF0aW9ucyhhLnNsaWNlKGkgKyAxKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXG4gICAgXSxcbiAgICBbXVxuICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNhcnRlc2lhbihbMSwgMiwgM10sIFsnYScsICdiJ10pO1xuICogYGBgXG4gKlxuICogT3V0cHV0OlxuICogYGBganNvblxuICogW1xuICogICBbMSwgXCJhXCJdLFxuICogICBbMSwgXCJiXCJdLFxuICogICBbMiwgXCJhXCJdLFxuICogICBbMiwgXCJiXCJdLFxuICogICBbMywgXCJhXCJdLFxuICogICBbMywgXCJiXCJdXG4gKiBdXG4gKiBgYGBcbiAqL1xuY29uc3QgY2FydGVzaWFuID0gKC4uLmFycikgPT5cbiAgYXJyLnJlZHVjZShcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcbiAgICBbW11dXG4gICk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhcnJheSB2YWx1ZXNcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IFRoZSBhcnJheSB2YWx1ZVxuICovXG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxuICogQHBhcmFtIHtUaW1lc0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxuICovXG5jb25zdCB0aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyAwLT4obiAtIDEpXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcbiAqL1xuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XG5cbi8qKlxuICogWmlwIG11bHRpcGxlIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxuICogQHBhcmFtIHsuLi5BcnJheTwqPn0gYSBUaGUgYXJyYXlzIHRvIHppcFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fVxuICovXG5jb25zdCB6aXAgPSAoLi4uYSkgPT4gdGltZXMoaSA9PiBhLm1hcChhID0+IGFbaV0pLCBNYXRoLm1heCguLi5hLm1hcChhID0+IGEubGVuZ3RoKSkpO1xuXG4vKipcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xuICogQHBhcmFtIHtBcnJheTwqPn0gYSBUaGUgYXJyYXkgdG8gYWNjZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEByZXR1cm4geyp9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgcGVlayA9IChhKSA9PiB7XG4gIGlmICghYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBwb3NpdGlvbiBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggaW4gdGhlIHVucm9sbGVkIGFycmF5XG4gKi9cbmNvbnN0IGluZCA9ICh4LCB5LCB3KSA9PiB4ICsgeSAqIHc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwb3NpdGlvbiBmb3IgYSBnaXZlbiBpbmRleCBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHBvc2l0aW9uIGFzIGEgMi10dXBsZVxuICovXG5jb25zdCBwb3MgPSAoaSwgdykgPT4gW2kgJSB3LCBNYXRoLmZsb29yKGkgLyB3KV07XG5cbi8qKlxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xuICovXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcblxuLyoqXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gVGhlIHNodWZmbGVkIGFycmF5XG4gKi9cbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuXG4vKipcbiAqIEZsYXR0ZW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIHVzZSBmb3IgY29uY2F0ZW5hdGluZyBrZXlzXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCBmbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChvW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBvW2tleV0udG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8ICFvW2tleV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2tleV06IG9ba2V5XSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQob1trZXldLCBjb25jYXRlbmF0b3IpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGZsYXR0ZW5lZCkucmVkdWNlKFxuICAgICAgICAoY2hpbGRBY2MsIGNoaWxkS2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmNoaWxkQWNjLFxuICAgICAgICAgIFtgJHtrZXl9JHtjb25jYXRlbmF0b3J9JHtjaGlsZEtleX1gXTogZmxhdHRlbmVkW2NoaWxkS2V5XSxcbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApLFxuICAgIH07XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogVW5mbGF0dGVuIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byBjaGVjayBmb3IgaW4gY29uY2F0ZW5hdGVkIGtleXNcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gdW4tZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCB1bmZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XG4gIGxldCByZXN1bHQgPSB7fSwgdGVtcCwgc3Vic3RyaW5ncywgcHJvcGVydHksIGk7XG5cbiAgZm9yIChwcm9wZXJ0eSBpbiBvKSB7XG4gICAgc3Vic3RyaW5ncyA9IHByb3BlcnR5LnNwbGl0KGNvbmNhdGVuYXRvcik7XG4gICAgdGVtcCA9IHJlc3VsdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICghKHN1YnN0cmluZ3NbaV0gaW4gdGVtcCkpIHtcbiAgICAgICAgaWYgKGlzRmluaXRlKHN1YnN0cmluZ3NbaSArIDFdKSkge1xuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSB0ZW1wW3N1YnN0cmluZ3NbaV1dO1xuICAgIH1cbiAgICB0ZW1wW3N1YnN0cmluZ3Nbc3Vic3RyaW5ncy5sZW5ndGggLSAxXV0gPSBvW3Byb3BlcnR5XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEEgc3BsaXQgcHJlZGljYXRlXG4gKiBAY2FsbGJhY2sgU3BsaXRQcmVkaWNhdGVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJyYXkgc2hvdWxkIHNwbGl0IGF0IHRoaXMgaW5kZXhcbiAqL1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gc3ViLWFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcbiAqIEBwYXJhbSB7U3BsaXRQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheXNcbiAqL1xuY29uc3Qgc3BsaXQgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gW3ZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2goY3VycmVudCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGx1Y2sga2V5cyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIHBsdWNrIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGx1Y2tlZCBrZXlzXG4gKi9cbmNvbnN0IHBsdWNrID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChyZXN1bHQsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9ba2V5XSB9KSxcbiAgICB7fVxuICApO1xufTtcblxuLyoqXG4gKiBFeGNsdWRlIGtleXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBleGNsdWRlIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5cyBleGNlcHQgZXhjbHVkZWQga2V5c1xuICovXG5jb25zdCBleGNsdWRlID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKVxuICApO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1lbW9pemUsXG4gICAgZmxvYXRFcXVhbHMsXG4gICAgY2xhbXAsXG4gICAgZnJhYyxcbiAgICByb3VuZCxcbiAgICBsZXJwLFxuICAgIHVubGVycCxcbiAgICBibGVycCxcbiAgICByZW1hcCxcbiAgICBzbW9vdGhzdGVwLFxuICAgIHJhZGlhbnMsXG4gICAgZGVncmVlcyxcbiAgICByYW5kb21CZXR3ZWVuLFxuICAgIHJhbmRvbUludEJldHdlZW4sXG4gICAgY2x0UmFuZG9tLFxuICAgIGNsdFJhbmRvbUludCxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcbiAgICBsZXJwQXJyYXksXG4gICAgZG90LFxuICAgIGZhY3RvcmlhbCxcbiAgICBucHIsXG4gICAgbmNyLFxuICAgIHBlcm11dGF0aW9ucyxcbiAgICBjb21iaW5hdGlvbnMsXG4gICAgY2FydGVzaWFuLFxuICAgIHRpbWVzLFxuICAgIHJhbmdlLFxuICAgIHppcCxcbiAgICBhdCxcbiAgICBwZWVrLFxuICAgIGluZCxcbiAgICBwb3MsXG4gICAgY2h1bmssXG4gICAgc2h1ZmZsZSxcbiAgICBmbGF0LFxuICAgIHVuZmxhdCxcbiAgICBzcGxpdCxcbiAgICBwbHVjayxcbiAgICBleGNsdWRlLFxuICB9O1xufVxuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxuICovXG5cbmNvbnN0IF92ZWNfdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XG5jb25zdCBfdmVjX2lzX3ZlYzIgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYTtcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xuXG4vKipcbiAqIEEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxuICogbGV0IGMgPSB2ZWMyKGEpOyAgICAvLyAoMywgMilcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXG4gKi9cbmNvbnN0IHZlYzIgPSAoeCwgeSkgPT4ge1xuICBpZiAoIXggJiYgIXkpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xuICB9XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxuICovXG52ZWMyLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxuICovXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcbiAqL1xudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxuICovXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcblxuLyoqXG4gKiBBZGQgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSArIGJcbiAqL1xudmVjMi5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC0gYlxuICovXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxuICovXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXG4gKi9cbnZlYzIuc2NhbGUgPSAoYSwgYikgPT4gdmVjMi5tdWwoYSwgYik7XG5cbi8qKlxuICogRGl2aWRlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC8gYlxuICovXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjMn0gXmFcbiAqL1xudmVjMi5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzIubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMi5yb3QgPSAoYSwgcikgPT4ge1xuICBsZXQgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XG59O1xuXG4vKipcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIDEgZm9yIDkwIGRlZ3JlZXMgKGN3KSwgLTEgZm9yIC05MCBkZWdyZWVzIChjY3cpLCAyIG9yIC0yIGZvciAxODAgZGVncmVlc1xuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMyLnJvdGYgPSAoYSwgcikgPT4ge1xuICBzd2l0Y2ggKHIpIHtcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XG4gICAgY2FzZSAtMTogcmV0dXJuIHZlYzIoLWEueSwgYS54KTtcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xuICB9XG59O1xuXG4vKipcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcbiAqL1xudmVjMi5jcm9zcyA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb3B5XG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcbiAqL1xudmVjMi5jcHkgPSBhID0+IHZlYzIoYSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgMmQgdmVjdG9yXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xuXG4vKipcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXG4gKlxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcbiAqIC0gYHhgIG9yIGB5YFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAtMik7XG4gKiB2ZWMyLnN3aXooYSwgJ3gnKTsgICAgLy8gWzNdXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxuICogdmVjMi5zd2l6KGEsICdZeScpOyAgIC8vIFsyLCAtMl1cbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxuICovXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnBvbGFyID0gYSA9PiAoeyByOiB2ZWMyLmxlbihhKSwgdGhldGE6IE1hdGguYXRhbjIoYS55LCBhLngpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcbiAqL1xudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XG5cbi8qKlxuICogQSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHogVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciB0aGUgeiBjb21wb25lbnQgaWYgeCBpcyBhIHZlYzJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcbiAqIGxldCBjID0gdmVjMyg2KTsgICAgICAgICAgICAgLy8gKDYsIDYsIDYpXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcbiAqIGxldCBmID0gdmVjMyh2ZWMyKDEsIDIpLCAzKTsgLy8gKDEsIDIsIDMpXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxuICovXG5jb25zdCB2ZWMzID0gKHgsIHksIHopID0+IHtcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAqL1xudmVjMy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnksIGEuel07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxuICovXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcbiAqL1xudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxuICovXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXG4gKi9cbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIEFkZCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxuICovXG52ZWMzLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpLCB6OiBhLnogKyAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLSBiXG4gKi9cbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXG4gKi9cbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxuICogQHJldHVybiB7dmVjM30gYSAqIGJcbiAqL1xudmVjMy5zY2FsZSA9IChhLCBiKSA9PiB2ZWMzLm11bChhLCBiKTtcblxuLyoqXG4gKiBEaXZpZGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLyBiXG4gKi9cbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkgKyBhLnogKiBhLnopO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjM30gXmFcbiAqL1xudmVjMy5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzMubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XG59O1xuXG4vKipcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge21hdH0gbSBUaGUgcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90ID0gKGEsIG0pID0+IHZlYzMoXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDMpKSwgYSlcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eCA9IChhLCByKSA9PiB2ZWMzKFxuICBhLngsXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXG4gIGEueSAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3Mocilcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eSA9IChhLCByKSA9PiB2ZWMzKFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxuICBhLnksXG4gIC1hLnggKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHogPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcbiAgYS56XG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxIFRoZSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHEgPSAodiwgcSkgPT4ge1xuICBpZiAocS5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gdmVjMygpO1xuICB9XG5cbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIHZlYzMoKTtcbiAgfVxuXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xuICBjb25zdCBzID0gdXFbM107XG4gIHJldHVybiB2ZWMzLmFkZChcbiAgICB2ZWMzLmFkZChcbiAgICAgIHZlYzMubXVsKHUsIDIgKiB2ZWMzLmRvdCh1LCB2KSksXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxuICAgICksXG4gICAgdmVjMy5tdWwodmVjMy5jcm9zcyh1LCB2KSwgMiAqIHMpXG4gICk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXG4gKi9cbnZlYzMuY3Jvc3MgPSAoYSwgYikgPT4gdmVjMyhcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXG4gIGEueCAqIGIueSAtIGEueSAqIGIueFxuKTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG52ZWMzLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEueiA9PT0gYi56O1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeCBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcbiAqL1xudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMzLnJhZHogPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLnopO1xuXG4vKipcbiAqIENvcHkgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxuICovXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcblxuLyoqXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xuICpcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcbiAqIC0gYHJgLCBgZ2Agb3IgYGJgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cbiAqIHZlYzMuc3dpeihhLCAnenl4Jyk7ICAgLy8gWzEsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cbiAqIHZlYzMuc3dpeihhLCAneC54Jyk7ICAgLy8gWzMsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXG4gKi9cbnZlYzMuc3dpeiA9IChhLCBzID0gJy4uLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICd6JzogY2FzZSAndyc6IGNhc2UgJ2InOiByZXN1bHQucHVzaChhLnopOyBicmVhaztcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJ1onOiBjYXNlICdXJzogY2FzZSAnQic6IHJlc3VsdC5wdXNoKC1hLnopOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueSwgYS56XVtpXSA/PyAwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMzZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBoaSBUaGUgcGFuIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczNkfSBUaGUgbWFnbml0dWRlLCB0aWx0IGFuZCBwYW4gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnBvbGFyID0gYSA9PiB7XG4gIGxldCByID0gdmVjMy5sZW4oYSksXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XG4gIHJldHVybiB7IHIsIHRoZXRhLCBwaGkgfTtcbn07XG5cbi8qKlxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxuICovXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICByZXR1cm4gdmVjMyhcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5zaW4ocGhpKVxuICApO1xufTtcblxuLyoqXG4gKiBBIG1hdHJpeFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxuICovXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XG4gIG0sIG4sXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcbn0pO1xuXG4vKipcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxuICovXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xuXG4vKipcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcbiAqL1xubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xuXG4vKipcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxuICovXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XG5cbi8qKlxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxuICovXG5tYXQucm93ID0gKGEsIG0pID0+IHtcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LmNvbCA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcblxuLyoqXG4gKiBBZGQgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fSBhICsgYlxuICovXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcbiAqL1xubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIG1hdHJpeCBieSBhIHZlY3RvclxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHt2ZWMyfHZlYzN8bnVtYmVyW118ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggYW5kIHZlY3RvciBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XG4gIGxldCBuLCBiYiwgcnQ7XG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcbiAgICBuID0gMztcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XG4gICAgYmIgPSB2ZWMyLmNvbXBvbmVudHMoYik7XG4gICAgbiA9IDI7XG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xuICB9IGVsc2Uge1xuICAgIGJiID0gYjtcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcbiAgICBydCA9IHYgPT4gdjtcbiAgfVxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xuICB9XG4gIHJldHVybiBydChyZXN1bHQpO1xufVxuXG4vKipcbiAqIFNjYWxlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcbiAqL1xubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XG5cbi8qKlxuICogVHJhbnNwb3NlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XG4gKi9cbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xuXG4vKipcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0LmRldCA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhLm0gPT09IDEpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xuICB9XG4gIGlmIChhLm0gPT09IDIpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xuICB9XG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xuICAgIHNpZ24gKj0gLTE7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxuICovXG5tYXQubm9yID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxuICovXG5tYXQuYWRqID0gYSA9PiB7XG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxuICovXG5tYXQuaW52ID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xuXG4vKipcbiAqIENvcHkgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcbiAqL1xubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjMiwgdmVjMywgbWF0IH07XG59XG4iLCJjb25zdCBkZWZhdWx0VmVydGV4U2hhZGVyID0gYFxuICAjaWZkZWYgR0xfRVNcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICNlbmRpZlxuICBhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcbiAgdm9pZCBtYWluKCkge1xuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xuICB9XG5gO1xuY29uc3QgZGVmYXVsdEZyYWdtZW50U2hhZGVyID0gYFxuICAjaWZkZWYgR0xfRVNcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICNlbmRpZlxuICB2b2lkIG1haW4oKSB7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xuICB9XG5gO1xuZXhwb3J0IGNsYXNzIFNoYWRlckNhbnZhcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xuICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gZ2V0IHdlYmdsIGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIGlmICghdnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgdmVydGV4IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IHZzO1xuICAgICAgICBjb25zdCB2c0VycnMgPSBjb21waWxlU2hhZGVyKHRoaXMuZ2wsIHRoaXMudmVydGV4U2hhZGVyLCBkZWZhdWx0VmVydGV4U2hhZGVyKTtcbiAgICAgICAgaWYgKHZzRXJycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcyA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgaWYgKCFmcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSBmcmFnbWVudCBzaGFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZzO1xuICAgICAgICBjb25zdCBmc0VycnMgPSBjb21waWxlU2hhZGVyKHRoaXMuZ2wsIHRoaXMuZnJhZ21lbnRTaGFkZXIsIGRlZmF1bHRGcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGlmIChmc0VycnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFkZXJQcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnZlcnRleFNoYWRlciwgdGhpcy5mcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGJpbmRQb3NpdGlvbkF0dHJpYnV0ZSh0aGlzLmdsLCB0aGlzLnNoYWRlclByb2dyYW0pO1xuICAgICAgICB0aGlzLmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSg0MDAsIDQwMCk7XG4gICAgfVxuICAgIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZG9tRWxlbWVudC53aWR0aCwgdGhpcy5kb21FbGVtZW50LmhlaWdodCk7XG4gICAgfVxuICAgIC8vIGdldFJlc29sdXRpb24gaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGdldHRpbmcgYSB2ZWMyIHJlcHJlc2VudGluZyB0aGVcbiAgICAvLyBzaXplIGluIHBoeXNpY2FsIHBpeGVscyBvZiB0aGUgY2FudmFzLlxuICAgIC8vIFR5cGljYWwgdXNhZ2UgaXM6XG4gICAgLy8gICBzaGFkZXJDYW52YXMuc2V0VW5pZm9ybShcInVfcmVzb2x1dGlvblwiLCBzaGFkZXJDYW52YXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICBnZXRSZXNvbHV0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LndpZHRoLFxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LmhlaWdodCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgc2V0U2hhZGVyKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGNvbnN0IGVycnMgPSBjb21waWxlU2hhZGVyKGdsLCB0aGlzLmZyYWdtZW50U2hhZGVyLCBzb3VyY2UpO1xuICAgICAgICBpZiAoZXJycykge1xuICAgICAgICAgICAgcmV0dXJuIGVycnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2wubGlua1Byb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMuc2hhZGVyUHJvZ3JhbSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGxpbmsgcHJvZ3JhbVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0VW5pZm9ybShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5zaGFkZXJQcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uICE9PSBudWxsO1xuICAgIH1cbiAgICBzZXRVbmlmb3JtKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIG5hbWU/XG4gICAgICAgIC8vIFRPRE8gT1BUSU1JWkU6IGNhY2hlIHVuaWZvcm0gbG9jYXRpb25cbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIG5hbWUpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5pZm9ybSBsb2NhdGlvbiBmb3IgJHtuYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogYWNjZXB0IG9wdGlvbnMsIGxpa2UgZm9ybWF0LCBmaWx0ZXIsIHdyYXAsIGV0Yy5cbiAgICBzZXRUZXh0dXJlKG5hbWUsIGltYWdlKSB7XG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRlIG5hbWU/XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgbGV0IHQgPSB0aGlzLnRleHR1cmVzW25hbWVdO1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gY3JlYXRlIGdsVGV4dHVyZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IHtcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUsXG4gICAgICAgICAgICAgICAgdW5pdDogbG93ZXN0VW51c2VkKE9iamVjdC5rZXlzKHRoaXMudGV4dHVyZXMpLm1hcCgoaykgPT4gdGhpcy50ZXh0dXJlc1trXS51bml0KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlc1tuYW1lXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHQudW5pdCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHQuZ2xUZXh0dXJlKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgMSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIG5hbWUpO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5pZm9ybSBsb2NhdGlvbiBmb3IgdGV4dHVyZSAke25hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdC51bml0KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCBzaGFkZXIsIHNvdXJjZSkge1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY29tcGlsZSwgYnV0IGZvdW5kIG5vIGVycm9yIGxvZ1wiKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihpbmZvKTtcbiAgICByZXR1cm4gcGFyc2VFcnJvck1lc3NhZ2VzKGluZm8pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdnMsIGZzKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBpZiAocHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIHNoYWRlciBwcm9ncmFtXCIpO1xuICAgIH1cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcyk7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBjb25zdCBpbmZvID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoaW5mbyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBsaW5rIHByb2dyYW1cIik7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZnVuY3Rpb24gYmluZFBvc2l0aW9uQXR0cmlidXRlKGdsLCBwcm9ncmFtKSB7XG4gICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgIC0xLjAsIDEuMCxcbiAgICAgICAgMS4wLCAtMS4wLFxuICAgICAgICAxLjAsIDEuMCxcbiAgICBdKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25zLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwicG9zaXRpb25cIik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xufVxuZnVuY3Rpb24gcGFyc2VFcnJvck1lc3NhZ2VzKG1zZykge1xuICAgIGNvbnN0IGVycm9yUmVnZXggPSAvXkVSUk9SOiBcXGQrOihcXGQrKS4qJC9tZztcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBtYXRjaCA9IGVycm9yUmVnZXguZXhlYyhtc2cpO1xuICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2sgZm9yIGFub3RoZXIgZXJyb3I6XG4gICAgICAgIG1hdGNoID0gZXJyb3JSZWdleC5leGVjKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbn1cbi8vIFRoaXMgaXMgYSBmbGF2b3Igb2YgU2hsZW1pZWwgdGhlIHBhaW50ZXIncyBhbGdvcml0aG0uXG4vLyBodHRwOi8vd2lraS5jMi5jb20vP1NobGVtaWVsVGhlUGFpbnRlclxuLy9cbi8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIHJ1biB0ZXN0cywgYnV0IEkndmUgc3BvdCBjaGVja2VkIHRoZXNlOlxuLy8gICBbXSA9PiAwXG4vLyAgIFswLCAxLCAyLCAzLCA0XSA9PiA1XG4vLyAgIFswLCAxLCAzLCA0XSA9PiAyXG4vLyAgIFsxLCAzLCA0XSA9PiAwXG4vLyAgIFs0XSA9PiAwXG4vLyAgIFs0LCAzLCAyLCAxLCAwXSA9PiA1XG4vLyAgIFs0LCAyLCAxLCAwXSA9PiAzXG4vLyAgIFs0LCAyLCAxLCAxMF0gPT4gMFxuLy8gICBbMiwgMCwgMywgNF0gPT4gMVxuZnVuY3Rpb24gbG93ZXN0VW51c2VkKHhzKSB7XG4gICAgbGV0IHVudXNlZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHVudXNlZCkge1xuICAgICAgICAgICAgdW51c2VkKys7XG4gICAgICAgICAgICBpID0gLTE7IC8vIGdvIGJhY2sgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bnVzZWQ7XG59XG4iLCJpbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBDb250ZW50TWFuYWdlciwgeyBDb250ZW50UHJvY2Vzc29yIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zyc7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zY2VuZS1tYW5hZ2VyJztcbmltcG9ydCBMb2FkaW5nU2NlbmUgZnJvbSAnLi9zY2VuZXMvTG9hZGluZ1NjZW5lJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuL2NvbmZpZy5qc29uJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBTaGFkZXJQcm9jZXNzb3IgfSBmcm9tICcuL2NvbnRlbnQtcHJvY2Vzc29ycy9zaGFkZXIuY29udGVudC1wcm9jZXNzb3InO1xuaW1wb3J0IHsgdGV4dHVyZUF0bGFzQ29udGVudFByb2Nlc3NvciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3RleHR1cmUtYXRsYXMnO1xuaW1wb3J0IHsgdGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdGlsZS1tYXAnO1xuaW1wb3J0IHsgc3ByaXRlT3B0aW9uc0NvbnRlbnRQcm9jZXNzb3IgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUnO1xuaW1wb3J0IHsgaW1hZ2VGb250Q29udGVudFByb2Nlc3NvciB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ltYWdlLWZvbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgcHJpdmF0ZSBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuICBwcml2YXRlIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgcHJpdmF0ZSBsYXN0RnJhbWVUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgbGFzdEZyYW1lQ291bnRUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgZnJhbWVSYXRlOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGZyYW1lQ291bnQ6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIHN0YXRpYyBzY3JlZW46IHZlYzI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHZhbGlkIGNvbnRhaW5lciBlbGVtZW50IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2NhbnZhcycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGFpbmVyIGVsZW1lbnQgbXVzdCBiZSBhIGNhbnZhcy4nKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMgPSBjb250YWluZXIgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAvLyBHZXQgYSAyZCBjb250ZXh0XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGdldCBhIDJkIGNvbnRleHQuXCIpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSByZXNpemVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIHRoaXMucmVzaXplKCk7XG4gIH1cblxuICBwcml2YXRlIHJlc2l6ZSgpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXNlKCkge1xuICAgIC8vIEluaXRpYWxpc2Ugc3Vic3lzdGVtc1xuICAgIENvbnRlbnRNYW5hZ2VyLmluaXRpYWxpc2Uoe1xuICAgICAgc2ltdWxhdGVTbG93TG9hZGluZzogY29uc3RhbnRzLkRFQlVHLFxuICAgICAgc2xvd0xvYWRpbmdUaW1lTWluOiAxMDAsXG4gICAgICBzbG93TG9hZGluZ1RpbWVNYXg6IDUwMCxcbiAgICAgIHByb2Nlc3NvcnM6IHtcbiAgICAgICAgc2hhZGVyOiBTaGFkZXJQcm9jZXNzb3IsXG4gICAgICAgIHRleHR1cmVBdGxhczogdGV4dHVyZUF0bGFzQ29udGVudFByb2Nlc3NvcixcbiAgICAgICAgdGlsZU1hcDogdGlsZU1hcE9wdGlvbnNDb250ZW50UHJvY2Vzc29yLFxuICAgICAgICBzcHJpdGU6IHNwcml0ZU9wdGlvbnNDb250ZW50UHJvY2Vzc29yLFxuICAgICAgICBpbWFnZUZvbnQ6IGltYWdlRm9udENvbnRlbnRQcm9jZXNzb3IsXG4gICAgICB9LFxuICAgICAgdGhyb3dPbk5vdEZvdW5kOiB0cnVlLFxuICAgIH0pO1xuICAgIERlYnVnLmluaXRpYWxpc2Uoe1xuICAgICAgbGluZU1hcmdpbjogNSxcbiAgICB9KTtcbiAgICBJbnB1dE1hbmFnZXIuaW5pdGlhbGlzZSgpO1xuICAgIFNjZW5lTWFuYWdlci5pbml0aWFsaXNlKCk7XG5cbiAgICAvLyBTdGFydCBnYW1lIGxvb3BcbiAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMubG9vcCgpO1xuXG4gICAgLy8gUHVzaCB0aGUgaW5pdGlhbCBzY2VuZVxuICAgIFNjZW5lTWFuYWdlci5wdXNoKG5ldyBMb2FkaW5nU2NlbmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGxvb3AoKSB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBNYXRoLm1pbihub3cgLSB0aGlzLmxhc3RGcmFtZVRpbWUsIGNvbnN0YW50cy5GUFNfTUlOKTtcblxuICAgIC8vIENhbGN1bGF0ZSBmcmFtZXJhdGVcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RnJhbWVDb3VudFRpbWUgPj0gMTAwMCkge1xuICAgICAgdGhpcy5sYXN0RnJhbWVDb3VudFRpbWUgPSBub3c7XG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IHRoaXMuZnJhbWVDb3VudDtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgfVxuICAgIHRoaXMuZnJhbWVDb3VudCsrO1xuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IG5vdztcbiAgICBpZiAoY29uZmlnLnNob3dGUFMpIHtcbiAgICAgIERlYnVnLnZhbHVlKCdGUFMnLCB0aGlzLmZyYW1lUmF0ZSwgeyBhbGlnbjogJ3JpZ2h0JyB9KTtcbiAgICAgIERlYnVnLmNoYXJ0KCdGUFMnLCB0aGlzLmZyYW1lUmF0ZSwgeyBtaW5WYWx1ZTogMCwgbWF4VmFsdWU6IDcwIH0pO1xuICAgIH1cblxuICAgIC8vIERvIGdhbWUgbG9vcFxuICAgIHRoaXMudXBkYXRlKGVsYXBzZWRUaW1lKTtcbiAgICB0aGlzLmRyYXcoKTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMubG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgR2FtZS5zY3JlZW4gPSB2ZWMyKHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgRGVidWcudmFsdWUoJ3N0YXR1cycsIENvbnRlbnRNYW5hZ2VyLnN0YXR1cyk7XG4gICAgRGVidWcudmFsdWUoJ3Byb2dyZXNzJywgQ29udGVudE1hbmFnZXIucHJvZ3Jlc3MpO1xuXG4gICAgU2NlbmVNYW5hZ2VyLnVwZGF0ZShkdCk7XG4gICAgSW5wdXRNYW5hZ2VyLnVwZGF0ZSgpOyAgLy8gSW5wdXQgbWFuYWdlciBzaG91bGQgYmUgdXBkYXRlZCBsYXN0XG4gIH1cblxuICBkcmF3KCkge1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG5cbiAgICBTY2VuZU1hbmFnZXIuZHJhdyh0aGlzLmNvbnRleHQpO1xuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIEFjdG9yIHtcbiAgdXBkYXRlKGR0OiBudW1iZXIpOiB2b2lkO1xuICBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQ7XG59XG4iLCJpbXBvcnQgeyBTcHJpdGUsIFNwcml0ZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUnO1xuaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuL0FjdG9yJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBQbGF5ZXJEaXJlY3Rpb24gPSAnbicgfCAnbmUnIHwgJ2UnIHwgJ3NlJyB8ICdzJyB8ICdzdycgfCAndycgfCAnbncnO1xuXG5leHBvcnQgY2xhc3MgUGxheWVyIGltcGxlbWVudHMgQWN0b3Ige1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTUEVFRDogbnVtYmVyID0gNDA7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERJUkVDVElPTl9NQVA6IFJlY29yZDxzdHJpbmcsIFBsYXllckRpcmVjdGlvbj4gPSB7XG4gICAgWycxLCAwJ106ICdlJyxcbiAgICBbJzEsIDEnXTogJ3NlJyxcbiAgICBbJzAsIDEnXTogJ3MnLFxuICAgIFsnLTEsIDEnXTogJ3N3JyxcbiAgICBbJy0xLCAwJ106ICd3JyxcbiAgICBbJy0xLCAtMSddOiAnbncnLFxuICAgIFsnMCwgLTEnXTogJ24nLFxuICAgIFsnMSwgLTEnXTogJ25lJyxcbiAgfTtcblxuICBwcml2YXRlIHNwcml0ZTogU3ByaXRlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcG9zaXRpb246IHZlYzIsXG4gICAgcHVibGljIGRpcmVjdGlvbjogUGxheWVyRGlyZWN0aW9uLFxuICAgIHNwcml0ZURhdGE6IFNwcml0ZU9wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBuZXcgU3ByaXRlKHtcbiAgICAgIC4uLnNwcml0ZURhdGEsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGRlZmF1bHREaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG1vdmVWZWN0b3IgPSB2ZWMyKCk7XG5cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0Fycm93VXAnKSkge1xuICAgICAgbW92ZVZlY3Rvci55LS07XG4gICAgfVxuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5RG93bignQXJyb3dEb3duJykpIHtcbiAgICAgIG1vdmVWZWN0b3IueSsrO1xuICAgIH1cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleURvd24oJ0Fycm93TGVmdCcpKSB7XG4gICAgICBtb3ZlVmVjdG9yLngtLTtcbiAgICB9XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlEb3duKCdBcnJvd1JpZ2h0JykpIHtcbiAgICAgIG1vdmVWZWN0b3IueCsrO1xuICAgIH1cblxuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmFkZChcbiAgICAgIHRoaXMucG9zaXRpb24sXG4gICAgICB2ZWMyLm11bChtb3ZlVmVjdG9yLCBQbGF5ZXIuU1BFRUQgKiBkdClcbiAgICApO1xuXG4gICAgdGhpcy5wb3NpdGlvbi54ID0gY2xhbXAodGhpcy5wb3NpdGlvbi54LCAwLCAxMDI0KTtcbiAgICB0aGlzLnBvc2l0aW9uLnkgPSBjbGFtcCh0aGlzLnBvc2l0aW9uLnksIDAsIDEwMjQpO1xuXG4gICAgY29uc3QgbW92aW5nID0gIXZlYzIuZXEobW92ZVZlY3RvciwgdmVjMigpKTtcbiAgICBpZiAobW92aW5nKSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IChcbiAgICAgICAgUGxheWVyLkRJUkVDVElPTl9NQVBbdmVjMi5zdHIobW92ZVZlY3RvcildID8/ICdzJ1xuICAgICAgKSBhcyBQbGF5ZXJEaXJlY3Rpb247XG4gICAgfVxuXG4gICAgdGhpcy5zcHJpdGUucG9zaXRpb24gPSB2ZWMyLmNweSh0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnNwcml0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICB0aGlzLnNwcml0ZS5hbmltYXRpb24gPSBtb3ZpbmcgPyAnd2FsaycgOiAnaWRsZSc7XG4gICAgdGhpcy5zcHJpdGUudXBkYXRlKGR0KTtcbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIHRoaXMuc3ByaXRlLmRyYXcoY29udGV4dCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuJztcblxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyIGltcGxlbWVudHMgQWN0b3Ige1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFQVNFX0FNT1VOVCA9IDEuNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09MT1VSID0gJ3doaXRlJztcblxuICBwdWJsaWMgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgZGlzcGxheVByb2dyZXNzOiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcG9zaXRpb246IHZlYzIsXG4gICAgcHVibGljIHNpemU6IHZlYzJcbiAgKSB7fVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIHRoaXMuZGlzcGxheVByb2dyZXNzICs9IChcbiAgICAgIHRoaXMucHJvZ3Jlc3MgLSB0aGlzLmRpc3BsYXlQcm9ncmVzc1xuICAgICkgKiBQcm9ncmVzc0Jhci5FQVNFX0FNT1VOVCAqIGR0O1xuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxheVByb2dyZXNzIC0gdGhpcy5wcm9ncmVzcykgPD0gMC4wMDEpIHtcbiAgICAgIHRoaXMuZGlzcGxheVByb2dyZXNzID0gdGhpcy5wcm9ncmVzcztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBQcm9ncmVzc0Jhci5DT0xPVVI7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBQcm9ncmVzc0Jhci5DT0xPVVI7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAyO1xuXG4gICAgY29uc3QgdG9wTGVmdCA9IHZlYzIuc3ViKFxuICAgICAgdGhpcy5wb3NpdGlvbixcbiAgICAgIHZlYzIubXVsKHRoaXMuc2l6ZSwgMSAvIDIpXG4gICAgKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgIHRvcExlZnQueCxcbiAgICAgIHRvcExlZnQueSxcbiAgICAgIHRoaXMuc2l6ZS54LFxuICAgICAgdGhpcy5zaXplLnlcbiAgICApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICB0b3BMZWZ0LngsXG4gICAgICB0b3BMZWZ0LnksXG4gICAgICBNYXRoLmZsb29yKHRoaXMuZGlzcGxheVByb2dyZXNzICogdGhpcy5zaXplLngpLFxuICAgICAgdGhpcy5zaXplLnlcbiAgICApO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQWN0b3InO1xuZXhwb3J0ICogZnJvbSAnLi9QbGF5ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9Qcm9ncmVzc0Jhcic7XG4iLCJleHBvcnQgY29uc3QgREVCVUcgPSB0cnVlO1xuZXhwb3J0IGNvbnN0IEZQU19NSU4gPSAxIC8gMzA7XG4iLCJpbXBvcnQgeyBDb250ZW50UHJvY2Vzc29yIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCB7IFNoYWRlckNhbnZhcyB9IGZyb20gJ3NoYWRlci1jYW52YXMnO1xuXG5leHBvcnQgY29uc3QgU2hhZGVyUHJvY2Vzc29yOiBDb250ZW50UHJvY2Vzc29yID0gYXN5bmMgKFxuICBjb250ZW50LFxuICBpdGVtXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3Qgc2hhZGVyQ2FudmFzID0gbmV3IFNoYWRlckNhbnZhcygpO1xuICBzaGFkZXJDYW52YXMuc2V0U2hhZGVyKGl0ZW0uY29udGVudCBhcyBzdHJpbmcpO1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgaXRlbS5jb250ZW50ID0gc2hhZGVyQ2FudmFzO1xufTtcbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IEdhbWUgZnJvbSAnLi4vR2FtZSc7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgeyBUaWxlTWFwLCBUaWxlTWFwT3B0aW9ucyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3RpbGUtbWFwJztcbmltcG9ydCB7IFNwcml0ZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zcHJpdGUnO1xuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vYWN0b3JzJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAxO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVEFSVElOR19QT1NJVElPTjogdmVjMiA9IHZlYzIoNTEyLCA1MTIpO1xuXG4gIHByaXZhdGUgY2FtZXJhOiBDYW1lcmE7XG4gIHByaXZhdGUgbWFwOiBUaWxlTWFwO1xuICBwcml2YXRlIHBsYXllcjogUGxheWVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2l0aW9uVGltZTogR2FtZVNjZW5lLlRSQU5TSVRJT05fVElNRSxcbiAgICAgIG9uVHJhbnNpdGlvbmVkT3V0OiAoKSA9PiB7XG4gICAgICAgIERlYnVnLnJlbW92ZUNoYXJ0KCdDYW1lcmEgU2NhbGUnKTtcbiAgICAgICAgRGVidWcucmVtb3ZlQ2hhcnQoJ1dhdmUnKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoXG4gICAgICBHYW1lU2NlbmUuU1RBUlRJTkdfUE9TSVRJT04sXG4gICAgICB7XG4gICAgICAgIG1pblNjYWxlOiAwLjUsXG4gICAgICAgIG1heFNjYWxlOiA1LFxuICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICByaWdodDogMTAyNCxcbiAgICAgICAgICBib3R0b206IDEwMjQsXG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVFYXNlQW1vdW50OiAwLjk1LFxuICAgICAgICBzY2FsZUVhc2VBbW91bnQ6IDAuOTUsXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNhbWVyYS5zY2FsZUltbWVkaWF0ZSA9IDM7XG5cbiAgICB0aGlzLm1hcCA9IG5ldyBUaWxlTWFwKFxuICAgICAgQ29udGVudE1hbmFnZXIuZ2V0PFRpbGVNYXBPcHRpb25zPigndGlsZS1tYXAnKSFcbiAgICApO1xuXG4gICAgdGhpcy5wbGF5ZXIgPSBuZXcgUGxheWVyKFxuICAgICAgR2FtZVNjZW5lLlNUQVJUSU5HX1BPU0lUSU9OLFxuICAgICAgJ3MnLFxuICAgICAgQ29udGVudE1hbmFnZXIuZ2V0PFNwcml0ZU9wdGlvbnM+KCdjaGFyYWN0ZXItc3ByaXRlJykhXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIGlmIChJbnB1dE1hbmFnZXIua2V5UHJlc3NlZCgnRXNjYXBlJykpIHtcbiAgICAgIFNjZW5lTWFuYWdlci5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAoSW5wdXRNYW5hZ2VyLm1vdXNlV2hlZWxVcCgpKSB7XG4gICAgICB0aGlzLmNhbWVyYS5zY2FsZSArPSAwLjE7XG4gICAgfVxuICAgIGlmIChJbnB1dE1hbmFnZXIubW91c2VXaGVlbERvd24oKSkge1xuICAgICAgdGhpcy5jYW1lcmEuc2NhbGUgLT0gMC4xO1xuICAgIH1cblxuICAgIERlYnVnLmNoYXJ0KFxuICAgICAgJ0NhbWVyYSBTY2FsZScsXG4gICAgICB0aGlzLmNhbWVyYS5zY2FsZSxcbiAgICAgIHtcbiAgICAgICAgbWluVmFsdWU6IDAuNSxcbiAgICAgICAgbWF4VmFsdWU6IDUsXG4gICAgICAgIGJhckNvbG91cnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICBjb2xvdXI6ICcjZjAwJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9mZnNldDogMi41LFxuICAgICAgICAgICAgY29sb3VyOiAnI2Y1MCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvZmZzZXQ6IDQsXG4gICAgICAgICAgICBjb2xvdXI6ICcjZjkwJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcblxuICAgIERlYnVnLmNoYXJ0KFxuICAgICAgJ1dhdmUnLFxuICAgICAgTWF0aC5zaW4ocGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwKSArIDEsXG4gICAgICB7XG4gICAgICAgIG1pblZhbHVlOiAwLFxuICAgICAgICBtYXhWYWx1ZTogMixcbiAgICAgICAgdmFsdWVCdWZmZXJTaXplOiAxNTAwLFxuICAgICAgICB2YWx1ZUJ1ZmZlclN0cmlkZTogMzAsXG4gICAgICB9XG4gICAgKTtcblxuICAgIERlYnVnLmJvcmRlcihcbiAgICAgICd0ZXN0MScsXG4gICAgICAnJyxcbiAgICAgIHZlYzIoMjAwKSxcbiAgICAgIHtcbiAgICAgICAgc3BhY2U6ICdzY3JlZW4nLFxuICAgICAgICBzaXplOiB2ZWMyKDIwMCwgMjAwKSxcbiAgICAgICAgYm9yZGVyQ29sb3VyOiAnI2Y4MicsXG4gICAgICAgIGJvcmRlclN0eWxlOiAnZGFzaGVkJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDQsXG4gICAgICB9XG4gICAgKTtcblxuICAgIERlYnVnLmJvcmRlcihcbiAgICAgICd0ZXN0MicsXG4gICAgICAnJyxcbiAgICAgIHZlYzIoMTAwKSxcbiAgICAgIHtcbiAgICAgICAgc3BhY2U6ICd3b3JsZCcsXG4gICAgICAgIHJhZGl1czogMjAwLFxuICAgICAgICBib3JkZXJTaGFwZTogJ2NpcmNsZScsXG4gICAgICAgIGJvcmRlckNvbG91cjogJyM1ZjUnLFxuICAgICAgICBib3JkZXJTdHlsZTogJ2RvdHRlZCcsXG4gICAgICAgIHNob3dMYWJlbDogZmFsc2UsXG4gICAgICB9XG4gICAgKTtcblxuICAgIERlYnVnLm1hcmtlcihcbiAgICAgICdwbGF5ZXInLFxuICAgICAgdmVjMi5zdHIodmVjMi5tYXAodGhpcy5wbGF5ZXIucG9zaXRpb24sIE1hdGguZmxvb3IpKSxcbiAgICAgIHZlYzIuYWRkKHRoaXMucGxheWVyLnBvc2l0aW9uLCB2ZWMyKDAsIDMwKSksXG4gICAgICB7XG4gICAgICAgIG1hcmtlclN0eWxlOiAneCcsXG4gICAgICAgIG1hcmtlckNvbG91cjogJyNmZjAnLFxuICAgICAgICBzaG93TGFiZWw6IGZhbHNlLFxuICAgICAgICBzaG93VmFsdWU6IHRydWUsXG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMucGxheWVyLnVwZGF0ZShkdCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24gPSB2ZWMyLmNweSh0aGlzLnBsYXllci5wb3NpdGlvbik7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmUpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLnRyYW5zaXRpb25BbW91bnQ7XG4gICAgfVxuXG4gICAgLy8gQmFja2dyb3VuZFxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNjY2MnO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgR2FtZS5zY3JlZW4ueCwgR2FtZS5zY3JlZW4ueSk7XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNhbWVyYS5kcmF3KGNvbnRleHQsIEdhbWUuc2NyZWVuKTtcblxuICAgIC8vIE1hcFxuICAgIHRoaXMubWFwLmRyYXcoY29udGV4dCwgdGhpcy5jYW1lcmEpO1xuXG4gICAgLy8gUGxheWVyXG4gICAgdGhpcy5wbGF5ZXIuZHJhdyhjb250ZXh0KTtcblxuICAgIERlYnVnLmRyYXcoY29udGV4dCk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IEdhbWUgZnJvbSAnLi4vR2FtZSc7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IE1lbnVTY2VuZSBmcm9tICcuL01lbnVTY2VuZSc7XG5pbXBvcnQgQ29udGVudE1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCB7IFNoYWRlckNhbnZhcyB9IGZyb20gJ3NoYWRlci1jYW52YXMnO1xuaW1wb3J0IERlYnVnIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50cm9TY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAyO1xuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPT0xET1dOX1RJTUU6IG51bWJlciA9IDg7XG5cbiAgcHJpdmF0ZSBzaGFkZXI6IFNoYWRlckNhbnZhcztcblxuICBwcml2YXRlIGxvZ286IEhUTUxJbWFnZUVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSB0aW1lOiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2l0aW9uVGltZTogSW50cm9TY2VuZS5UUkFOU0lUSU9OX1RJTUUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZSgpIHtcbiAgICBjb25zdCBzaGFkZXIgPSBDb250ZW50TWFuYWdlci5nZXQ8U2hhZGVyQ2FudmFzPignYmx1ci1zaGFkZXInKTtcbiAgICBpZiAoc2hhZGVyKSB7XG4gICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dvID0gQ29udGVudE1hbmFnZXIuZ2V0PEhUTUxJbWFnZUVsZW1lbnQ+KCdiYXNlbWVudC11bml2ZXJzZScpO1xuICAgIGlmIChsb2dvKSB7XG4gICAgICB0aGlzLmxvZ28gPSBsb2dvO1xuXG4gICAgICB0aGlzLnNoYWRlci5zZXRTaXplKHRoaXMubG9nby53aWR0aCwgdGhpcy5sb2dvLmhlaWdodCk7XG4gICAgICB0aGlzLnNoYWRlci5zZXRUZXh0dXJlKCd1X21haW5UZXgnLCB0aGlzLmxvZ28pO1xuICAgICAgdGhpcy5zaGFkZXIuc2V0VW5pZm9ybSgndV9yZXNvbHV0aW9uJywgdGhpcy5zaGFkZXIuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRpbWUgPiBJbnRyb1NjZW5lLkNPT0xET1dOX1RJTUUgfHxcbiAgICAgIElucHV0TWFuYWdlci5rZXlQcmVzc2VkKCkgfHxcbiAgICAgIElucHV0TWFuYWdlci5tb3VzZVByZXNzZWQoKVxuICAgICkge1xuICAgICAgU2NlbmVNYW5hZ2VyLnBvcCgpO1xuICAgICAgU2NlbmVNYW5hZ2VyLnB1c2gobmV3IE1lbnVTY2VuZSgpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmUpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLnRyYW5zaXRpb25BbW91bnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICB0aGlzLnNoYWRlci5zZXRVbmlmb3JtKCd1X3NpZ21hJywgMSAtIHRoaXMudHJhbnNpdGlvbkFtb3VudCk7XG4gICAgICB0aGlzLnNoYWRlci5yZW5kZXIoKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0aGlzLnNoYWRlci5kb21FbGVtZW50LFxuICAgICAgICBHYW1lLnNjcmVlbi54IC8gMiAtIHRoaXMubG9nby53aWR0aCAvIDIsXG4gICAgICAgIEdhbWUuc2NyZWVuLnkgLyAyIC0gdGhpcy5sb2dvLmhlaWdodCAvIDIsXG4gICAgICAgIHRoaXMubG9nby53aWR0aCxcbiAgICAgICAgdGhpcy5sb2dvLmhlaWdodFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBEZWJ1Zy5kcmF3KGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IEdhbWUgZnJvbSAnLi4vR2FtZSc7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgQ29udGVudE1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgY29udGVudCBmcm9tICcuLi8uLi9jb250ZW50L2NvbnRlbnQuanNvbic7XG5pbXBvcnQgSW50cm9TY2VuZSBmcm9tICcuL0ludHJvU2NlbmUnO1xuaW1wb3J0IHsgUHJvZ3Jlc3NCYXIgfSBmcm9tICcuLi9hY3RvcnMnO1xuaW1wb3J0IERlYnVnIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGluZ1NjZW5lIGV4dGVuZHMgU2NlbmUge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBUUkFOU0lUSU9OX1RJTUU6IG51bWJlciA9IDAuNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09PTERPV05fVElNRTogbnVtYmVyID0gMi41O1xuXG4gIHByaXZhdGUgZmluaXNoZWRMb2FkaW5nQ29udGVudDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBwcm9ncmVzc0JhcjogUHJvZ3Jlc3NCYXI7XG4gIHByaXZhdGUgY29vbGRvd25UaW1lOiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2l0aW9uVGltZTogTG9hZGluZ1NjZW5lLlRSQU5TSVRJT05fVElNRSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXNlKCkge1xuICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nQ29udGVudCA9IGZhbHNlO1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIgPSBuZXcgUHJvZ3Jlc3NCYXIoXG4gICAgICB2ZWMyLm1hcCh2ZWMyLm11bChHYW1lLnNjcmVlbiwgMSAvIDIpLCBNYXRoLmZsb29yKSxcbiAgICAgIHZlYzIoMjAwLCA0MClcbiAgICApO1xuICAgIHRoaXMuY29vbGRvd25UaW1lID0gTG9hZGluZ1NjZW5lLkNPT0xET1dOX1RJTUU7XG5cbiAgICBDb250ZW50TWFuYWdlci5sb2FkKGNvbnRlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5maW5pc2hlZExvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICB9KS5jYXRjaCgoZXJyb3I6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3RhbnRzLkRFQlVHICYmIGNvbnNvbGUubG9nKGBVbmFibGUgdG8gbG9hZCBjb250ZW50OiAke2Vycm9yfWApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5wb3NpdGlvbiA9IHZlYzIubWFwKFxuICAgICAgdmVjMi5tdWwoR2FtZS5zY3JlZW4sIDEgLyAyKSxcbiAgICAgIE1hdGguZmxvb3JcbiAgICApO1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIucHJvZ3Jlc3MgPSBDb250ZW50TWFuYWdlci5wcm9ncmVzcztcbiAgICB0aGlzLnByb2dyZXNzQmFyLnVwZGF0ZShkdCk7XG5cbiAgICBpZiAodGhpcy5maW5pc2hlZExvYWRpbmdDb250ZW50KSB7XG4gICAgICB0aGlzLmNvb2xkb3duVGltZSAtPSBkdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb29sZG93blRpbWUgPD0gMCkge1xuICAgICAgU2NlbmVNYW5hZ2VyLnBvcCgpO1xuICAgICAgU2NlbmVNYW5hZ2VyLnB1c2gobmV3IEludHJvU2NlbmUoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICBpZiAodGhpcy50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmUpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLnRyYW5zaXRpb25BbW91bnQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9ncmVzc0Jhci5kcmF3KGNvbnRleHQpO1xuXG4gICAgRGVidWcuZHJhdyhjb250ZXh0KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgR2FtZSBmcm9tICcuLi9HYW1lJztcbmltcG9ydCBTY2VuZU1hbmFnZXIsIHtcbiAgU2NlbmUsXG4gIFNjZW5lVHJhbnNpdGlvblN0YXRlLFxufSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9zY2VuZS1tYW5hZ2VyJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCBJbnB1dE1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlcic7XG5pbXBvcnQgQ29udGVudE1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyJztcbmltcG9ydCBHYW1lU2NlbmUgZnJvbSAnLi9HYW1lU2NlbmUnO1xuaW1wb3J0IHsgSW1hZ2VGb250IH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW1hZ2UtZm9udCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnVTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAxO1xuXG4gIHByaXZhdGUgYmFja2dyb3VuZDogSFRNTEltYWdlRWxlbWVudDtcbiAgcHJpdmF0ZSB0aXRsZTogSFRNTEltYWdlRWxlbWVudDtcbiAgcHJpdmF0ZSBtZW51Rm9udDogSW1hZ2VGb250O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2l0aW9uVGltZTogTWVudVNjZW5lLlRSQU5TSVRJT05fVElNRSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXNlKCkge1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBDb250ZW50TWFuYWdlci5nZXQ8SFRNTEltYWdlRWxlbWVudD4oJ21lbnUtYmFja2dyb3VuZCcpO1xuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgIGNvbnN0IHRpdGxlID0gQ29udGVudE1hbmFnZXIuZ2V0PEhUTUxJbWFnZUVsZW1lbnQ+KCdtZW51LXRpdGxlJyk7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgfVxuXG4gICAgY29uc3QgbWVudUZvbnQgPSBDb250ZW50TWFuYWdlci5nZXQ8SW1hZ2VGb250PignbWVudS1mb250Jyk7XG4gICAgaWYgKG1lbnVGb250KSB7XG4gICAgICB0aGlzLm1lbnVGb250ID0gbWVudUZvbnQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgaWYgKElucHV0TWFuYWdlci5rZXlQcmVzc2VkKCkgfHwgSW5wdXRNYW5hZ2VyLm1vdXNlUHJlc3NlZCgpKSB7XG4gICAgICBTY2VuZU1hbmFnZXIucHVzaChuZXcgR2FtZVNjZW5lKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSAhPT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMudHJhbnNpdGlvbkFtb3VudDtcbiAgICB9XG5cbiAgICAvLyBCYWNrZ3JvdW5kXG4gICAgY29uc3QgbGFyZ2VzdFNjcmVlbkRpbWVuc2lvbiA9IE1hdGgubWF4KEdhbWUuc2NyZWVuLngsIEdhbWUuc2NyZWVuLnkpO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gdGhpcy5iYWNrZ3JvdW5kLndpZHRoIC8gdGhpcy5iYWNrZ3JvdW5kLmhlaWdodDtcbiAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IHZlYzIoXG4gICAgICBsYXJnZXN0U2NyZWVuRGltZW5zaW9uICogYXNwZWN0UmF0aW8sXG4gICAgICBsYXJnZXN0U2NyZWVuRGltZW5zaW9uXG4gICAgKTtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kKSB7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLFxuICAgICAgICBHYW1lLnNjcmVlbi54IC8gMiAtIGJhY2tncm91bmRTaXplLnggLyAyLFxuICAgICAgICBHYW1lLnNjcmVlbi55IC8gMiAtIGJhY2tncm91bmRTaXplLnkgLyAyLFxuICAgICAgICBsYXJnZXN0U2NyZWVuRGltZW5zaW9uICogYXNwZWN0UmF0aW8sXG4gICAgICAgIGxhcmdlc3RTY3JlZW5EaW1lbnNpb25cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGl0bGVcbiAgICBpZiAodGhpcy50aXRsZSkge1xuICAgICAgY29uc3QgeSA9IGxlcnAoXG4gICAgICAgIC0zMDAsXG4gICAgICAgIEdhbWUuc2NyZWVuLnkgLyAyIC0gMjAwLFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25BbW91bnRcbiAgICAgICk7XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0aGlzLnRpdGxlLFxuICAgICAgICBHYW1lLnNjcmVlbi54IC8gMiAtIHRoaXMudGl0bGUud2lkdGggLyAyLFxuICAgICAgICB5XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE1lbnUgdGV4dFxuICAgIGlmICh0aGlzLm1lbnVGb250KSB7XG4gICAgICBjb25zdCB0ZXh0ID0gJ1BSRVNTIEFOWSBLRVkgVE8gU1RBUlQuLi4nO1xuICAgICAgY29uc3QgeSA9IGxlcnAoXG4gICAgICAgIEdhbWUuc2NyZWVuLnkgKyAxMDAsXG4gICAgICAgIEdhbWUuc2NyZWVuLnkgLyAyICsgMTAwLFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25BbW91bnRcbiAgICAgICk7XG5cbiAgICAgIHRoaXMubWVudUZvbnQuZHJhd1RleHQoY29udGV4dCwgdGV4dCwgR2FtZS5zY3JlZW4ueCAvIDIsIHksIHtcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICBzY2FsZTogMC43LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IEdhbWUgZnJvbSAnLi9HYW1lJztcblxud2luZG93Lm9ubG9hZCA9ICgpID0+IHtcbiAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnYW1lJykpO1xuICBnYW1lLmluaXRpYWxpc2UoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=